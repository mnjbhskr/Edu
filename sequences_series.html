<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sequences &amp; Series</title>
    <meta name="description" content="Visualise convergent and divergent sequences and series. Interactive exploration of limits, partial sums, and classic series.">
    <link rel="canonical" href="https://mathsedu.org/sequences_series.html">
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "LearningResource",
      "name": "Sequences & Series",
      "url": "https://mathsedu.org/sequences_series.html",
      "description": "Visualise convergent and divergent sequences and series. Interactive exploration of limits, partial sums, and classic series.",
      "educationalLevel": "Intermediate",
      "teaches": "Sequences and series",
      "learningResourceType": "Interactive visualisation",
      "interactivityType": "active",
      "inLanguage": "en",
      "isAccessibleForFree": true,
      "creator": {
        "@type": "Person",
        "name": "Manoj Bhaskar"
      },
      "license": "https://creativecommons.org/licenses/by-nc-sa/4.0/",
      "isPartOf": {
        "@type": "Course",
        "name": "Analysis & Topology",
        "url": "https://mathsedu.org/"
      }
    }
    </script>
    <meta property="og:title" content="Sequences & Series">
    <meta property="og:description" content="Visualise convergent and divergent sequences and series. Interactive exploration of limits, partial sums, and classic series.">
    <meta property="og:url" content="https://mathsedu.org/sequences_series.html">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="A Visual Discovery of Mathematics">
    <meta property="og:locale" content="en_GB">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Sequences & Series">
    <meta name="twitter:description" content="Visualise convergent and divergent sequences and series. Interactive exploration of limits, partial sums, and classic series.">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a1a;color:#e0e0e0;font-family:Georgia,'Times New Roman',serif;line-height:1.6}
        .container{max-width:960px;margin:0 auto;padding:24px 28px 48px}
        .back{color:#606078;text-decoration:none;font-size:0.85em}
        .back:hover{color:#818cf8}
        h1{font-size:1.8em;font-weight:400;color:#fff;margin:16px 0 4px}
        .subtitle{color:#808098;font-style:italic;margin-bottom:28px}
        h2{font-size:1.15em;font-weight:400;color:#fff;margin:28px 0 12px}
        canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:crosshair}
        .panel{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:18px 22px;margin-bottom:20px}
        .panel h3{font-weight:400;font-size:0.8em;color:#808098;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
        .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
        .btn{background:rgba(255,255,255,0.035);border:1px solid rgba(255,255,255,0.07);color:#b0b0c4;padding:5px 13px;border-radius:6px;cursor:pointer;font-family:Georgia,serif;font-size:0.92em;transition:all 0.2s}
        .btn:hover{background:rgba(255,255,255,0.07);color:#e0e0ef}
        .btn.active{background:rgba(129,140,248,0.13);border-color:rgba(129,140,248,0.4);color:#818cf8}
        .math-line{font-family:'Courier New',monospace;font-size:0.92em;color:#c0c0d8;margin:4px 0;line-height:1.8}
        .math-line .indigo{color:#818cf8}.math-line .cyan{color:#22d3ee}.math-line .green{color:#2ecc71}
        .math-line .gold{color:#fbbf24}.math-line .red{color:#f87171}
        .math-line .muted{color:#808098}
        .slider-row{display:flex;align-items:center;gap:14px;margin:10px 0}
        .slider-row input[type=range]{flex:1;max-width:260px;accent-color:#818cf8}
        .slider-label{color:#818cf8;font-family:'Courier New',monospace;font-size:1.05em;min-width:50px}
        .explain{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:20px 24px;margin-top:20px}
        .explain-name{color:#818cf8;font-size:1.1em;margin-bottom:6px}
        .explain-text{color:#a0a0b8;font-size:0.9em;line-height:1.75}
        .info-row{display:flex;gap:12px;flex-wrap:wrap;margin:8px 0}
        .info-item{font-family:'Courier New',monospace;font-size:0.88em;color:#c0c0d8;padding:4px 10px;background:rgba(255,255,255,0.02);border-radius:5px;border:1px solid rgba(255,255,255,0.04)}
        .info-item .lbl{color:#808098;font-size:0.85em}
        .test-row{display:flex;gap:10px;align-items:center;margin:6px 0;font-size:0.9em}
        .test-badge{display:inline-block;padding:2px 8px;border-radius:4px;font-family:'Courier New',monospace;font-size:0.82em;font-weight:bold}
        .test-badge.pass{background:rgba(46,204,113,0.12);color:#2ecc71;border:1px solid rgba(46,204,113,0.25)}
        .test-badge.fail{background:rgba(248,113,113,0.12);color:#f87171;border:1px solid rgba(248,113,113,0.25)}
        .test-badge.warn{background:rgba(251,191,36,0.12);color:#fbbf24;border:1px solid rgba(251,191,36,0.25)}
        .test-badge.na{background:rgba(128,128,152,0.1);color:#808098;border:1px solid rgba(128,128,152,0.2)}
        .famous-card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05);border-radius:8px;padding:14px 18px;margin-bottom:12px;display:flex;gap:16px;align-items:center}
        .famous-card .formula{flex:1}
        .famous-card .formula .series-name{color:#818cf8;font-size:0.95em;margin-bottom:4px}
        .famous-card .formula .series-terms{font-family:'Courier New',monospace;font-size:0.85em;color:#c0c0d8;line-height:1.7}
        .famous-card .formula .series-result{font-family:'Courier New',monospace;font-size:0.95em;color:#fff;margin-top:4px}
        .famous-card .formula .series-note{color:#808098;font-size:0.8em;margin-top:2px}
        .famous-card canvas{border:none;cursor:default;flex-shrink:0}
        .convergence-zone{display:inline-block;width:10px;height:10px;border-radius:2px;margin-right:4px;vertical-align:middle}
        @media(max-width:600px){canvas{width:100%!important;height:auto!important}}
    </style>
</head>
<body>
<div class="container">
    <a class="back" href="index.html">&larr; Back to Index</a>
    <h1>Sequences &amp; Series</h1>
    <p class="subtitle">Does this sum converge? Harmonic, geometric, and beyond</p>

    <!-- Section 1: Sequence Visualizer -->
    <h2>Sequence Visualizer</h2>
    <div class="panel">
        <h3>Choose a Sequence</h3>
        <div class="btn-row" id="seqBtns"></div>
        <div class="slider-row">
            <span class="math-line muted">N =</span>
            <input type="range" id="seqN" min="0" max="4" value="2">
            <span class="slider-label" id="seqNLabel">50</span>
        </div>
        <div class="slider-row">
            <span class="math-line muted">&epsilon; =</span>
            <input type="range" id="seqEps" min="1" max="100" value="20">
            <span class="slider-label" id="seqEpsLabel">0.20</span>
        </div>
        <canvas id="seqCanvas" width="700" height="350" style="margin-top:10px;cursor:default"></canvas>
        <div id="seqInfo" class="math-line" style="margin-top:10px"></div>
    </div>

    <!-- Section 2: Partial Sums / Series Visualizer -->
    <h2>Partial Sums &mdash; Series Visualizer</h2>
    <div class="panel">
        <h3>Choose a Series</h3>
        <div class="btn-row" id="serBtns"></div>
        <canvas id="serCanvas" width="700" height="350" style="margin-top:10px;cursor:default"></canvas>
        <div id="serInfo" class="info-row" style="margin-top:10px"></div>
    </div>

    <!-- Section 3: Geometric Series Deep Dive -->
    <h2>Geometric Series Deep Dive</h2>
    <div class="panel">
        <h3>Common Ratio r</h3>
        <div class="slider-row">
            <span class="math-line muted">r =</span>
            <input type="range" id="geoR" min="-150" max="150" value="50">
            <span class="slider-label" id="geoRLabel">0.50</span>
        </div>
        <div class="slider-row">
            <span class="math-line muted">n =</span>
            <input type="range" id="geoN" min="1" max="30" value="10">
            <span class="slider-label" id="geoNLabel">10</span>
        </div>
        <canvas id="geoCanvas" width="600" height="350" style="margin-top:10px;cursor:default"></canvas>
        <div id="geoInfo" class="math-line" style="margin-top:10px"></div>
    </div>

    <!-- Section 4: Convergence Tests Panel -->
    <h2>Convergence Tests</h2>
    <div class="panel" id="testPanel">
        <h3>Tests for Currently Selected Series</h3>
        <div id="testResults"></div>
    </div>

    <!-- Section 5: Famous Series Results -->
    <h2>Famous Series</h2>
    <div id="famousPanel"></div>

    <!-- Section 6: Explanation -->
    <div class="explain">
        <div class="explain-name">What have we learnt?</div>
        <div class="explain-text">
            The fundamental question of analysis is: <em>does an infinite process produce a finite result?</em> A sequence converges if its terms eventually cluster within any &epsilon;-band around a limit. A series converges if its partial sums approach a finite value. Convergence tests &mdash; ratio, comparison, integral, alternating series &mdash; give us tools to answer this question without computing every term.
            <br><br>
            The harmonic series is the great surprise: its terms 1/n tend to zero, yet the sum diverges to infinity. This shows that terms shrinking to zero is necessary but not sufficient for convergence. Meanwhile, the closely related p-series with p=2 converges to the beautiful result &pi;&sup2;/6, discovered by Euler in 1735.
            <br><br>
            These ideas connect directly to calculus: Taylor series are power series, and their radius of convergence determines where they faithfully represent a function. Understanding convergence is understanding the boundary between the finite and the infinite.
        </div>
    </div>
</div>

<script>
/* ============================================================
   SEQUENCES & SERIES — Interactive Visualizer
   ============================================================ */

/* -- N steps lookup -- */
const nSteps = [10, 20, 50, 100, 200];

/* ============================================================
   SECTION 1: SEQUENCE VISUALIZER
   ============================================================ */
const seqPresets = [
    { label: '1/n', fn: n => 1/n, limit: 0, limitLabel: '0', converges: true },
    { label: '(-1)^n / n', fn: n => Math.pow(-1,n)/n, limit: 0, limitLabel: '0', converges: true },
    { label: 'n/(n+1)', fn: n => n/(n+1), limit: 1, limitLabel: '1', converges: true },
    { label: '(1+1/n)^n', fn: n => Math.pow(1+1/n,n), limit: Math.E, limitLabel: 'e', converges: true },
    { label: 'sin(n)/n', fn: n => Math.sin(n)/n, limit: 0, limitLabel: '0', converges: true },
    { label: '(-1)^n', fn: n => Math.pow(-1,n), limit: null, limitLabel: null, converges: false },
    { label: 'n', fn: n => n, limit: null, limitLabel: null, converges: false }
];
let activeSeq = 0;

function renderSeqBtns() {
    const c = document.getElementById('seqBtns');
    c.innerHTML = seqPresets.map((s, i) =>
        '<button class="btn' + (i === activeSeq ? ' active' : '') + '" data-si="' + i + '">' + s.label + '</button>'
    ).join('');
    c.querySelectorAll('.btn').forEach(b => b.addEventListener('click', () => {
        activeSeq = parseInt(b.dataset.si);
        renderSeqBtns();
        drawSeq();
    }));
}

function drawSeq() {
    const cvs = document.getElementById('seqCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const preset = seqPresets[activeSeq];
    const N = nSteps[parseInt(document.getElementById('seqN').value)];
    const eps = parseFloat(document.getElementById('seqEps').value) / 100;

    document.getElementById('seqNLabel').textContent = N;
    document.getElementById('seqEpsLabel').textContent = eps.toFixed(2);

    // Compute sequence values
    const vals = [];
    for (let n = 1; n <= N; n++) vals.push({ n, v: preset.fn(n) });

    // Y range
    let yMin = Infinity, yMax = -Infinity;
    for (const p of vals) {
        if (isFinite(p.v)) { yMin = Math.min(yMin, p.v); yMax = Math.max(yMax, p.v); }
    }
    if (preset.converges) {
        yMin = Math.min(yMin, preset.limit - eps);
        yMax = Math.max(yMax, preset.limit + eps);
    }
    const yPad = (yMax - yMin) * 0.1 || 0.5;
    yMin -= yPad; yMax += yPad;

    const padL = 60, padR = 20, padT = 20, padB = 40;
    const plotW = W - padL - padR, plotH = H - padT - padB;

    function toX(n) { return padL + (n - 1) / (N - 1) * plotW; }
    function toY(v) { return padT + (1 - (v - yMin) / (yMax - yMin)) * plotH; }

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, W, H);

    // Grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    const yTicks = niceTicksFor(yMin, yMax, 6);
    for (const t of yTicks) {
        const y = toY(t);
        ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W - padR, y); ctx.stroke();
    }
    const xTickCount = Math.min(N, 10);
    const xStep = Math.max(1, Math.floor(N / xTickCount));
    for (let n = 1; n <= N; n += xStep) {
        const x = toX(n);
        ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, H - padB); ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(padL, H - padB); ctx.lineTo(W - padR, H - padB); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, H - padB); ctx.stroke();

    // Tick labels
    ctx.font = '10px Georgia';
    ctx.fillStyle = '#505068';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for (let n = 1; n <= N; n += xStep) {
        ctx.fillText(n, toX(n), H - padB + 6);
    }
    if (N % xStep !== 1) ctx.fillText(N, toX(N), H - padB + 6);
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (const t of yTicks) {
        ctx.fillText(t.toFixed(2), padL - 6, toY(t));
    }

    // Axis labels
    ctx.font = '12px Georgia';
    ctx.fillStyle = '#808098';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('n', padL + plotW / 2, H - 14);
    ctx.save();
    ctx.translate(14, padT + plotH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('a_n', 0, 0);
    ctx.restore();

    // Epsilon band + limit line
    let firstInEps = null;
    if (preset.converges) {
        const L = preset.limit;
        const yTop = toY(L + eps);
        const yBot = toY(L - eps);
        ctx.fillStyle = 'rgba(129,140,248,0.08)';
        ctx.fillRect(padL, yTop, plotW, yBot - yTop);

        // Epsilon band borders
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = 'rgba(129,140,248,0.25)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(padL, yTop); ctx.lineTo(W - padR, yTop); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(padL, yBot); ctx.lineTo(W - padR, yBot); ctx.stroke();

        // Limit line
        ctx.strokeStyle = 'rgba(129,140,248,0.6)';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(padL, toY(L)); ctx.lineTo(W - padR, toY(L)); ctx.stroke();
        ctx.setLineDash([]);

        // Label
        ctx.font = '11px Courier New';
        ctx.fillStyle = '#818cf8';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillText('L = ' + preset.limitLabel + ' (' + L.toFixed(4) + ')', W - padR - 160, toY(L) - 4);
        ctx.fillStyle = 'rgba(129,140,248,0.5)';
        ctx.textBaseline = 'bottom';
        ctx.fillText('L+\u03B5', W - padR + 2, yTop + 12);
        ctx.fillText('L-\u03B5', W - padR + 2, yBot + 12);

        // Find first n where all subsequent terms are within eps
        for (let i = 0; i < vals.length; i++) {
            let allIn = true;
            for (let j = i; j < vals.length; j++) {
                if (Math.abs(vals[j].v - L) > eps) { allIn = false; break; }
            }
            if (allIn) { firstInEps = vals[i].n; break; }
        }
    }

    // Sequence dots
    for (const p of vals) {
        if (!isFinite(p.v)) continue;
        const x = toX(p.n), y = toY(p.v);
        if (y < padT || y > H - padB) continue;
        ctx.fillStyle = '#818cf8';
        ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI * 2); ctx.fill();
    }

    // Info text
    const info = document.getElementById('seqInfo');
    if (preset.converges) {
        const lastVal = vals[vals.length - 1].v;
        let txt = '<span class="indigo">a_' + N + ' = ' + lastVal.toFixed(6) + '</span>';
        txt += ' &ensp; <span class="muted">Limit L = ' + preset.limitLabel + '</span>';
        if (firstInEps !== null) {
            txt += ' &ensp; <span class="green">All terms after n = ' + firstInEps + ' are within \u03B5 of L</span>';
        } else {
            txt += ' &ensp; <span class="gold">Not all terms within \u03B5 yet (increase N or \u03B5)</span>';
        }
        info.innerHTML = txt;
    } else {
        info.innerHTML = '<span class="red">Diverges</span> &mdash; no finite limit exists';
    }
}

/* ============================================================
   SECTION 2: PARTIAL SUMS — SERIES VISUALIZER
   ============================================================ */
const serPresets = [
    { label: 'Geometric (r=1/2)', fn: n => Math.pow(0.5, n), limit: 1, limitLabel: '1', converges: true, note: 'Converges: sum = 1' },
    { label: 'Geometric (r=2/3)', fn: n => Math.pow(2/3, n), limit: 2, limitLabel: '2', converges: true, note: 'Converges: sum = 2' },
    { label: 'Geometric (r=1)', fn: n => 1, limit: null, limitLabel: null, converges: false, note: 'Diverges to infinity' },
    { label: 'Harmonic 1/n', fn: n => 1/n, limit: null, limitLabel: null, converges: false, note: 'Diverges but incredibly slowly' },
    { label: '1/n\u00B2 (Basel)', fn: n => 1/(n*n), limit: Math.PI*Math.PI/6, limitLabel: '\u03C0\u00B2/6', converges: true, note: 'Basel problem: \u03C0\u00B2/6' },
    { label: 'Alt. harmonic', fn: n => Math.pow(-1, n+1)/n, limit: Math.LN2, limitLabel: 'ln(2)', converges: true, note: 'Conditionally convergent' },
    { label: 'Telescoping', fn: n => 1/n - 1/(n+1), limit: 1, limitLabel: '1', converges: true, note: 'Cancellation: sum = 1' }
];
let activeSer = 0;

function renderSerBtns() {
    const c = document.getElementById('serBtns');
    c.innerHTML = serPresets.map((s, i) =>
        '<button class="btn' + (i === activeSer ? ' active' : '') + '" data-si="' + i + '">' + s.label + '</button>'
    ).join('');
    c.querySelectorAll('.btn').forEach(b => b.addEventListener('click', () => {
        activeSer = parseInt(b.dataset.si);
        renderSerBtns();
        drawSer();
        renderTests();
    }));
}

function drawSer() {
    const cvs = document.getElementById('serCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const preset = serPresets[activeSer];
    const N = nSteps[parseInt(document.getElementById('seqN').value)];

    // Compute partial sums
    const sums = [];
    let S = 0;
    for (let n = 1; n <= N; n++) {
        S += preset.fn(n);
        sums.push({ n, s: S });
    }

    // Y range
    let yMin = 0, yMax = 0;
    for (const p of sums) {
        if (isFinite(p.s)) { yMin = Math.min(yMin, p.s); yMax = Math.max(yMax, p.s); }
    }
    if (preset.converges && preset.limit !== null) {
        yMin = Math.min(yMin, preset.limit);
        yMax = Math.max(yMax, preset.limit);
    }
    const yPad = (yMax - yMin) * 0.1 || 0.5;
    yMin -= yPad; yMax += yPad;

    const padL = 70, padR = 20, padT = 20, padB = 40;
    const plotW = W - padL - padR, plotH = H - padT - padB;

    function toX(n) { return padL + (n - 1) / Math.max(N - 1, 1) * plotW; }
    function toY(v) { return padT + (1 - (v - yMin) / (yMax - yMin)) * plotH; }

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, W, H);

    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    const yTicks = niceTicksFor(yMin, yMax, 6);
    for (const t of yTicks) {
        const y = toY(t);
        ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W - padR, y); ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(padL, H - padB); ctx.lineTo(W - padR, H - padB); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, H - padB); ctx.stroke();

    // Tick labels
    ctx.font = '10px Georgia';
    ctx.fillStyle = '#505068';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (const t of yTicks) {
        ctx.fillText(t.toFixed(2), padL - 6, toY(t));
    }
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const xTickCount = Math.min(N, 10);
    const xStep = Math.max(1, Math.floor(N / xTickCount));
    for (let n = 1; n <= N; n += xStep) {
        ctx.fillText(n, toX(n), H - padB + 6);
    }
    if (N % xStep !== 1) ctx.fillText(N, toX(N), H - padB + 6);

    // Axis labels
    ctx.font = '12px Georgia';
    ctx.fillStyle = '#808098';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('n', padL + plotW / 2, H - 14);
    ctx.save();
    ctx.translate(14, padT + plotH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('S_n', 0, 0);
    ctx.restore();

    // Limit line
    if (preset.converges && preset.limit !== null) {
        const ly = toY(preset.limit);
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = 'rgba(129,140,248,0.6)';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(padL, ly); ctx.lineTo(W - padR, ly); ctx.stroke();
        ctx.setLineDash([]);
        ctx.font = '11px Courier New';
        ctx.fillStyle = '#818cf8';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillText('S = ' + preset.limitLabel, W - padR - 100, ly - 4);
    }

    // Partial sum line
    ctx.strokeStyle = '#22d3ee';
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started = false;
    for (const p of sums) {
        if (!isFinite(p.s)) continue;
        const x = toX(p.n), y = toY(p.s);
        if (y < padT - 10 || y > H - padB + 10) continue;
        if (!started) { ctx.moveTo(x, y); started = true; }
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Dots on partial sums
    for (const p of sums) {
        if (!isFinite(p.s)) continue;
        const x = toX(p.n), y = toY(p.s);
        if (y < padT - 5 || y > H - padB + 5) continue;
        ctx.fillStyle = '#22d3ee';
        ctx.beginPath(); ctx.arc(x, y, 2.5, 0, Math.PI * 2); ctx.fill();
    }

    // Divergence annotation
    if (!preset.converges) {
        ctx.font = '14px Georgia';
        ctx.fillStyle = '#f87171';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.fillText('Diverges', W - padR - 10, padT + 10);
        if (activeSer === 3) {
            ctx.font = '10px Georgia';
            ctx.fillStyle = '#808098';
            ctx.fillText('(incredibly slowly)', W - padR - 10, padT + 28);
        }
    }

    // Info
    const lastSum = sums[sums.length - 1].s;
    const info = document.getElementById('serInfo');
    let html = '<div class="info-item"><span class="lbl">S_' + N + '</span> ' + lastSum.toFixed(6) + '</div>';
    if (preset.converges && preset.limit !== null) {
        html += '<div class="info-item"><span class="lbl">Limit</span> ' + preset.limitLabel + ' (' + preset.limit.toFixed(6) + ')</div>';
        html += '<div class="info-item"><span class="lbl">|S_n - S|</span> ' + Math.abs(lastSum - preset.limit).toFixed(8) + '</div>';
    }
    html += '<div class="info-item"><span class="lbl">Note</span> ' + preset.note + '</div>';
    info.innerHTML = html;
}

/* ============================================================
   SECTION 3: GEOMETRIC SERIES DEEP DIVE
   ============================================================ */
function drawGeo() {
    const cvs = document.getElementById('geoCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const r = parseInt(document.getElementById('geoR').value) / 100;
    const n = parseInt(document.getElementById('geoN').value);

    document.getElementById('geoRLabel').textContent = r.toFixed(2);
    document.getElementById('geoNLabel').textContent = n;

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, W, H);

    const padL = 60, padR = 30, padT = 50, padB = 60;
    const plotW = W - padL - padR, plotH = H - padT - padB;

    // Compute partial sums
    const sums = [];
    let S = 0;
    for (let k = 0; k <= n; k++) {
        S += Math.pow(r, k);
        sums.push({ k, s: S, term: Math.pow(r, k) });
    }

    // Determine convergence
    const absR = Math.abs(r);
    const converges = absR < 1;
    const exactLimit = converges ? 1 / (1 - r) : null;

    // Y range
    let yMin = 0, yMax = 0;
    for (const p of sums) {
        yMin = Math.min(yMin, p.s);
        yMax = Math.max(yMax, p.s);
    }
    if (converges && exactLimit !== null) {
        yMin = Math.min(yMin, exactLimit);
        yMax = Math.max(yMax, exactLimit);
    }
    const yPad = (yMax - yMin) * 0.12 || 1;
    yMin -= yPad; yMax += yPad;

    function toX(k) { return padL + k / n * plotW; }
    function toY(v) { return padT + (1 - (v - yMin) / (yMax - yMin)) * plotH; }

    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    const yTicks = niceTicksFor(yMin, yMax, 5);
    for (const t of yTicks) {
        const y = toY(t);
        ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W - padR, y); ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(padL, H - padB); ctx.lineTo(W - padR, H - padB); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, H - padB); ctx.stroke();

    // Tick labels
    ctx.font = '10px Georgia';
    ctx.fillStyle = '#505068';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (const t of yTicks) {
        ctx.fillText(t.toFixed(2), padL - 6, toY(t));
    }
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for (let k = 0; k <= n; k += Math.max(1, Math.floor(n / 10))) {
        ctx.fillText(k, toX(k), H - padB + 6);
    }

    // Convergence zone indicator at top
    ctx.font = '11px Courier New';
    if (converges) {
        ctx.fillStyle = 'rgba(46,204,113,0.15)';
        ctx.fillRect(padL, 8, plotW, 28);
        ctx.fillStyle = '#2ecc71';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('|r| < 1 : Converges to 1/(1-r) = ' + exactLimit.toFixed(4), padL + plotW / 2, 22);
    } else if (absR === 1) {
        ctx.fillStyle = 'rgba(251,191,36,0.12)';
        ctx.fillRect(padL, 8, plotW, 28);
        ctx.fillStyle = '#fbbf24';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('|r| = 1 : Diverges (boundary case)', padL + plotW / 2, 22);
    } else {
        ctx.fillStyle = 'rgba(248,113,113,0.12)';
        ctx.fillRect(padL, 8, plotW, 28);
        ctx.fillStyle = '#f87171';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('|r| > 1 : Diverges \u2014 terms grow without bound', padL + plotW / 2, 22);
    }

    // Limit line
    if (converges && exactLimit !== null) {
        const ly = toY(exactLimit);
        if (ly > padT && ly < H - padB) {
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = 'rgba(46,204,113,0.6)';
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(padL, ly); ctx.lineTo(W - padR, ly); ctx.stroke();
            ctx.setLineDash([]);
            ctx.font = '10px Courier New';
            ctx.fillStyle = '#2ecc71';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.fillText('1/(1-r) = ' + exactLimit.toFixed(4), W - padR, ly - 3);
        }
    }

    // Segment visualization — stacked bars showing each term
    const barW = Math.max(2, plotW / (n + 1) * 0.6);
    for (let i = 0; i <= n; i++) {
        const p = sums[i];
        const prevS = i > 0 ? sums[i - 1].s : 0;
        const x = toX(p.k) - barW / 2;
        const yTop = toY(p.s);
        const yBot = toY(prevS);
        const termPositive = p.term >= 0;
        ctx.fillStyle = termPositive ? 'rgba(129,140,248,0.3)' : 'rgba(248,113,113,0.2)';
        ctx.fillRect(x, Math.min(yTop, yBot), barW, Math.abs(yBot - yTop));
        ctx.strokeStyle = termPositive ? 'rgba(129,140,248,0.5)' : 'rgba(248,113,113,0.4)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, Math.min(yTop, yBot), barW, Math.abs(yBot - yTop));
    }

    // Partial sum line
    ctx.strokeStyle = '#22d3ee';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i <= n; i++) {
        const x = toX(sums[i].k), y = toY(sums[i].s);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Dots
    for (let i = 0; i <= n; i++) {
        const x = toX(sums[i].k), y = toY(sums[i].s);
        ctx.fillStyle = '#22d3ee';
        ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI * 2); ctx.fill();
    }

    // Info
    const lastS = sums[sums.length - 1].s;
    const formulaS = Math.abs(r - 1) > 1e-10 ? (1 - Math.pow(r, n + 1)) / (1 - r) : n + 1;
    let info = '<span class="muted">S_' + n + ' = (1 - r^' + (n + 1) + ')/(1-r) = ' + formulaS.toFixed(6) + '</span>';
    if (converges) {
        info += ' &ensp; <span class="green">Limit = ' + exactLimit.toFixed(6) + '</span>';
        info += ' &ensp; <span class="muted">|S_n - S| = ' + Math.abs(lastS - exactLimit).toFixed(8) + '</span>';
    }
    document.getElementById('geoInfo').innerHTML = info;
}

/* ============================================================
   SECTION 4: CONVERGENCE TESTS
   ============================================================ */
function renderTests() {
    const preset = serPresets[activeSer];
    const div = document.getElementById('testResults');
    const tests = computeTests(activeSer);
    let html = '';
    for (const t of tests) {
        let badgeCls, badgeTxt;
        if (t.result === 'converges') { badgeCls = 'pass'; badgeTxt = 'Converges'; }
        else if (t.result === 'diverges') { badgeCls = 'fail'; badgeTxt = 'Diverges'; }
        else if (t.result === 'inconclusive') { badgeCls = 'warn'; badgeTxt = 'Inconclusive'; }
        else { badgeCls = 'na'; badgeTxt = 'N/A'; }

        html += '<div class="test-row">';
        html += '<span class="test-badge ' + badgeCls + '">' + badgeTxt + '</span>';
        html += '<span style="color:#818cf8;font-size:0.9em;min-width:140px;display:inline-block">' + t.name + '</span>';
        html += '<span class="math-line muted" style="font-size:0.85em">' + t.detail + '</span>';
        html += '</div>';
    }
    div.innerHTML = html;
}

function computeTests(serIdx) {
    const tests = [];

    // Ratio Test
    const ratioData = computeRatioTest(serIdx);
    tests.push({ name: 'Ratio Test', ...ratioData });

    // Comparison Test
    const compData = computeComparisonTest(serIdx);
    tests.push({ name: 'Comparison Test', ...compData });

    // Integral Test
    const intData = computeIntegralTest(serIdx);
    tests.push({ name: 'Integral Test', ...intData });

    // Alternating Series Test
    const altData = computeAltTest(serIdx);
    tests.push({ name: 'Alternating Series Test', ...altData });

    return tests;
}

function computeRatioTest(idx) {
    // Compute lim |a_{n+1}/a_n| for large n
    const fn = serPresets[idx].fn;
    const ratios = [];
    for (let n = 50; n <= 100; n++) {
        const an = fn(n), an1 = fn(n + 1);
        if (Math.abs(an) > 1e-15) ratios.push(Math.abs(an1 / an));
    }
    if (ratios.length === 0) return { result: 'na', detail: 'Cannot compute ratio' };
    const avgRatio = ratios.reduce((a, b) => a + b, 0) / ratios.length;

    if (idx === 0) return { result: 'converges', detail: 'lim |a_(n+1)/a_n| = |r| = 0.50 < 1' }; // geo r=1/2
    if (idx === 1) return { result: 'converges', detail: 'lim |a_(n+1)/a_n| = |r| = 0.67 < 1' }; // geo r=2/3
    if (idx === 2) return { result: 'diverges', detail: 'lim |a_(n+1)/a_n| = 1 (all terms = 1), but sum clearly diverges' };

    if (Math.abs(avgRatio - 1) < 0.02) return { result: 'inconclusive', detail: 'lim |a_(n+1)/a_n| = ' + avgRatio.toFixed(4) + ' = 1' };
    if (avgRatio < 0.999) return { result: 'converges', detail: 'lim |a_(n+1)/a_n| = ' + avgRatio.toFixed(4) + ' < 1' };
    return { result: 'diverges', detail: 'lim |a_(n+1)/a_n| = ' + avgRatio.toFixed(4) + ' > 1' };
}

function computeComparisonTest(idx) {
    switch (idx) {
        case 0: return { result: 'converges', detail: '(1/2)^n < (1/2)^n: compare with itself, geometric with |r|<1' };
        case 1: return { result: 'converges', detail: '(2/3)^n < (2/3)^n: geometric series with |r|<1' };
        case 2: return { result: 'diverges', detail: 'a_n = 1 for all n, partial sums grow without bound' };
        case 3: return { result: 'diverges', detail: '1/n > 1/n: harmonic series diverges (compare with integral)' };
        case 4: return { result: 'converges', detail: '1/n\u00B2 < 1/n(n-1) = telescoping series, converges' };
        case 5: return { result: 'na', detail: 'Comparison test requires non-negative terms (use alternating series test)' };
        case 6: return { result: 'converges', detail: '1/n - 1/(n+1) = 1/[n(n+1)] < 1/n\u00B2, and p-series p=2 converges' };
        default: return { result: 'na', detail: '' };
    }
}

function computeIntegralTest(idx) {
    switch (idx) {
        case 0: return { result: 'converges', detail: '\u222B (1/2)^x dx converges (exponential decay)' };
        case 1: return { result: 'converges', detail: '\u222B (2/3)^x dx converges (exponential decay)' };
        case 2: return { result: 'diverges', detail: '\u222B 1 dx = x \u2192 \u221E' };
        case 3: return { result: 'diverges', detail: '\u222B 1/x dx = ln(x) \u2192 \u221E' };
        case 4: return { result: 'converges', detail: '\u222B 1/x\u00B2 dx = -1/x \u2192 1 (finite)' };
        case 5: return { result: 'na', detail: 'Integral test requires positive, decreasing terms' };
        case 6: return { result: 'converges', detail: '\u222B 1/[x(x+1)] dx = ln(x/(x+1)) converges' };
        default: return { result: 'na', detail: '' };
    }
}

function computeAltTest(idx) {
    switch (idx) {
        case 5: return { result: 'converges', detail: '|a_n| = 1/n decreasing to 0, signs alternate: converges by Leibniz' };
        default: return { result: 'na', detail: 'Not an alternating series' };
    }
}

/* ============================================================
   SECTION 5: FAMOUS SERIES
   ============================================================ */
const famousSeries = [
    {
        name: 'Basel Problem (Euler, 1735)',
        terms: '1/1\u00B2 + 1/2\u00B2 + 1/3\u00B2 + 1/4\u00B2 + ...',
        result: '\u03C0\u00B2/6 = ' + (Math.PI * Math.PI / 6).toFixed(6),
        note: 'Euler solved this famous problem at age 28, establishing his reputation.',
        fn: n => 1 / (n * n),
        limit: Math.PI * Math.PI / 6
    },
    {
        name: 'Alternating Harmonic Series',
        terms: '1 - 1/2 + 1/3 - 1/4 + ...',
        result: 'ln(2) = ' + Math.LN2.toFixed(6),
        note: 'Conditionally convergent: rearranging terms can give any sum (Riemann).',
        fn: n => Math.pow(-1, n + 1) / n,
        limit: Math.LN2
    },
    {
        name: 'Exponential Series',
        terms: '1/0! + 1/1! + 1/2! + 1/3! + ...',
        result: 'e = ' + Math.E.toFixed(6),
        note: 'Converges extremely fast due to factorial denominators.',
        fn: (function () { let fac = 1; const cache = [1]; for (let i = 1; i <= 200; i++) { fac *= i; cache[i] = fac; } return n => 1 / cache[n]; })(),
        limit: Math.E
    },
    {
        name: 'Leibniz Formula for \u03C0',
        terms: '1 - 1/3 + 1/5 - 1/7 + ...',
        result: '\u03C0/4 = ' + (Math.PI / 4).toFixed(6),
        note: 'Beautiful but slow: needs millions of terms for good accuracy.',
        fn: n => Math.pow(-1, n) / (2 * n + 1),
        limit: Math.PI / 4,
        startAt0: true
    },
    {
        name: 'Geometric Series (r = 1/2)',
        terms: '1/2 + 1/4 + 1/8 + 1/16 + ...',
        result: '1',
        note: 'The simplest convergent series: half of what remains, forever.',
        fn: n => Math.pow(0.5, n),
        limit: 1
    }
];

function renderFamous() {
    const container = document.getElementById('famousPanel');
    let html = '';
    famousSeries.forEach((s, i) => {
        html += '<div class="famous-card">';
        html += '<div class="formula">';
        html += '<div class="series-name">' + s.name + '</div>';
        html += '<div class="series-terms">' + s.terms + '</div>';
        html += '<div class="series-result">= ' + s.result + '</div>';
        html += '<div class="series-note">' + s.note + '</div>';
        html += '</div>';
        html += '<canvas id="sparkline' + i + '" width="120" height="50" style="border-radius:6px"></canvas>';
        html += '</div>';
    });
    container.innerHTML = html;

    // Draw sparklines
    famousSeries.forEach((s, i) => drawSparkline(i, s));
}

function drawSparkline(idx, series) {
    const cvs = document.getElementById('sparkline' + idx);
    if (!cvs) return;
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = 'rgba(255,255,255,0.015)';
    ctx.fillRect(0, 0, W, H);

    const N = 40;
    const sums = [];
    let S = 0;
    const startK = series.startAt0 ? 0 : 1;
    for (let k = startK; k < startK + N; k++) {
        S += series.fn(k);
        sums.push(S);
    }

    let yMin = Math.min(...sums, series.limit);
    let yMax = Math.max(...sums, series.limit);
    const yPad = (yMax - yMin) * 0.15 || 0.1;
    yMin -= yPad; yMax += yPad;

    const pad = 4;
    function toX(i) { return pad + i / (N - 1) * (W - 2 * pad); }
    function toY(v) { return pad + (1 - (v - yMin) / (yMax - yMin)) * (H - 2 * pad); }

    // Limit line
    ctx.setLineDash([2, 2]);
    ctx.strokeStyle = 'rgba(129,140,248,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, toY(series.limit));
    ctx.lineTo(W, toY(series.limit));
    ctx.stroke();
    ctx.setLineDash([]);

    // Line
    ctx.strokeStyle = '#818cf8';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let i = 0; i < sums.length; i++) {
        const x = toX(i), y = toY(sums[i]);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
}

/* ============================================================
   UTILITY: Nice tick marks
   ============================================================ */
function niceTicksFor(min, max, count) {
    const range = max - min;
    if (range <= 0) return [min];
    const rough = range / count;
    const mag = Math.pow(10, Math.floor(Math.log10(rough)));
    let step;
    if (rough / mag < 1.5) step = mag;
    else if (rough / mag < 3.5) step = 2 * mag;
    else if (rough / mag < 7.5) step = 5 * mag;
    else step = 10 * mag;
    const ticks = [];
    let t = Math.ceil(min / step) * step;
    while (t <= max + step * 0.01) {
        ticks.push(t);
        t += step;
    }
    return ticks;
}

/* ============================================================
   EVENT WIRING
   ============================================================ */
// N slider controls Sections 1 and 2
document.getElementById('seqN').addEventListener('input', () => { drawSeq(); drawSer(); });
document.getElementById('seqEps').addEventListener('input', drawSeq);
document.getElementById('geoR').addEventListener('input', drawGeo);
document.getElementById('geoN').addEventListener('input', drawGeo);

// Touch support for sliders
['seqN', 'seqEps', 'geoR', 'geoN'].forEach(id => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', e => { e.stopPropagation(); }, { passive: true });
    el.addEventListener('touchmove', e => { e.stopPropagation(); }, { passive: true });
});

/* ============================================================
   INITIAL RENDER
   ============================================================ */
renderSeqBtns();
renderSerBtns();
drawSeq();
drawSer();
drawGeo();
renderTests();
renderFamous();
</script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Coded by <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
