<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inverse Trigonometric Functions</title>
    <meta name="description" content="Explore arcsin, arccos, and arctan with interactive graphs. Visualise domains, ranges, and the relationship to forward trig functions.">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a1a;color:#e0e0e0;font-family:Georgia,'Times New Roman',serif;line-height:1.6}
        .container{max-width:960px;margin:0 auto;padding:24px 28px 48px}
        .back{color:#606078;text-decoration:none;font-size:0.85em}
        .back:hover{color:#34d399}
        h1{font-size:1.8em;font-weight:400;color:#fff;margin:16px 0 4px}
        .subtitle{color:#808098;font-style:italic;margin-bottom:28px}
        h2{font-size:1.15em;font-weight:400;color:#fff;margin:28px 0 12px}
        canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:crosshair}
        .panel{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:18px 22px;margin-bottom:20px}
        .panel h3{font-weight:400;font-size:0.8em;color:#808098;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
        .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
        .btn{background:rgba(255,255,255,0.035);border:1px solid rgba(255,255,255,0.07);color:#b0b0c4;padding:5px 13px;border-radius:6px;cursor:pointer;font-family:Georgia,serif;font-size:0.92em;transition:all 0.2s}
        .btn:hover{background:rgba(255,255,255,0.07);color:#e0e0ef}
        .btn.active{background:rgba(52,211,153,0.13);border-color:rgba(52,211,153,0.4);color:#34d399}
        .math-line{font-family:'Courier New',monospace;font-size:0.92em;color:#c0c0d8;margin:4px 0;line-height:1.8}
        .math-line .emerald{color:#34d399}.math-line .gold{color:#fbbf24}.math-line .blue{color:#60a5fa}
        .math-line .muted{color:#808098}
        .explain{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:20px 24px;margin-top:20px}
        .explain-name{color:#34d399;font-size:1.1em;margin-bottom:6px}
        .explain-text{color:#a0a0b8;font-size:0.9em;line-height:1.75}
        .slider-row{display:flex;align-items:center;gap:14px;margin:10px 0}
        .slider-row input[type=range]{flex:1;max-width:320px;accent-color:#34d399}
        .slider-label{color:#34d399;font-family:'Courier New',monospace;font-size:1.05em;min-width:80px}
        .flex-row{display:flex;gap:20px;flex-wrap:wrap}
        .flex-row>.flex-half{flex:1 1 300px;min-width:280px}
        .warning{background:rgba(251,191,36,0.08);border:1px solid rgba(251,191,36,0.2);border-radius:8px;padding:12px 16px;margin:10px 0;color:#fbbf24;font-size:0.88em}
        .identity-row{display:flex;align-items:center;gap:12px;flex-wrap:wrap;padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.04)}
        .identity-row:last-child{border-bottom:none}
        .identity-eq{font-family:'Courier New',monospace;font-size:0.88em;color:#c0c0d8;min-width:260px}
        .identity-val{font-family:'Courier New',monospace;font-size:0.88em;color:#34d399;min-width:120px}
        .identity-check{font-size:0.85em;color:#808098}
        .section-note{color:#808098;font-size:0.85em;line-height:1.7;margin-top:8px}
        @media(max-width:700px){canvas{width:100%!important;height:auto!important}}
    </style>
</head>
<body>
<div class="container">
    <a class="back" href="index.html">&larr; Back to Index</a>
    <h1>Inverse Trigonometric Functions</h1>
    <p class="subtitle">Going backwards &mdash; from ratio to angle</p>

    <!-- ═══════════ SECTION 1: Why We Need Restricted Domains ═══════════ -->
    <h2>1. Why We Need Restricted Domains</h2>
    <div class="panel">
        <h3>The Problem of Many Solutions</h3>
        <div class="btn-row" id="s1Btns"></div>
        <canvas id="domainCanvas" width="700" height="350"></canvas>
        <div class="slider-row">
            <span class="math-line muted">y =</span>
            <input type="range" id="s1YSlider" min="-100" max="100" value="50">
            <span class="slider-label" id="s1YLabel">0.50</span>
        </div>
        <div id="s1Info" class="math-line" style="margin-top:8px"></div>
        <p class="section-note">The horizontal line y = 0.5 crosses sin(x) infinitely many times. To define an inverse, we must restrict the domain so the function is one-to-one. The emerald highlighted portion shows the restricted domain where the horizontal line test passes.</p>
    </div>

    <!-- ═══════════ SECTION 2: The Reflection ═══════════ -->
    <h2>2. The Reflection &mdash; Graph of Inverse</h2>
    <div class="panel">
        <h3>Original &amp; Inverse Functions</h3>
        <div class="btn-row" id="s2Btns"></div>
        <canvas id="reflectCanvas" width="700" height="400"></canvas>
        <div class="slider-row">
            <span class="math-line muted">input x =</span>
            <input type="range" id="s2Slider" min="-100" max="100" value="50">
            <span class="slider-label" id="s2Label">0.50</span>
        </div>
        <div style="display:flex;gap:12px;margin-top:8px;align-items:center">
            <button class="btn" id="s2AnimBtn">Animate Reflection</button>
            <span class="math-line" id="s2Info"></span>
        </div>
        <div id="s2KeyValues" class="math-line" style="margin-top:10px"></div>
    </div>

    <!-- ═══════════ SECTION 3: Interactive Calculator with Unit Circle ═══════════ -->
    <h2>3. Interactive Calculator with Unit Circle</h2>
    <div class="panel">
        <h3>From Ratio to Angle</h3>
        <div class="btn-row" id="s3Btns"></div>
        <div class="flex-row">
            <div class="flex-half">
                <canvas id="unitCircleCanvas" width="400" height="400" style="max-width:100%"></canvas>
            </div>
            <div class="flex-half" style="display:flex;flex-direction:column;justify-content:center">
                <div class="slider-row">
                    <span class="math-line muted" id="s3InputLabel">y =</span>
                    <input type="range" id="s3Slider" min="-100" max="100" value="50" step="1">
                    <span class="slider-label" id="s3ValLabel">0.50</span>
                </div>
                <div id="s3Result" class="math-line" style="margin-top:12px;line-height:2.2"></div>
            </div>
        </div>
    </div>

    <!-- ═══════════ SECTION 4: Key Identities ═══════════ -->
    <h2>4. Key Identities</h2>
    <div class="panel">
        <h3>Verify Interactively</h3>
        <div class="btn-row" id="s4Btns"></div>
        <div class="slider-row">
            <span class="math-line muted">x =</span>
            <input type="range" id="s4Slider" min="-100" max="100" value="50" step="1">
            <span class="slider-label" id="s4XLabel">0.50</span>
        </div>
        <div id="s4Identities" style="margin-top:12px"></div>
        <div id="s4Warning"></div>
    </div>

    <!-- ═══════════ SECTION 5: Derivatives of Inverse Trig ═══════════ -->
    <h2>5. Derivatives of Inverse Trig Functions</h2>
    <div class="panel">
        <h3>Connecting Trigonometry to Algebra</h3>
        <div class="btn-row" id="s5Btns"></div>
        <canvas id="derivCanvas" width="500" height="300"></canvas>
        <div id="s5Info" class="math-line" style="margin-top:10px"></div>
    </div>

    <!-- ═══════════ SECTION 6: Explanation Panel ═══════════ -->
    <div class="explain">
        <div class="explain-name">What have we learnt?</div>
        <div class="explain-text">
            Inverse trigonometric functions answer the question: "what angle gives this ratio?" But because trig functions are periodic, they produce infinitely many angles for a single ratio value. To define proper inverse functions, we must restrict the original functions to intervals where they are one-to-one.
            <br><br>
            <strong style="color:#c0c0d8">Key restrictions:</strong> sin is restricted to [-&pi;/2, &pi;/2], cos to [0, &pi;], and tan to (-&pi;/2, &pi;/2). On these intervals, each function is monotonic and covers its full range, yielding a unique inverse.
            <br><br>
            <strong style="color:#c0c0d8">The surprise:</strong> The derivatives of inverse trig functions are purely algebraic &mdash; no trigonometry in sight. The derivative of arctan(x) is 1/(1+x&sup2;), and the derivative of arcsin(x) is 1/&radic;(1-x&sup2;). This creates a deep bridge between trigonometry and algebra, and it is exactly why these functions appear everywhere in integral calculus.
            <br><br>
            <strong style="color:#c0c0d8">Where they appear:</strong> In calculus (integration of rational functions), in physics (resolving vector components into angles), in engineering (signal processing, control theory), and in computer graphics (computing angles from coordinates). The integral &int;1/(1+x&sup2;)dx = arctan(x) + C is one of the most important formulas in applied mathematics.
        </div>
    </div>
</div>

<script>
/* ════════════════════════════════════════════════════════════
   SHARED UTILITIES
   ════════════════════════════════════════════════════════════ */
const PI = Math.PI;
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}
function toDeg(r){return r*180/PI;}
function toRad(d){return d*PI/180;}
function fmtAngle(rad){
    const d=toDeg(rad);
    return rad.toFixed(4)+' rad ('+d.toFixed(1)+'\u00B0)';
}
function fmtFrac(rad){
    // Try to express as a nice fraction of pi
    const r=rad/PI;
    const fracs=[[0,'0'],[1/6,'\u03C0/6'],[1/4,'\u03C0/4'],[1/3,'\u03C0/3'],[1/2,'\u03C0/2'],[2/3,'2\u03C0/3'],[3/4,'3\u03C0/4'],[5/6,'5\u03C0/6'],[1,'\u03C0'],[-1/6,'-\u03C0/6'],[-1/4,'-\u03C0/4'],[-1/3,'-\u03C0/3'],[-1/2,'-\u03C0/2'],[-2/3,'-2\u03C0/3'],[-3/4,'-3\u03C0/4'],[-5/6,'-5\u03C0/6'],[-1,'-\u03C0']];
    for(const [v,s] of fracs){if(Math.abs(r-v)<0.001) return s;}
    return rad.toFixed(4);
}

/* ════════════════════════════════════════════════════════════
   SECTION 1: RESTRICTED DOMAINS
   ════════════════════════════════════════════════════════════ */
(function(){
    const cvs=document.getElementById('domainCanvas'), ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;
    let funcType='sin';
    let yVal=0.5;
    const funcs={
        sin:{fn:Math.sin, restrict:[-PI/2,PI/2], range:[-1,1], label:'sin(x)', invLabel:'arcsin'},
        cos:{fn:Math.cos, restrict:[0,PI], range:[-1,1], label:'cos(x)', invLabel:'arccos'},
        tan:{fn:Math.tan, restrict:[-PI/2+0.01,PI/2-0.01], range:[-10,10], label:'tan(x)', invLabel:'arctan'}
    };
    const btns=[{id:'sin',label:'sin'},{id:'cos',label:'cos'},{id:'tan',label:'tan'}];
    const btnContainer=document.getElementById('s1Btns');
    function renderBtns(){
        btnContainer.innerHTML=btns.map(b=>'<button class="btn'+(b.id===funcType?' active':'')+'" data-f="'+b.id+'">'+b.label+'</button>').join('');
        btnContainer.querySelectorAll('.btn').forEach(b=>b.addEventListener('click',()=>{
            funcType=b.dataset.f;
            const sl=document.getElementById('s1YSlider');
            if(funcType==='tan'){sl.min=-500;sl.max=500;sl.value=Math.round(yVal*100);}
            else{sl.min=-100;sl.max=100;sl.value=Math.round(clamp(yVal,-1,1)*100);}
            renderBtns();draw();
        }));
    }
    const slider=document.getElementById('s1YSlider');
    const label=document.getElementById('s1YLabel');
    slider.addEventListener('input',()=>{
        yVal=funcType==='tan'?parseInt(slider.value)/100:parseInt(slider.value)/100;
        label.textContent=yVal.toFixed(2);
        draw();
    });
    // Touch support
    slider.addEventListener('touchstart',e=>{e.stopPropagation();},{passive:true});

    function draw(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);
        const f=funcs[funcType];
        const xMin=-2*PI, xMax=2*PI;
        const yMin=funcType==='tan'?-5:f.range[0]-0.3;
        const yMax=funcType==='tan'?5:f.range[1]+0.3;
        const px=W/(xMax-xMin), py=H/(yMax-yMin);
        function toSx(x){return (x-xMin)*px;}
        function toSy(y){return H-(y-yMin)*py;}

        // Grid
        ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;
        for(let x=Math.ceil(xMin);x<=Math.floor(xMax);x++){
            const sx=toSx(x);
            ctx.beginPath();ctx.moveTo(sx,0);ctx.lineTo(sx,H);ctx.stroke();
        }
        for(let y=Math.ceil(yMin);y<=Math.floor(yMax);y++){
            const sy=toSy(y);
            ctx.beginPath();ctx.moveTo(0,sy);ctx.lineTo(W,sy);ctx.stroke();
        }
        // Axes
        ctx.strokeStyle='rgba(255,255,255,0.18)';ctx.lineWidth=1.5;
        const ox=toSx(0), oy=toSy(0);
        ctx.beginPath();ctx.moveTo(0,oy);ctx.lineTo(W,oy);ctx.stroke();
        ctx.beginPath();ctx.moveTo(ox,0);ctx.lineTo(ox,H);ctx.stroke();
        // Tick labels
        ctx.font='10px Georgia';ctx.fillStyle='#505068';ctx.textAlign='center';ctx.textBaseline='top';
        const piTicks=[[-2*PI,'-2\u03C0'],[-3*PI/2,'-3\u03C0/2'],[-PI,'-\u03C0'],[-PI/2,'-\u03C0/2'],[PI/2,'\u03C0/2'],[PI,'\u03C0'],[3*PI/2,'3\u03C0/2'],[2*PI,'2\u03C0']];
        for(const [v,l] of piTicks){
            const sx=toSx(v);
            ctx.fillText(l,sx,oy+4);
        }
        ctx.textAlign='right';ctx.textBaseline='middle';
        for(let y=Math.ceil(yMin);y<=Math.floor(yMax);y++){
            if(y===0) continue;
            ctx.fillText(y,ox-6,toSy(y));
        }

        // Full function (dim)
        ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.lineWidth=1.5;
        ctx.beginPath();
        let started=false;
        for(let i=0;i<=W;i++){
            const x=xMin+i/px;
            let y=f.fn(x);
            if(funcType==='tan'&&Math.abs(y)>10){started=false;continue;}
            const sy=toSy(y);
            if(!started){ctx.moveTo(i,sy);started=true;}
            else ctx.lineTo(i,sy);
        }
        ctx.stroke();

        // Restricted domain (emerald, thick)
        ctx.strokeStyle='#34d399';ctx.lineWidth=3;
        ctx.beginPath();
        started=false;
        const [rlo,rhi]=f.restrict;
        for(let i=0;i<=W;i++){
            const x=xMin+i/px;
            if(x<rlo||x>rhi) continue;
            let y=f.fn(x);
            if(funcType==='tan'&&Math.abs(y)>10){started=false;continue;}
            const sy=toSy(y);
            if(!started){ctx.moveTo(i,sy);started=true;}
            else ctx.lineTo(i,sy);
        }
        ctx.stroke();

        // Restricted domain shading
        ctx.fillStyle='rgba(52,211,153,0.06)';
        ctx.fillRect(toSx(rlo),0,toSx(rhi)-toSx(rlo),H);
        // Boundary lines
        ctx.setLineDash([4,4]);ctx.strokeStyle='rgba(52,211,153,0.3)';ctx.lineWidth=1;
        ctx.beginPath();ctx.moveTo(toSx(rlo),0);ctx.lineTo(toSx(rlo),H);ctx.stroke();
        ctx.beginPath();ctx.moveTo(toSx(rhi),0);ctx.lineTo(toSx(rhi),H);ctx.stroke();
        ctx.setLineDash([]);

        // Horizontal line y = yVal
        const ySafe=funcType==='tan'?yVal:clamp(yVal,-1,1);
        const sy_line=toSy(ySafe);
        if(sy_line>=0&&sy_line<=H){
            ctx.strokeStyle='#fbbf24';ctx.lineWidth=1.5;ctx.setLineDash([6,4]);
            ctx.beginPath();ctx.moveTo(0,sy_line);ctx.lineTo(W,sy_line);ctx.stroke();
            ctx.setLineDash([]);
            ctx.font='12px Georgia';ctx.fillStyle='#fbbf24';ctx.textAlign='left';ctx.textBaseline='bottom';
            ctx.fillText('y = '+ySafe.toFixed(2),8,sy_line-4);
        }

        // Mark intersections
        const intersections=[];
        for(let i=1;i<=W;i++){
            const x0=xMin+(i-1)/px, x1=xMin+i/px;
            const y0=f.fn(x0)-ySafe, y1=f.fn(x1)-ySafe;
            if(funcType==='tan'&&(Math.abs(f.fn(x0))>10||Math.abs(f.fn(x1))>10)) continue;
            if(y0*y1<=0&&Math.abs(y0-y1)<5){
                const t=-y0/(y1-y0);
                const xi=x0+t*(x1-x0);
                intersections.push(xi);
            }
        }
        for(const xi of intersections){
            const inRestricted=(xi>=rlo-0.01&&xi<=rhi+0.01);
            const sx=toSx(xi), syi=toSy(ySafe);
            ctx.fillStyle=inRestricted?'#34d399':'rgba(251,191,36,0.5)';
            ctx.beginPath();ctx.arc(sx,syi,inRestricted?6:4,0,PI*2);ctx.fill();
        }

        // Label
        ctx.font='13px Georgia';ctx.fillStyle='#34d399';ctx.textAlign='left';ctx.textBaseline='top';
        const restrictLabel=funcType==='sin'?'[-\u03C0/2, \u03C0/2]':funcType==='cos'?'[0, \u03C0]':'(-\u03C0/2, \u03C0/2)';
        ctx.fillText('Restricted domain: '+restrictLabel,toSx(rlo)+4,12);
        ctx.font='12px Georgia';ctx.fillStyle='#808098';ctx.textAlign='right';
        ctx.fillText(f.label,W-10,12);

        // Info
        const info=document.getElementById('s1Info');
        const restricted=intersections.filter(x=>x>=rlo-0.01&&x<=rhi+0.01);
        info.innerHTML='<span class="emerald">Intersections in restricted domain: '+restricted.length+'</span> &ensp; <span class="muted">Total intersections visible: '+intersections.length+'</span>';
    }

    renderBtns();draw();
})();

/* ════════════════════════════════════════════════════════════
   SECTION 2: THE REFLECTION
   ════════════════════════════════════════════════════════════ */
(function(){
    const cvs=document.getElementById('reflectCanvas'), ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;
    let funcType='arcsin';
    let inputVal=0.5;
    let animProgress=-1; // -1 = not animating, 0..1 = progress
    let animId=null;

    const configs={
        arcsin:{
            origFn:Math.sin, invFn:Math.asin,
            origDom:[-PI/2,PI/2], origRange:[-1,1],
            invDom:[-1,1], invRange:[-PI/2,PI/2],
            label:'sin(x)', invLabel:'arcsin(x)',
            keyVals:[[0,0],[0.5,PI/6],[Math.sqrt(2)/2,PI/4],[Math.sqrt(3)/2,PI/3],[1,PI/2],[-1,-PI/2]],
            keyLabels:['arcsin(0)=0','arcsin(1/2)=\u03C0/6','arcsin(\u221A2/2)=\u03C0/4','arcsin(\u221A3/2)=\u03C0/3','arcsin(1)=\u03C0/2','arcsin(-1)=-\u03C0/2']
        },
        arccos:{
            origFn:Math.cos, invFn:Math.acos,
            origDom:[0,PI], origRange:[-1,1],
            invDom:[-1,1], invRange:[0,PI],
            label:'cos(x)', invLabel:'arccos(x)',
            keyVals:[[1,0],[Math.sqrt(3)/2,PI/6],[Math.sqrt(2)/2,PI/4],[0.5,PI/3],[0,PI/2],[-1,PI]],
            keyLabels:['arccos(1)=0','arccos(\u221A3/2)=\u03C0/6','arccos(\u221A2/2)=\u03C0/4','arccos(1/2)=\u03C0/3','arccos(0)=\u03C0/2','arccos(-1)=\u03C0']
        },
        arctan:{
            origFn:Math.tan, invFn:Math.atan,
            origDom:[-PI/2+0.05,PI/2-0.05], origRange:[-6,6],
            invDom:[-6,6], invRange:[-PI/2,PI/2],
            label:'tan(x)', invLabel:'arctan(x)',
            keyVals:[[0,0],[1,PI/4],[-1,-PI/4],[Math.sqrt(3),PI/3]],
            keyLabels:['arctan(0)=0','arctan(1)=\u03C0/4','arctan(-1)=-\u03C0/4','arctan(\u221A3)=\u03C0/3']
        }
    };
    const btns=[{id:'arcsin',label:'arcsin'},{id:'arccos',label:'arccos'},{id:'arctan',label:'arctan'}];
    const btnContainer=document.getElementById('s2Btns');

    function renderBtns(){
        btnContainer.innerHTML=btns.map(b=>'<button class="btn'+(b.id===funcType?' active':'')+'" data-f="'+b.id+'">'+b.label+'</button>').join('');
        btnContainer.querySelectorAll('.btn').forEach(b=>b.addEventListener('click',()=>{
            funcType=b.dataset.f;
            const sl=document.getElementById('s2Slider');
            if(funcType==='arctan'){sl.min=-600;sl.max=600;sl.value=Math.round(inputVal*100);}
            else{sl.min=-100;sl.max=100;sl.value=Math.round(clamp(inputVal,-1,1)*100);}
            renderBtns();updateKeyValues();draw();
        }));
    }

    const slider=document.getElementById('s2Slider');
    const label=document.getElementById('s2Label');
    slider.addEventListener('input',()=>{
        inputVal=parseInt(slider.value)/100;
        label.textContent=inputVal.toFixed(2);
        draw();
    });

    document.getElementById('s2AnimBtn').addEventListener('click',()=>{
        if(animProgress>=0) return;
        animProgress=0;
        const start=performance.now();
        const duration=1200;
        function step(now){
            animProgress=Math.min(1,(now-start)/duration);
            draw();
            if(animProgress<1) animId=requestAnimationFrame(step);
            else{animProgress=-1;}
        }
        animId=requestAnimationFrame(step);
    });

    function updateKeyValues(){
        const c=configs[funcType];
        const el=document.getElementById('s2KeyValues');
        el.innerHTML='<span class="muted">Key values: </span>'+c.keyLabels.map(l=>'<span style="color:#34d399">'+l+'</span>').join(' &ensp; ');
    }

    function draw(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);
        const c=configs[funcType];
        // Determine plot bounds to show both original and inverse
        let xMin,xMax,yMin,yMax;
        if(funcType==='arctan'){
            xMin=-6;xMax=6;yMin=-6;yMax=6;
        } else {
            xMin=-PI/2-0.5;xMax=PI+0.5;yMin=-PI/2-0.5;yMax=PI+0.5;
        }
        const px=W/(xMax-xMin), py=H/(yMax-yMin);
        function toSx(x){return (x-xMin)*px;}
        function toSy(y){return H-(y-yMin)*py;}

        // Grid
        ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;
        for(let x=Math.ceil(xMin);x<=Math.floor(xMax);x++){
            ctx.beginPath();ctx.moveTo(toSx(x),0);ctx.lineTo(toSx(x),H);ctx.stroke();
        }
        for(let y=Math.ceil(yMin);y<=Math.floor(yMax);y++){
            ctx.beginPath();ctx.moveTo(0,toSy(y));ctx.lineTo(W,toSy(y));ctx.stroke();
        }
        // Axes
        ctx.strokeStyle='rgba(255,255,255,0.18)';ctx.lineWidth=1.5;
        ctx.beginPath();ctx.moveTo(0,toSy(0));ctx.lineTo(W,toSy(0));ctx.stroke();
        ctx.beginPath();ctx.moveTo(toSx(0),0);ctx.lineTo(toSx(0),H);ctx.stroke();

        // y = x dashed line
        ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.lineWidth=1;ctx.setLineDash([5,5]);
        ctx.beginPath();ctx.moveTo(toSx(xMin),toSy(xMin));ctx.lineTo(toSx(xMax),toSy(xMax));ctx.stroke();
        ctx.setLineDash([]);
        ctx.font='11px Georgia';ctx.fillStyle='rgba(255,255,255,0.3)';ctx.textAlign='left';ctx.textBaseline='bottom';
        ctx.fillText('y = x',toSx(Math.min(xMax-0.3,yMax-0.3))+4,toSy(Math.min(xMax-0.3,yMax-0.3))-4);

        // Original (restricted) function in emerald
        ctx.strokeStyle='#34d399';ctx.lineWidth=2.5;
        ctx.beginPath();
        let started=false;
        const step=0.005;
        for(let x=c.origDom[0];x<=c.origDom[1];x+=step){
            let y=c.origFn(x);
            if(funcType==='tan'&&Math.abs(y)>10){started=false;continue;}
            const sx=toSx(x),sy=toSy(y);
            if(sx<-10||sx>W+10||sy<-10||sy>H+10){started=false;continue;}
            if(!started){ctx.moveTo(sx,sy);started=true;}
            else ctx.lineTo(sx,sy);
        }
        ctx.stroke();

        // Inverse function in gold
        ctx.strokeStyle='#fbbf24';ctx.lineWidth=2.5;
        ctx.beginPath();
        started=false;
        const invLo=c.invDom[0], invHi=c.invDom[1];
        const invStep=(invHi-invLo)/400;
        for(let x=invLo;x<=invHi;x+=invStep){
            let y;
            try{y=c.invFn(x);}catch(e){continue;}
            if(isNaN(y)) continue;
            const sx=toSx(x),sy=toSy(y);
            if(sx<-10||sx>W+10||sy<-10||sy>H+10){started=false;continue;}
            if(!started){ctx.moveTo(sx,sy);started=true;}
            else ctx.lineTo(sx,sy);
        }
        ctx.stroke();

        // Animation: reflect points
        if(animProgress>=0){
            const nPts=30;
            for(let i=0;i<=nPts;i++){
                const t=i/nPts;
                const x=c.origDom[0]+t*(c.origDom[1]-c.origDom[0]);
                let y=c.origFn(x);
                if(funcType==='tan'&&Math.abs(y)>6) continue;
                // Interpolate from (x,y) to (y,x)
                const cx_=x+(y-x)*animProgress;
                const cy_=y+(x-y)*animProgress;
                const sx=toSx(cx_),sy=toSy(cy_);
                if(sx<0||sx>W||sy<0||sy>H) continue;
                ctx.fillStyle='rgba(52,211,153,'+(0.3+0.5*animProgress)+')';
                ctx.beginPath();ctx.arc(sx,sy,3,0,PI*2);ctx.fill();
            }
        }

        // Interactive: current input value
        const iv=funcType==='arctan'?inputVal:clamp(inputVal,-1,1);
        let angle;
        try{angle=configs[funcType].invFn(iv);}catch(e){angle=NaN;}
        if(!isNaN(angle)){
            // Point on inverse function
            const psx=toSx(iv), psy=toSy(angle);
            ctx.fillStyle='#fbbf24';ctx.beginPath();ctx.arc(psx,psy,6,0,PI*2);ctx.fill();
            // Corresponding point on original
            const osx=toSx(angle), osy=toSy(iv);
            ctx.fillStyle='#34d399';ctx.beginPath();ctx.arc(osx,osy,6,0,PI*2);ctx.fill();
            // Dashed lines connecting them through y=x
            ctx.setLineDash([3,3]);ctx.strokeStyle='rgba(255,255,255,0.2)';ctx.lineWidth=1;
            ctx.beginPath();ctx.moveTo(psx,psy);ctx.lineTo(osx,osy);ctx.stroke();
            ctx.setLineDash([]);
        }

        // Labels
        ctx.font='13px Georgia';ctx.fillStyle='#34d399';ctx.textAlign='left';ctx.textBaseline='top';
        ctx.fillText(c.label+' (restricted)',10,10);
        ctx.fillStyle='#fbbf24';
        ctx.fillText(c.invLabel,10,28);

        // Info
        const info=document.getElementById('s2Info');
        if(!isNaN(angle)){
            info.innerHTML='<span class="emerald">'+configs[funcType].invLabel+'('+iv.toFixed(2)+') = '+fmtFrac(angle)+' = '+toDeg(angle).toFixed(1)+'\u00B0</span>';
        } else {
            info.innerHTML='<span class="muted">Value outside domain</span>';
        }
    }

    renderBtns();updateKeyValues();draw();
})();

/* ════════════════════════════════════════════════════════════
   SECTION 3: INTERACTIVE CALCULATOR WITH UNIT CIRCLE
   ════════════════════════════════════════════════════════════ */
(function(){
    const cvs=document.getElementById('unitCircleCanvas'), ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;
    const CX=W/2, CY=H/2, R=150;
    let funcType='arcsin';
    let inputVal=0.5;
    const allFuncs=['arcsin','arccos','arctan','arccsc','arcsec','arccot'];
    const btnContainer=document.getElementById('s3Btns');

    function renderBtns(){
        btnContainer.innerHTML=allFuncs.map(f=>'<button class="btn'+(f===funcType?' active':'')+'" data-f="'+f+'">'+f+'</button>').join('');
        btnContainer.querySelectorAll('.btn').forEach(b=>b.addEventListener('click',()=>{
            funcType=b.dataset.f;
            updateSlider();
            renderBtns();draw();
        }));
    }

    function updateSlider(){
        const sl=document.getElementById('s3Slider');
        const il=document.getElementById('s3InputLabel');
        if(funcType==='arcsin'){sl.min=-100;sl.max=100;sl.step=1;il.textContent='y =';}
        else if(funcType==='arccos'){sl.min=-100;sl.max=100;sl.step=1;il.textContent='x =';}
        else if(funcType==='arctan'){sl.min=-1000;sl.max=1000;sl.step=1;il.textContent='ratio =';}
        else if(funcType==='arccsc'){sl.min=-500;sl.max=500;sl.step=1;il.textContent='csc =';}
        else if(funcType==='arcsec'){sl.min=-500;sl.max=500;sl.step=1;il.textContent='sec =';}
        else if(funcType==='arccot'){sl.min=-1000;sl.max=1000;sl.step=1;il.textContent='cot =';}
        sl.value=Math.round(inputVal*100);
    }

    const slider=document.getElementById('s3Slider');
    const valLabel=document.getElementById('s3ValLabel');
    slider.addEventListener('input',()=>{
        inputVal=parseInt(slider.value)/100;
        valLabel.textContent=inputVal.toFixed(2);
        draw();
    });

    function computeAngle(val){
        switch(funcType){
            case 'arcsin': return (val>=-1&&val<=1)?Math.asin(val):NaN;
            case 'arccos': return (val>=-1&&val<=1)?Math.acos(val):NaN;
            case 'arctan': return Math.atan(val);
            case 'arccsc': return (Math.abs(val)>=1)?Math.asin(1/val):NaN;
            case 'arcsec': return (Math.abs(val)>=1)?Math.acos(1/val):NaN;
            case 'arccot': return val===0?PI/2:Math.atan(1/val)+(val<0?PI:0);
        }
        return NaN;
    }

    function draw(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);
        // Axes
        ctx.strokeStyle='rgba(255,255,255,0.12)';ctx.lineWidth=1;
        ctx.beginPath();ctx.moveTo(0,CY);ctx.lineTo(W,CY);ctx.stroke();
        ctx.beginPath();ctx.moveTo(CX,0);ctx.lineTo(CX,H);ctx.stroke();
        ctx.font='11px Georgia';ctx.fillStyle='#808098';ctx.textAlign='left';ctx.textBaseline='bottom';
        ctx.fillText('x',W-16,CY-6);
        ctx.textAlign='left';ctx.textBaseline='top';
        ctx.fillText('y',CX+6,6);
        // Unit circle
        ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.lineWidth=1.5;
        ctx.beginPath();ctx.arc(CX,CY,R,0,PI*2);ctx.stroke();
        // Tick marks
        ctx.fillStyle='#505068';ctx.font='10px Georgia';ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText('1',CX+R,CY+6);ctx.fillText('-1',CX-R,CY+6);
        ctx.textAlign='right';ctx.textBaseline='middle';
        ctx.fillText('1',CX-6,CY-R);ctx.fillText('-1',CX-6,CY+R);

        const angle=computeAngle(inputVal);
        if(isNaN(angle)){
            // Out of domain
            ctx.font='14px Georgia';ctx.fillStyle='#fbbf24';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText('Value outside domain',CX,CY);
            document.getElementById('s3Result').innerHTML='<span style="color:#fbbf24">Input '+inputVal.toFixed(2)+' is outside the domain of '+funcType+'</span>';
            return;
        }

        const cosA=Math.cos(angle), sinA=Math.sin(angle);
        const px=CX+cosA*R, py=CY-sinA*R;

        // Construction lines depending on function
        if(funcType==='arcsin'||funcType==='arccsc'){
            // Horizontal line at y = sin(angle)
            const lineY=CY-sinA*R;
            ctx.strokeStyle='rgba(251,191,36,0.4)';ctx.lineWidth=1;ctx.setLineDash([4,4]);
            ctx.beginPath();ctx.moveTo(0,lineY);ctx.lineTo(W,lineY);ctx.stroke();
            ctx.setLineDash([]);
            ctx.font='10px Georgia';ctx.fillStyle='#fbbf24';ctx.textAlign='left';ctx.textBaseline='bottom';
            ctx.fillText('y = '+sinA.toFixed(3),4,lineY-3);
        } else if(funcType==='arccos'||funcType==='arcsec'){
            // Vertical line at x = cos(angle)
            const lineX=CX+cosA*R;
            ctx.strokeStyle='rgba(251,191,36,0.4)';ctx.lineWidth=1;ctx.setLineDash([4,4]);
            ctx.beginPath();ctx.moveTo(lineX,0);ctx.lineTo(lineX,H);ctx.stroke();
            ctx.setLineDash([]);
            ctx.font='10px Georgia';ctx.fillStyle='#fbbf24';ctx.textAlign='left';ctx.textBaseline='top';
            ctx.fillText('x = '+cosA.toFixed(3),lineX+4,4);
        } else if(funcType==='arctan'||funcType==='arccot'){
            // Tangent line construction: line from origin at angle, meeting x=1 vertical
            const tanX=CX+R, tanY=CY-inputVal*R;
            // Vertical line at x=1
            ctx.strokeStyle='rgba(255,255,255,0.08)';ctx.lineWidth=1;
            ctx.beginPath();ctx.moveTo(tanX,0);ctx.lineTo(tanX,H);ctx.stroke();
            // Line from origin to tangent point
            ctx.strokeStyle='rgba(251,191,36,0.3)';ctx.lineWidth=1.5;
            ctx.beginPath();ctx.moveTo(CX,CY);
            const ext=Math.sqrt(1+inputVal*inputVal);
            ctx.lineTo(CX+R/ext*1,CY-R/ext*inputVal);
            ctx.stroke();
            // Tangent segment on x=1 line
            ctx.strokeStyle='#fbbf24';ctx.lineWidth=2;
            ctx.beginPath();ctx.moveTo(tanX,CY);ctx.lineTo(tanX,CY-Math.min(Math.max(inputVal*R,-R*1.5),R*1.5));ctx.stroke();
            ctx.font='10px Georgia';ctx.fillStyle='#fbbf24';ctx.textAlign='left';ctx.textBaseline='middle';
            const labelY=CY-clamp(inputVal*R/2,-R,R);
            ctx.fillText('tan = '+inputVal.toFixed(2),tanX+6,labelY);
        }

        // Angle arc
        const arcStart=0, arcEnd=angle;
        const arcR=35;
        if(Math.abs(angle)>0.01){
            ctx.strokeStyle='rgba(52,211,153,0.6)';ctx.lineWidth=2;
            ctx.beginPath();
            if(angle>=0) ctx.arc(CX,CY,arcR,-angle,0);
            else ctx.arc(CX,CY,arcR,0,-angle);
            ctx.stroke();
            // Fill arc
            ctx.fillStyle='rgba(52,211,153,0.08)';
            ctx.beginPath();
            ctx.moveTo(CX,CY);
            if(angle>=0) ctx.arc(CX,CY,arcR,-angle,0);
            else ctx.arc(CX,CY,arcR,0,-angle);
            ctx.closePath();ctx.fill();
            // Angle label
            const midA=angle/2;
            ctx.font='12px Georgia';ctx.fillStyle='#34d399';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText(toDeg(angle).toFixed(1)+'\u00B0',CX+Math.cos(midA)*(arcR+16),CY-Math.sin(midA)*(arcR+16));
        }

        // Radius line
        ctx.strokeStyle='#34d399';ctx.lineWidth=2;
        ctx.beginPath();ctx.moveTo(CX,CY);ctx.lineTo(px,py);ctx.stroke();

        // Point on circle
        ctx.fillStyle='#34d399';ctx.beginPath();ctx.arc(px,py,6,0,PI*2);ctx.fill();
        // Coordinate label
        ctx.font='11px Courier New';ctx.fillStyle='#c0c0d8';ctx.textAlign='left';ctx.textBaseline='bottom';
        ctx.fillText('('+cosA.toFixed(3)+', '+sinA.toFixed(3)+')',px+10,py-8);

        // Projections
        ctx.setLineDash([2,3]);ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.lineWidth=1;
        ctx.beginPath();ctx.moveTo(px,py);ctx.lineTo(px,CY);ctx.stroke();
        ctx.beginPath();ctx.moveTo(px,py);ctx.lineTo(CX,py);ctx.stroke();
        ctx.setLineDash([]);

        // Result display
        const res=document.getElementById('s3Result');
        let html='<div><span class="emerald">'+funcType+'('+inputVal.toFixed(2)+')</span></div>';
        html+='<div>= <span style="color:#fff">'+fmtFrac(angle)+'</span></div>';
        html+='<div>= <span style="color:#fff">'+toDeg(angle).toFixed(2)+'\u00B0</span></div>';
        html+='<div style="margin-top:8px;color:#808098">Point on circle: ('+cosA.toFixed(4)+', '+sinA.toFixed(4)+')</div>';
        if(funcType==='arcsin') html+='<div style="color:#808098">sin(\u03B8) = '+sinA.toFixed(4)+' = y-coordinate</div>';
        else if(funcType==='arccos') html+='<div style="color:#808098">cos(\u03B8) = '+cosA.toFixed(4)+' = x-coordinate</div>';
        else if(funcType==='arctan') html+='<div style="color:#808098">tan(\u03B8) = '+(sinA/cosA).toFixed(4)+' = y/x ratio</div>';
        else if(funcType==='arccsc') html+='<div style="color:#808098">csc(\u03B8) = '+(1/sinA).toFixed(4)+' = 1/sin(\u03B8)</div>';
        else if(funcType==='arcsec') html+='<div style="color:#808098">sec(\u03B8) = '+(1/cosA).toFixed(4)+' = 1/cos(\u03B8)</div>';
        else if(funcType==='arccot') html+='<div style="color:#808098">cot(\u03B8) = '+(cosA/sinA).toFixed(4)+' = cos/sin</div>';
        res.innerHTML=html;
    }

    renderBtns();updateSlider();draw();
})();

/* ════════════════════════════════════════════════════════════
   SECTION 4: KEY IDENTITIES
   ════════════════════════════════════════════════════════════ */
(function(){
    let identitySet='composition';
    let xVal=0.5;
    const btnContainer=document.getElementById('s4Btns');
    const sets=[
        {id:'composition',label:'Composition'},
        {id:'complement',label:'Complement'},
        {id:'reciprocal',label:'Reciprocal'},
        {id:'mistake',label:'Common Mistake'}
    ];

    function renderBtns(){
        btnContainer.innerHTML=sets.map(s=>'<button class="btn'+(s.id===identitySet?' active':'')+'" data-s="'+s.id+'">'+s.label+'</button>').join('');
        btnContainer.querySelectorAll('.btn').forEach(b=>b.addEventListener('click',()=>{
            identitySet=b.dataset.s;
            const sl=document.getElementById('s4Slider');
            if(identitySet==='reciprocal'){sl.min=10;sl.max=1000;sl.value=Math.max(10,Math.round(xVal*100));}
            else if(identitySet==='mistake'){sl.min=-400;sl.max=400;sl.value=Math.round(xVal*100);}
            else{sl.min=-100;sl.max=100;sl.value=Math.round(clamp(xVal,-1,1)*100);}
            renderBtns();update();
        }));
    }

    const slider=document.getElementById('s4Slider');
    const xlabel=document.getElementById('s4XLabel');
    slider.addEventListener('input',()=>{
        xVal=parseInt(slider.value)/100;
        xlabel.textContent=xVal.toFixed(2);
        update();
    });

    function update(){
        const el=document.getElementById('s4Identities');
        const warn=document.getElementById('s4Warning');
        warn.innerHTML='';
        let html='';

        if(identitySet==='composition'){
            const x=clamp(xVal,-1,1);
            const sinAsinX=Math.sin(Math.asin(x));
            const asinSinX_raw=Math.asin(Math.sin(x));
            html+='<div class="identity-row">';
            html+='<div class="identity-eq">sin(arcsin('+x.toFixed(3)+'))</div>';
            html+='<div class="identity-val">= '+sinAsinX.toFixed(6)+'</div>';
            html+='<div class="identity-check" style="color:'+(Math.abs(sinAsinX-x)<0.0001?'#34d399':'#fbbf24')+'">'+
                (Math.abs(sinAsinX-x)<0.0001?'Equals x':'Not equal to x')+'</div>';
            html+='</div>';

            html+='<div class="identity-row">';
            html+='<div class="identity-eq">arcsin(sin('+x.toFixed(3)+'))</div>';
            html+='<div class="identity-val">= '+asinSinX_raw.toFixed(6)+'</div>';
            html+='<div class="identity-check" style="color:'+(Math.abs(asinSinX_raw-x)<0.0001?'#34d399':'#fbbf24')+'">'+
                (Math.abs(asinSinX_raw-x)<0.0001?'Equals x (in [-\u03C0/2, \u03C0/2])':'Not x! ('+x.toFixed(3)+' outside [-\u03C0/2, \u03C0/2])')+'</div>';
            html+='</div>';

            html+='<div class="identity-row">';
            html+='<div class="identity-eq">cos(arccos('+x.toFixed(3)+'))</div>';
            const cosAcosX=Math.cos(Math.acos(x));
            html+='<div class="identity-val">= '+cosAcosX.toFixed(6)+'</div>';
            html+='<div class="identity-check" style="color:#34d399">Equals x (always for x in [-1,1])</div>';
            html+='</div>';

            html+='<div class="identity-row">';
            html+='<div class="identity-eq">arccos(cos('+x.toFixed(3)+'))</div>';
            const acosCosX=Math.acos(Math.cos(x));
            html+='<div class="identity-check" style="color:'+(Math.abs(acosCosX-x)<0.0001?'#34d399':'#fbbf24')+'">= '+acosCosX.toFixed(6)+
                (Math.abs(acosCosX-x)<0.0001?' = x (in [0, \u03C0])':' (not x; x outside [0, \u03C0])')+'</div>';
            html+='</div>';
        }

        else if(identitySet==='complement'){
            const x=clamp(xVal,-1,1);
            const asin=Math.asin(x), acos=Math.acos(x);
            const sum=asin+acos;
            html+='<div class="identity-row">';
            html+='<div class="identity-eq">arcsin('+x.toFixed(3)+') + arccos('+x.toFixed(3)+')</div>';
            html+='<div class="identity-val">= '+asin.toFixed(4)+' + '+acos.toFixed(4)+'</div>';
            html+='</div>';
            html+='<div class="identity-row">';
            html+='<div class="identity-eq">= '+sum.toFixed(6)+'</div>';
            html+='<div class="identity-val">\u03C0/2 = '+(PI/2).toFixed(6)+'</div>';
            html+='<div class="identity-check" style="color:'+(Math.abs(sum-PI/2)<0.0001?'#34d399':'#fbbf24')+'">'+(Math.abs(sum-PI/2)<0.0001?'Verified!':'Error')+'</div>';
            html+='</div>';
            html+='<div style="color:#808098;font-size:0.85em;margin-top:8px">This identity arcsin(x) + arccos(x) = \u03C0/2 holds for all x in [-1, 1]. It follows from the co-function identity: sin(\u03B8) = cos(\u03C0/2 - \u03B8).</div>';
        }

        else if(identitySet==='reciprocal'){
            const x=Math.max(0.1,xVal);
            const atan1=Math.atan(x), atan2=Math.atan(1/x);
            const sum=atan1+atan2;
            html+='<div class="identity-row">';
            html+='<div class="identity-eq">arctan('+x.toFixed(3)+') + arctan(1/'+x.toFixed(3)+')</div>';
            html+='<div class="identity-val">= '+atan1.toFixed(4)+' + '+atan2.toFixed(4)+'</div>';
            html+='</div>';
            html+='<div class="identity-row">';
            html+='<div class="identity-eq">= '+sum.toFixed(6)+'</div>';
            html+='<div class="identity-val">\u03C0/2 = '+(PI/2).toFixed(6)+'</div>';
            html+='<div class="identity-check" style="color:'+(Math.abs(sum-PI/2)<0.001?'#34d399':'#fbbf24')+'">'+(Math.abs(sum-PI/2)<0.001?'Verified!':'Error')+'</div>';
            html+='</div>';
            html+='<div style="color:#808098;font-size:0.85em;margin-top:8px">arctan(x) + arctan(1/x) = \u03C0/2 for x > 0. This is because if \u03B8 = arctan(x), then the complementary angle \u03C0/2 - \u03B8 has tangent 1/x.</div>';
        }

        else if(identitySet==='mistake'){
            const x=xVal;
            const sinX=Math.sin(x);
            const asinSinX=Math.asin(sinX);
            const isClose=Math.abs(asinSinX-x)<0.001;
            html+='<div class="identity-row">';
            html+='<div class="identity-eq">sin('+x.toFixed(3)+') = '+sinX.toFixed(6)+'</div>';
            html+='</div>';
            html+='<div class="identity-row">';
            html+='<div class="identity-eq">arcsin(sin('+x.toFixed(3)+')) = '+asinSinX.toFixed(6)+'</div>';
            html+='<div class="identity-check" style="color:'+(isClose?'#34d399':'#fbbf24')+'">'+(isClose?'= x (within restricted range)':'Not '+x.toFixed(3)+'!')+'</div>';
            html+='</div>';

            if(!isClose){
                warn.innerHTML='<div class="warning"><strong>Common mistake!</strong> arcsin(sin('+x.toFixed(2)+')) = '+asinSinX.toFixed(4)+', not '+x.toFixed(2)+'. The arcsin function always returns a value in [-\u03C0/2, \u03C0/2]. Since '+x.toFixed(2)+' is outside this range, arcsin "folds" the result back into its range.</div>';
            } else {
                warn.innerHTML='<div style="color:#34d399;font-size:0.85em;margin-top:6px">x = '+x.toFixed(2)+' is within [-\u03C0/2, \u03C0/2], so arcsin(sin(x)) = x. Try moving x outside this range (beyond \u00B11.57) to see the common mistake.</div>';
            }

            // Show a few concrete examples
            html+='<div style="margin-top:12px;border-top:1px solid rgba(255,255,255,0.04);padding-top:8px">';
            html+='<div style="color:#808098;font-size:0.85em;margin-bottom:6px">Concrete examples:</div>';
            const examples=[0, PI/6, PI/4, 1, PI/2, 2, 3, PI, -1, -2];
            for(const ex of examples){
                const sv=Math.sin(ex);
                const asv=Math.asin(sv);
                const eq=Math.abs(asv-ex)<0.001;
                html+='<div class="math-line" style="font-size:0.82em"><span class="muted">arcsin(sin('+ex.toFixed(2)+')) = '+asv.toFixed(4)+'</span>';
                if(!eq) html+=' <span style="color:#fbbf24">not '+ex.toFixed(2)+'</span>';
                else html+=' <span style="color:#34d399">= x</span>';
                html+='</div>';
            }
            html+='</div>';
        }

        el.innerHTML=html;
    }

    renderBtns();update();
})();

/* ════════════════════════════════════════════════════════════
   SECTION 5: DERIVATIVES OF INVERSE TRIG
   ════════════════════════════════════════════════════════════ */
(function(){
    const cvs=document.getElementById('derivCanvas'), ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;
    let funcType='arctan';
    const btnContainer=document.getElementById('s5Btns');
    const configs={
        arctan:{
            fn:Math.atan, deriv:function(x){return 1/(1+x*x);},
            xMin:-6,xMax:6,yMin:-2.5,yMax:2.5,
            fnLabel:'arctan(x)', derivLabel:"1/(1+x\u00B2) \u2014 the Witch of Agnesi",
            note:'The derivative of arctan(x) is 1/(1+x\u00B2), a bell-shaped curve known as the Witch of Agnesi. Conversely, \u222B1/(1+x\u00B2)dx = arctan(x) + C. This integral appears throughout physics and engineering.'
        },
        arcsin:{
            fn:Math.asin, deriv:function(x){return Math.abs(x)>=1?NaN:1/Math.sqrt(1-x*x);},
            xMin:-1.5,xMax:1.5,yMin:-2.5,yMax:4,
            fnLabel:'arcsin(x)', derivLabel:"1/\u221A(1-x\u00B2)",
            note:'The derivative of arcsin(x) is 1/\u221A(1-x\u00B2), which goes to infinity at x = \u00B11 where the arcsin curve becomes vertical. This is why arcsin has vertical tangent lines at its endpoints.'
        },
        arccos:{
            fn:Math.acos, deriv:function(x){return Math.abs(x)>=1?NaN:-1/Math.sqrt(1-x*x);},
            xMin:-1.5,xMax:1.5,yMin:-4,yMax:4,
            fnLabel:'arccos(x)', derivLabel:"-1/\u221A(1-x\u00B2)",
            note:'The derivative of arccos(x) is -1/\u221A(1-x\u00B2). Notice this is the negative of the arcsin derivative, consistent with the identity arcsin(x) + arccos(x) = \u03C0/2 (differentiating both sides gives d/dx[arcsin] + d/dx[arccos] = 0).'
        }
    };
    const btns=[{id:'arctan',label:'arctan'},{id:'arcsin',label:'arcsin'},{id:'arccos',label:'arccos'}];

    function renderBtns(){
        btnContainer.innerHTML=btns.map(b=>'<button class="btn'+(b.id===funcType?' active':'')+'" data-f="'+b.id+'">'+b.label+'</button>').join('');
        btnContainer.querySelectorAll('.btn').forEach(b=>b.addEventListener('click',()=>{
            funcType=b.dataset.f;renderBtns();draw();
        }));
    }

    function draw(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);
        const c=configs[funcType];
        const xMin=c.xMin,xMax=c.xMax,yMin=c.yMin,yMax=c.yMax;
        const px=W/(xMax-xMin), py=H/(yMax-yMin);
        function toSx(x){return (x-xMin)*px;}
        function toSy(y){return H-(y-yMin)*py;}

        // Grid
        ctx.strokeStyle='rgba(255,255,255,0.04)';ctx.lineWidth=1;
        for(let x=Math.ceil(xMin);x<=Math.floor(xMax);x++){
            ctx.beginPath();ctx.moveTo(toSx(x),0);ctx.lineTo(toSx(x),H);ctx.stroke();
        }
        for(let y=Math.ceil(yMin);y<=Math.floor(yMax);y++){
            ctx.beginPath();ctx.moveTo(0,toSy(y));ctx.lineTo(W,toSy(y));ctx.stroke();
        }
        // Axes
        ctx.strokeStyle='rgba(255,255,255,0.18)';ctx.lineWidth=1.5;
        ctx.beginPath();ctx.moveTo(0,toSy(0));ctx.lineTo(W,toSy(0));ctx.stroke();
        ctx.beginPath();ctx.moveTo(toSx(0),0);ctx.lineTo(toSx(0),H);ctx.stroke();
        // Tick labels
        ctx.font='10px Georgia';ctx.fillStyle='#505068';ctx.textAlign='center';ctx.textBaseline='top';
        for(let x=Math.ceil(xMin);x<=Math.floor(xMax);x++){
            if(x===0) continue;
            ctx.fillText(x,toSx(x),toSy(0)+4);
        }
        ctx.textAlign='right';ctx.textBaseline='middle';
        for(let y=Math.ceil(yMin);y<=Math.floor(yMax);y++){
            if(y===0) continue;
            ctx.fillText(y,toSx(0)-6,toSy(y));
        }

        // Function (emerald)
        ctx.strokeStyle='#34d399';ctx.lineWidth=2.5;
        ctx.beginPath();
        let started=false;
        for(let i=0;i<=W;i++){
            const x=xMin+i/px;
            let y;
            try{y=c.fn(x);}catch(e){started=false;continue;}
            if(isNaN(y)||!isFinite(y)){started=false;continue;}
            const sy=toSy(y);
            if(sy<-20||sy>H+20){started=false;continue;}
            if(!started){ctx.moveTo(i,sy);started=true;}
            else ctx.lineTo(i,sy);
        }
        ctx.stroke();

        // Derivative (gold)
        ctx.strokeStyle='#fbbf24';ctx.lineWidth=2;
        ctx.beginPath();
        started=false;
        for(let i=0;i<=W;i++){
            const x=xMin+i/px;
            let y=c.deriv(x);
            if(isNaN(y)||!isFinite(y)||Math.abs(y)>20){started=false;continue;}
            const sy=toSy(y);
            if(sy<-20||sy>H+20){started=false;continue;}
            if(!started){ctx.moveTo(i,sy);started=true;}
            else ctx.lineTo(i,sy);
        }
        ctx.stroke();

        // Fill under derivative curve (subtle)
        if(funcType==='arctan'){
            ctx.fillStyle='rgba(251,191,36,0.06)';
            ctx.beginPath();
            ctx.moveTo(toSx(xMin),toSy(0));
            for(let i=0;i<=W;i++){
                const x=xMin+i/px;
                const y=c.deriv(x);
                if(!isNaN(y)&&isFinite(y)){
                    ctx.lineTo(i,toSy(y));
                }
            }
            ctx.lineTo(toSx(xMax),toSy(0));
            ctx.closePath();ctx.fill();
        }

        // Asymptotes for arctan
        if(funcType==='arctan'){
            ctx.setLineDash([4,4]);ctx.strokeStyle='rgba(52,211,153,0.25)';ctx.lineWidth=1;
            ctx.beginPath();ctx.moveTo(0,toSy(PI/2));ctx.lineTo(W,toSy(PI/2));ctx.stroke();
            ctx.beginPath();ctx.moveTo(0,toSy(-PI/2));ctx.lineTo(W,toSy(-PI/2));ctx.stroke();
            ctx.setLineDash([]);
            ctx.font='10px Georgia';ctx.fillStyle='rgba(52,211,153,0.5)';ctx.textAlign='right';ctx.textBaseline='bottom';
            ctx.fillText('\u03C0/2',W-4,toSy(PI/2)-2);
            ctx.textBaseline='top';
            ctx.fillText('-\u03C0/2',W-4,toSy(-PI/2)+2);
        }

        // Legend
        ctx.font='13px Georgia';
        ctx.fillStyle='#34d399';ctx.textAlign='left';ctx.textBaseline='top';
        ctx.fillText(c.fnLabel,10,10);
        ctx.fillStyle='#fbbf24';
        ctx.fillText("d/dx: "+c.derivLabel,10,28);

        // Info
        document.getElementById('s5Info').innerHTML='<span class="muted">'+c.note+'</span>';
    }

    renderBtns();draw();
})();

</script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Coded by <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>