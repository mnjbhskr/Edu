<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Non-Euclidean Geometry</title>
    <meta name="description" content="Explore spherical and hyperbolic geometry where parallel lines behave differently. Interactive non-Euclidean surface visualisations.">
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "LearningResource",
      "name": "Non-Euclidean Geometry",
      "url": "https://mathsedu.org/non_euclidean_geometry.html",
      "description": "Explore spherical and hyperbolic geometry where parallel lines behave differently. Interactive non-Euclidean surface visualisations.",
      "educationalLevel": "Advanced",
      "teaches": "Non-Euclidean geometry",
      "learningResourceType": "Interactive visualisation",
      "interactivityType": "active",
      "inLanguage": "en",
      "isAccessibleForFree": true,
      "creator": {
        "@type": "Person",
        "name": "Manoj Bhaskar"
      },
      "license": "https://creativecommons.org/licenses/by-nc-sa/4.0/",
      "isPartOf": {
        "@type": "Course",
        "name": "Geometry",
        "url": "https://mathsedu.org/"
      }
    }
    </script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a1a;color:#e0e0e0;font-family:Georgia,'Times New Roman',serif;line-height:1.6}
        .container{max-width:960px;margin:0 auto;padding:24px 28px 48px}
        .back{color:#606078;text-decoration:none;font-size:0.85em}
        .back:hover{color:#f87171}
        h1{font-size:1.8em;font-weight:400;color:#fff;margin:16px 0 4px}
        .subtitle{color:#808098;font-style:italic;margin-bottom:28px}
        .panel{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:20px 24px;margin-bottom:24px}
        .concept{border-left:3px solid #f87171;padding-left:20px;color:#a0a0b8;font-size:0.93em;line-height:1.75}
        .trio{display:flex;gap:20px;margin-bottom:24px;flex-wrap:wrap;justify-content:center}
        .geo-col{flex:0 0 280px;text-align:center}
        .geo-col canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:grab;margin-bottom:8px}
        .geo-col canvas:active{cursor:grabbing}
        .geo-label{font-size:0.82em;color:#808098;margin-bottom:2px}
        .geo-value{font-size:0.88em;color:#f87171;font-style:italic;min-height:2.4em}
        .slider-row{display:flex;align-items:center;gap:16px;margin-bottom:8px}
        .slider-row label{font-size:0.88em;color:#808098;white-space:nowrap}
        .slider-row input[type=range]{flex:1;accent-color:#f87171}
        .slider-labels{display:flex;justify-content:space-between;font-size:0.75em;color:#606078;margin-bottom:20px}
        .parallel-row{display:flex;gap:20px;margin-bottom:24px;flex-wrap:wrap;justify-content:center}
        .parallel-row canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06)}
        .par-label{text-align:center;font-size:0.78em;color:#808098;margin-top:4px}
        table{border-collapse:collapse;width:100%;margin-top:8px}
        th{padding:8px 12px;text-align:center;font-weight:400;font-size:0.82em;color:#f87171;border-bottom:1px solid rgba(255,255,255,0.08);text-transform:uppercase;letter-spacing:0.5px}
        td{padding:7px 12px;text-align:center;font-size:0.88em;color:#a0a0b8;border-bottom:1px solid rgba(255,255,255,0.04)}
        td:first-child{text-align:left;color:#e0e0e0;font-size:0.85em}
        tr:hover td{background:rgba(248,113,113,0.04)}
        .insight{border-left:3px solid #f87171;padding-left:20px;color:#a0a0b8;font-size:0.9em;line-height:1.75}
        .insight-title{color:#f87171;font-size:0.95em;margin-bottom:4px}
        @media(max-width:920px){.geo-col{flex:1 1 100%}.geo-col canvas{width:100%;height:auto}}
    </style>
</head>
<body>
<div class="container">
    <a class="back" href="index.html">&larr; Back to Index</a>
    <h1>Non-Euclidean Geometry</h1>
    <p class="subtitle">What happens when parallel lines meet &mdash; curved spaces revealed</p>

    <div class="panel">
        <div class="concept">For 2,000 years mathematicians tried to prove Euclid's fifth postulate from the other four. They failed &mdash; because it is independent. Replacing it with alternatives creates entirely consistent geometries on curved surfaces.</div>
    </div>

    <div class="trio">
        <div class="geo-col">
            <canvas id="cEuc" width="280" height="280"></canvas>
            <div class="geo-label">Euclidean &mdash; curvature = 0</div>
            <div class="geo-value" id="vEuc">Angle sum = 180.0&deg; &middot; Exactly 1 parallel</div>
        </div>
        <div class="geo-col">
            <canvas id="cSph" width="280" height="280"></canvas>
            <div class="geo-label">Spherical &mdash; positive curvature</div>
            <div class="geo-value" id="vSph">Angle sum &gt; 180&deg; &middot; 0 parallels</div>
        </div>
        <div class="geo-col">
            <canvas id="cHyp" width="280" height="280"></canvas>
            <div class="geo-label">Hyperbolic &mdash; negative curvature</div>
            <div class="geo-value" id="vHyp">Angle sum &lt; 180&deg; &middot; Infinitely many parallels</div>
        </div>
    </div>

    <div class="panel">
        <div class="slider-row">
            <label>Curvature</label>
            <input type="range" id="curveSlider" min="-100" max="100" value="0">
            <span id="curveVal" style="color:#f87171;font-size:0.9em;min-width:40px;text-align:right">0.00</span>
        </div>
        <div class="slider-labels"><span>-1 Hyperbolic</span><span>0 Euclidean</span><span>+1 Spherical</span></div>
    </div>

    <div class="panel" style="padding-bottom:12px">
        <div style="font-size:0.78em;color:#606078;text-transform:uppercase;letter-spacing:1px;margin-bottom:12px">Parallel Lines Behaviour</div>
        <div class="parallel-row">
            <div><canvas id="pEuc" width="260" height="140"></canvas><div class="par-label">Euclidean: constant separation</div></div>
            <div><canvas id="pSph" width="260" height="140"></canvas><div class="par-label">Spherical: lines converge and meet</div></div>
            <div><canvas id="pHyp" width="260" height="140"></canvas><div class="par-label">Hyperbolic: lines diverge exponentially</div></div>
        </div>
    </div>

    <div class="panel">
        <div style="font-size:0.78em;color:#606078;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px">Properties Comparison</div>
        <table>
            <tr><th style="text-align:left">Property</th><th>Euclidean</th><th>Spherical</th><th>Hyperbolic</th></tr>
            <tr><td>Curvature</td><td>0</td><td>Positive</td><td>Negative</td></tr>
            <tr><td>Parallels through external point</td><td>Exactly 1</td><td>0</td><td>Infinitely many</td></tr>
            <tr><td>Triangle angle sum</td><td>= 180&deg;</td><td>&gt; 180&deg;</td><td>&lt; 180&deg;</td></tr>
            <tr><td>Circle circumference</td><td>2&pi;r</td><td>&lt; 2&pi;r</td><td>&gt; 2&pi;r</td></tr>
            <tr><td>Real-world example</td><td>Flat table</td><td>Earth's surface</td><td>Saddle, Pringles chip</td></tr>
        </table>
    </div>

    <div class="panel">
        <div class="insight">
            <div class="insight-title">Historical Context</div>
            <span id="insightText">Gauss, Bolyai, and Lobachevsky independently discovered hyperbolic geometry in the 1820s&ndash;1830s. Riemann generalised further, creating the framework Einstein would use for General Relativity &mdash; gravity IS the curvature of spacetime.</span>
        </div>
    </div>
</div>

<script>
const ACC = '#f87171', MUTED = '#808098', DIM = 'rgba(255,255,255,0.06)';
const PI = Math.PI, TAU = 2*PI;

/* ---- Utility ---- */
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}
function lerp(a,b,t){return a+(b-a)*t}
function angleBetween(v1,v2){
    let dot=v1.x*v2.x+v1.y*v2.y;
    let cross=v1.x*v2.y-v1.y*v2.x;
    return Math.atan2(Math.abs(cross),dot);
}

/* ---- Triangle vertices (pixel coords) ---- */
const S=280, M=S/2, R0=S*0.32;
function defaultTri(){ return [
    {x:M, y:M-R0},
    {x:M-R0*Math.sin(TAU/3), y:M+R0*Math.cos(TAU/3)},
    {x:M+R0*Math.sin(TAU/3), y:M+R0*Math.cos(TAU/3)}
];}
let triEuc=defaultTri(), triSph=defaultTri(), triHyp=defaultTri().map(p=>({x:lerp(M,p.x,0.55),y:lerp(M,p.y,0.55)}));

/* ---- Curvature ---- */
let K = 0;

/* ---- Euclidean canvas ---- */
function drawEuc(){
    const c=document.getElementById('cEuc'), ctx=c.getContext('2d');
    ctx.clearRect(0,0,S,S);
    // grid
    ctx.strokeStyle='rgba(255,255,255,0.03)';ctx.lineWidth=1;
    for(let i=20;i<S;i+=20){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,S);ctx.stroke();ctx.beginPath();ctx.moveTo(0,i);ctx.lineTo(S,i);ctx.stroke();}
    const T=triEuc;
    // triangle
    ctx.strokeStyle=ACC;ctx.lineWidth=2;
    ctx.beginPath();ctx.moveTo(T[0].x,T[0].y);ctx.lineTo(T[1].x,T[1].y);ctx.lineTo(T[2].x,T[2].y);ctx.closePath();ctx.stroke();
    ctx.fillStyle='rgba(248,113,113,0.06)';ctx.fill();
    // parallel demo: line through T[1]-T[2], parallel through T[0]
    let dx=T[2].x-T[1].x, dy=T[2].y-T[1].y, len=Math.hypot(dx,dy);
    if(len>1){
        dx/=len;dy/=len;
        ctx.strokeStyle='rgba(248,113,113,0.25)';ctx.lineWidth=1;ctx.setLineDash([4,4]);
        ctx.beginPath();ctx.moveTo(T[1].x-dx*300,T[1].y-dy*300);ctx.lineTo(T[1].x+dx*300,T[1].y+dy*300);ctx.stroke();
        ctx.beginPath();ctx.moveTo(T[0].x-dx*300,T[0].y-dy*300);ctx.lineTo(T[0].x+dx*300,T[0].y+dy*300);ctx.stroke();
        ctx.setLineDash([]);
    }
    // vertices
    for(const p of T){ctx.beginPath();ctx.arc(p.x,p.y,5,0,TAU);ctx.fillStyle=ACC;ctx.fill();}
    // angle sum
    let sum=eucAngleSum(T);
    document.getElementById('vEuc').innerHTML='Angle sum = '+sum.toFixed(1)+'&deg; &middot; Exactly 1 parallel';
}

function eucAngleSum(T){
    let s=0;
    for(let i=0;i<3;i++){
        let a=T[i],b=T[(i+1)%3],c=T[(i+2)%3];
        let v1={x:b.x-a.x,y:b.y-a.y},v2={x:c.x-a.x,y:c.y-a.y};
        s+=angleBetween(v1,v2)*180/PI;
    }
    return s;
}

/* ---- Spherical canvas (stereographic-like projection) ---- */
function drawSph(){
    const c=document.getElementById('cSph'), ctx=c.getContext('2d');
    ctx.clearRect(0,0,S,S);
    // sphere outline
    ctx.strokeStyle='rgba(255,255,255,0.08)';ctx.lineWidth=1;
    ctx.beginPath();ctx.arc(M,M,S*0.44,0,TAU);ctx.stroke();
    // latitude lines
    for(let i=1;i<=3;i++){ctx.beginPath();ctx.ellipse(M,M,S*0.44*(i/4),S*0.44*(i/4)*0.3,0,0,TAU);ctx.stroke();}
    // longitude hints
    for(let a=0;a<PI;a+=PI/4){ctx.beginPath();ctx.ellipse(M,M,S*0.44*Math.abs(Math.cos(a)),S*0.44,a,0,TAU);ctx.stroke();}
    const T=triSph, sphR=S*0.44;
    // great circle arcs (bow outward)
    let sum=0;
    ctx.strokeStyle=ACC;ctx.lineWidth=2;
    for(let i=0;i<3;i++){
        let a=T[i],b=T[(i+1)%3];
        drawGreatArc(ctx,a,b,sphR);
    }
    ctx.fillStyle='rgba(248,113,113,0.06)';
    ctx.beginPath();
    sphTriPath(ctx,T,sphR);
    ctx.fill();
    // angles
    sum = sphAngleSum(T, sphR);
    for(const p of T){ctx.beginPath();ctx.arc(p.x,p.y,5,0,TAU);ctx.fillStyle=ACC;ctx.fill();}
    document.getElementById('vSph').innerHTML='Angle sum = '+sum.toFixed(1)+'&deg; &gt; 180&deg; &middot; 0 parallels';
}

function greatArcBulge(a,b,sphR){
    let mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    let dm=dist({x:mx,y:my},{x:M,y:M});
    let chord=dist(a,b);
    if(chord<1)return{cx:mx,cy:my};
    // Bulge outward from sphere center -- larger triangles and those farther from center bulge more
    let bulge=0.22+0.28*(dm/sphR);
    let nx=-(b.y-a.y)/chord, ny=(b.x-a.x)/chord;
    let sign=((mx-M)*nx+(my-M)*ny)>0?1:-1;
    return {cx:mx+nx*chord*bulge*sign, cy:my+ny*chord*bulge*sign};
}

function drawGreatArc(ctx,a,b,sphR){
    let cp=greatArcBulge(a,b,sphR);
    ctx.beginPath();ctx.moveTo(a.x,a.y);ctx.quadraticCurveTo(cp.cx,cp.cy,b.x,b.y);ctx.stroke();
}

function sphTriPath(ctx,T,sphR){
    let cp0=greatArcBulge(T[0],T[1],sphR);
    let cp1=greatArcBulge(T[1],T[2],sphR);
    let cp2=greatArcBulge(T[2],T[0],sphR);
    ctx.moveTo(T[0].x,T[0].y);
    ctx.quadraticCurveTo(cp0.cx,cp0.cy,T[1].x,T[1].y);
    ctx.quadraticCurveTo(cp1.cx,cp1.cy,T[2].x,T[2].y);
    ctx.quadraticCurveTo(cp2.cx,cp2.cy,T[0].x,T[0].y);
}

function sphAngleSum(T,sphR){
    let sum=0;
    for(let i=0;i<3;i++){
        let a=T[i],b=T[(i+1)%3],c=T[(i+2)%3];
        let cpb=greatArcBulge(a,b,sphR);
        let cpc=greatArcBulge(a,c,sphR);
        // tangent at a toward b via control point
        let tb={x:2*(cpb.cx-a.x),y:2*(cpb.cy-a.y)};
        let tc={x:2*(cpc.cx-a.x),y:2*(cpc.cy-a.y)};
        sum+=angleBetween(tb,tc)*180/PI;
    }
    return sum;
}

/* ---- Hyperbolic canvas (Poincare disc) ---- */
function drawHyp(){
    const c=document.getElementById('cHyp'), ctx=c.getContext('2d');
    ctx.clearRect(0,0,S,S);
    const dR=S*0.44; // disc radius
    // boundary circle
    ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.lineWidth=1.5;
    ctx.beginPath();ctx.arc(M,M,dR,0,TAU);ctx.stroke();
    // faint concentric circles for hyperbolic feel
    for(let r=dR*0.25;r<dR;r+=dR*0.25){ctx.strokeStyle='rgba(255,255,255,0.025)';ctx.beginPath();ctx.arc(M,M,r,0,TAU);ctx.stroke();}
    const T=triHyp;
    // clamp points inside disc
    for(let p of T){
        let d=dist(p,{x:M,y:M});
        if(d>dR*0.92){let s=dR*0.92/d;p.x=M+(p.x-M)*s;p.y=M+(p.y-M)*s;}
    }
    // geodesic arcs
    ctx.strokeStyle=ACC;ctx.lineWidth=2;
    for(let i=0;i<3;i++) drawHypGeodesic(ctx,T[i],T[(i+1)%3],dR);
    // fill triangle
    ctx.fillStyle='rgba(248,113,113,0.06)';
    ctx.beginPath();
    hypTriPath(ctx,T,dR);
    ctx.fill();
    // parallel lines through T[0] not meeting line T[1]-T[2]
    drawHypParallels(ctx,T,dR);
    // vertices
    for(const p of T){ctx.beginPath();ctx.arc(p.x,p.y,5,0,TAU);ctx.fillStyle=ACC;ctx.fill();}
    // angle sum
    let sum=hypAngleSum(T,dR);
    document.getElementById('vHyp').innerHTML='Angle sum = '+sum.toFixed(1)+'&deg; &lt; 180&deg; &middot; &infin; parallels';
}

function toDisc(p,dR){return {x:(p.x-M)/dR, y:(p.y-M)/dR};}
function fromDisc(p,dR){return {x:p.x*dR+M, y:p.y*dR+M};}

function hypGeodesicArc(P,Q,dR){
    // Convert to unit disc coords
    let p=toDisc(P,dR), q=toDisc(Q,dR);
    let px=p.x,py=p.y,qx=q.x,qy=q.y;
    // If nearly through center, treat as straight line
    let cross=px*qy-py*qx;
    if(Math.abs(cross)<0.01){
        return null; // straight line (diameter)
    }
    // Inversion of p: p* = p/|p|^2
    let pn2=px*px+py*py, qn2=qx*qx+qy*qy;
    let psx=px/pn2, psy=py/pn2;
    let qsx=qx/qn2, qsy=qy/qn2;
    // Circle through p, q, p*, q* -- actually through p, q and orthogonal to unit circle
    // Using the formula: center of circle through p and q orthogonal to unit circle
    let denom=2*cross;
    let cx=(qy*(pn2+1)-py*(qn2+1))/denom;
    let cy=(px*(qn2+1)-qx*(pn2+1))/denom;
    let cr=Math.hypot(px-cx,py-cy);
    return {cx:cx*dR+M, cy:cy*dR+M, cr:cr*dR, p:P, q:Q};
}

function drawHypGeodesic(ctx,P,Q,dR){
    let arc=hypGeodesicArc(P,Q,dR);
    if(!arc){
        ctx.beginPath();ctx.moveTo(P.x,P.y);ctx.lineTo(Q.x,Q.y);ctx.stroke();
        return;
    }
    let a1=Math.atan2(P.y-arc.cy,P.x-arc.cx);
    let a2=Math.atan2(Q.y-arc.cy,Q.x-arc.cx);
    // determine direction
    let da=a2-a1;
    while(da>PI)da-=TAU; while(da<-PI)da+=TAU;
    ctx.beginPath();
    ctx.arc(arc.cx,arc.cy,arc.cr,a1,a1+da,da<0);
    ctx.stroke();
}

function hypTriPath(ctx,T,dR){
    // Approximate with many points along each geodesic
    function arcPoints(P,Q){
        let arc=hypGeodesicArc(P,Q,dR);
        let pts=[];
        if(!arc){
            for(let t=0;t<=1;t+=0.05)pts.push({x:lerp(P.x,Q.x,t),y:lerp(P.y,Q.y,t)});
            return pts;
        }
        let a1=Math.atan2(P.y-arc.cy,P.x-arc.cx);
        let a2=Math.atan2(Q.y-arc.cy,Q.x-arc.cx);
        let da=a2-a1;while(da>PI)da-=TAU;while(da<-PI)da+=TAU;
        for(let t=0;t<=1;t+=0.05){
            let a=a1+da*t;
            pts.push({x:arc.cx+arc.cr*Math.cos(a),y:arc.cy+arc.cr*Math.sin(a)});
        }
        return pts;
    }
    let all=[...arcPoints(T[0],T[1]),...arcPoints(T[1],T[2]),...arcPoints(T[2],T[0])];
    ctx.moveTo(all[0].x,all[0].y);
    for(let i=1;i<all.length;i++)ctx.lineTo(all[i].x,all[i].y);
    ctx.closePath();
}

function hypAngleSum(T,dR){
    let sum=0;
    for(let i=0;i<3;i++){
        let A=T[i],B=T[(i+1)%3],C=T[(i+2)%3];
        // Tangent at A along geodesic AB
        let tb=hypTangent(A,B,dR);
        let tc=hypTangent(A,C,dR);
        sum+=angleBetween(tb,tc)*180/PI;
    }
    return sum;
}

function hypTangent(P,Q,dR){
    let arc=hypGeodesicArc(P,Q,dR);
    if(!arc){return {x:Q.x-P.x,y:Q.y-P.y};}
    // tangent to circle at P: perpendicular to radius from arc center to P
    let rx=P.x-arc.cx, ry=P.y-arc.cy;
    // two possible tangent directions, pick the one toward Q
    let t1={x:-ry,y:rx}, t2={x:ry,y:-rx};
    let d1=(Q.x-P.x)*t1.x+(Q.y-P.y)*t1.y;
    return d1>0?t1:t2;
}

function drawHypParallels(ctx,T,dR){
    // Show a few lines through T[0] that don't cross geodesic T[1]-T[2]
    ctx.strokeStyle='rgba(248,113,113,0.15)';ctx.lineWidth=1;ctx.setLineDash([3,3]);
    let p=toDisc(T[0],dR);
    for(let angle=0;angle<PI;angle+=PI/5){
        let dx=Math.cos(angle)*0.01, dy=Math.sin(angle)*0.01;
        let q={x:p.x+dx,y:p.y+dy};
        let Q=fromDisc(q,dR);
        // Extend toward boundary
        let ext=fromDisc({x:p.x+Math.cos(angle)*0.85,y:p.y+Math.sin(angle)*0.85},dR);
        let dd=dist(ext,{x:M,y:M});
        if(dd<dR*0.98){
            let arc=hypGeodesicArc(T[0],ext,dR);
            if(arc){
                let a1=Math.atan2(T[0].y-arc.cy,T[0].x-arc.cx);
                let a2=Math.atan2(ext.y-arc.cy,ext.x-arc.cx);
                let da=a2-a1;while(da>PI)da-=TAU;while(da<-PI)da+=TAU;
                ctx.beginPath();ctx.arc(arc.cx,arc.cy,arc.cr,a1,a1+da,da<0);ctx.stroke();
            } else {
                ctx.beginPath();ctx.moveTo(T[0].x,T[0].y);ctx.lineTo(ext.x,ext.y);ctx.stroke();
            }
        }
    }
    ctx.setLineDash([]);
}

/* ---- Parallel lines animation canvases ---- */
let parTime=0;
function drawParallels(){
    parTime+=0.008;
    drawParEuc();drawParSph();drawParHyp();
    requestAnimationFrame(drawParallels);
}

function drawParEuc(){
    const c=document.getElementById('pEuc'),ctx=c.getContext('2d'),W=c.width,H=c.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='rgba(255,255,255,0.015)';ctx.fillRect(0,0,W,H);
    ctx.strokeStyle=ACC;ctx.lineWidth=1.5;
    let y1=H*0.38, y2=H*0.62;
    ctx.beginPath();ctx.moveTo(0,y1);ctx.lineTo(W,y1);ctx.stroke();
    ctx.beginPath();ctx.moveTo(0,y2);ctx.lineTo(W,y2);ctx.stroke();
    // moving marker
    let mx=(parTime*80)%W;
    ctx.fillStyle='rgba(248,113,113,0.5)';
    ctx.beginPath();ctx.arc(mx,y1,3,0,TAU);ctx.fill();
    ctx.beginPath();ctx.arc(mx,y2,3,0,TAU);ctx.fill();
    // distance indicator
    ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.setLineDash([2,3]);
    ctx.beginPath();ctx.moveTo(mx,y1);ctx.lineTo(mx,y2);ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle=MUTED;ctx.font='11px Georgia';ctx.textAlign='center';
    ctx.fillText('d = const',mx,H*0.52);
}

function drawParSph(){
    const c=document.getElementById('pSph'),ctx=c.getContext('2d'),W=c.width,H=c.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='rgba(255,255,255,0.015)';ctx.fillRect(0,0,W,H);
    ctx.strokeStyle=ACC;ctx.lineWidth=1.5;
    // Two "longitude lines" that converge: start parallel, then meet
    let pts1=[],pts2=[];
    for(let t=0;t<=1;t+=0.01){
        let x=t*W;
        let spread=(1-t)*(H*0.12);
        pts1.push({x:x,y:H/2-spread});
        pts2.push({x:x,y:H/2+spread});
    }
    ctx.beginPath();pts1.forEach((p,i)=>i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y));ctx.stroke();
    ctx.beginPath();pts2.forEach((p,i)=>i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y));ctx.stroke();
    // moving marker
    let t=((parTime*0.4)%1);
    let idx=Math.floor(t*100);idx=Math.min(idx,pts1.length-1);
    ctx.fillStyle='rgba(248,113,113,0.5)';
    ctx.beginPath();ctx.arc(pts1[idx].x,pts1[idx].y,3,0,TAU);ctx.fill();
    ctx.beginPath();ctx.arc(pts2[idx].x,pts2[idx].y,3,0,TAU);ctx.fill();
    // convergence point marker
    ctx.fillStyle='rgba(248,113,113,0.3)';ctx.font='11px Georgia';ctx.textAlign='right';
    ctx.fillText('lines meet',W-8,H/2+4);
}

function drawParHyp(){
    const c=document.getElementById('pHyp'),ctx=c.getContext('2d'),W=c.width,H=c.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='rgba(255,255,255,0.015)';ctx.fillRect(0,0,W,H);
    ctx.strokeStyle=ACC;ctx.lineWidth=1.5;
    // Two lines that diverge exponentially
    let pts1=[],pts2=[];
    for(let t=0;t<=1;t+=0.01){
        let x=t*W;
        let spread=H*0.04*Math.exp(2.2*t);
        spread=Math.min(spread,H*0.48);
        pts1.push({x:x,y:H/2-spread});
        pts2.push({x:x,y:H/2+spread});
    }
    ctx.beginPath();pts1.forEach((p,i)=>i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y));ctx.stroke();
    ctx.beginPath();pts2.forEach((p,i)=>i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y));ctx.stroke();
    let t=((parTime*0.4)%1);
    let idx=Math.floor(t*100);idx=Math.min(idx,pts1.length-1);
    ctx.fillStyle='rgba(248,113,113,0.5)';
    ctx.beginPath();ctx.arc(pts1[idx].x,pts1[idx].y,3,0,TAU);ctx.fill();
    ctx.beginPath();ctx.arc(pts2[idx].x,pts2[idx].y,3,0,TAU);ctx.fill();
    ctx.fillStyle=MUTED;ctx.font='11px Georgia';ctx.textAlign='right';
    ctx.fillText('d grows exponentially',W-8,H-8);
}

/* ---- Drag handling ---- */
function setupDrag(canvasId, triRef, drawFn, constraint){
    const cvs=document.getElementById(canvasId);
    let dragging=-1;
    cvs.addEventListener('mousedown',e=>{
        let r=cvs.getBoundingClientRect();
        let mx=e.clientX-r.left, my=e.clientY-r.top;
        let sx=cvs.width/r.width, sy=cvs.height/r.height;
        mx*=sx;my*=sy;
        for(let i=0;i<3;i++){
            if(dist({x:mx,y:my},triRef[i])<15){dragging=i;break;}
        }
    });
    cvs.addEventListener('mousemove',e=>{
        if(dragging<0)return;
        let r=cvs.getBoundingClientRect();
        let mx=(e.clientX-r.left)*(cvs.width/r.width);
        let my=(e.clientY-r.top)*(cvs.height/r.height);
        if(constraint){
            let c=constraint(mx,my);
            mx=c.x;my=c.y;
        }
        triRef[dragging].x=mx;
        triRef[dragging].y=my;
        drawAll();
    });
    cvs.addEventListener('mouseup',()=>{dragging=-1;});
    cvs.addEventListener('mouseleave',()=>{dragging=-1;});
    // Touch support
    cvs.addEventListener('touchstart',e=>{
        e.preventDefault();
        let r=cvs.getBoundingClientRect();
        let t=e.touches[0];
        let mx=(t.clientX-r.left)*(cvs.width/r.width);
        let my=(t.clientY-r.top)*(cvs.height/r.height);
        for(let i=0;i<3;i++){
            if(dist({x:mx,y:my},triRef[i])<20){dragging=i;break;}
        }
    },{passive:false});
    cvs.addEventListener('touchmove',e=>{
        e.preventDefault();
        if(dragging<0)return;
        let r=cvs.getBoundingClientRect();
        let t=e.touches[0];
        let mx=(t.clientX-r.left)*(cvs.width/r.width);
        let my=(t.clientY-r.top)*(cvs.height/r.height);
        if(constraint){let c=constraint(mx,my);mx=c.x;my=c.y;}
        triRef[dragging].x=mx;triRef[dragging].y=my;
        drawAll();
    },{passive:false});
    cvs.addEventListener('touchend',()=>{dragging=-1;});
}

function constrainToDisc(mx,my){
    let dx=mx-M, dy=my-M, d=Math.hypot(dx,dy);
    let maxR=S*0.44*0.88;
    if(d>maxR){dx*=maxR/d;dy*=maxR/d;}
    return {x:M+dx,y:M+dy};
}

function constrainToSphere(mx,my){
    let dx=mx-M, dy=my-M, d=Math.hypot(dx,dy);
    let maxR=S*0.44*0.9;
    if(d>maxR){dx*=maxR/d;dy*=maxR/d;}
    return {x:M+dx,y:M+dy};
}

setupDrag('cEuc',triEuc,drawEuc,null);
setupDrag('cSph',triSph,drawSph,constrainToSphere);
setupDrag('cHyp',triHyp,drawHyp,constrainToDisc);

/* ---- Curvature slider ---- */
const slider=document.getElementById('curveSlider');
slider.addEventListener('input',()=>{
    K=parseInt(slider.value)/100;
    document.getElementById('curveVal').textContent=K.toFixed(2);
    updateFromSlider();
});

function updateFromSlider(){
    // Highlight the relevant canvas by adjusting border color
    document.getElementById('cEuc').style.borderColor = Math.abs(K)<0.05 ? ACC : DIM;
    document.getElementById('cSph').style.borderColor = K>0.05 ? ACC : DIM;
    document.getElementById('cHyp').style.borderColor = K<-0.05 ? ACC : DIM;

    // Morph all three triangles based on curvature to show the continuous transition
    // The spherical triangle sides bulge outward proportional to K (when K>0)
    // The hyperbolic triangle sides curve inward proportional to |K| (when K<0)
    // We encode this via the existing draw functions but update the insight text
    updateInsight();
    drawAll();
}

function updateInsight(){
    const el=document.getElementById('insightText');
    if(K>0.05){
        el.innerHTML='Airline routes follow great circles &mdash; the &ldquo;straight lines&rdquo; of spherical geometry. A triangle formed by the equator and two meridians can have angle sum up to 540&deg;. As curvature increases, the excess angle grows proportionally to the triangle&rsquo;s area.';
    } else if(K<-0.05){
        el.innerHTML='Hyperbolic geometry appears in nature: coral reefs, lettuce leaves, and crochet models all exhibit negative curvature. Through any point not on a given line, infinitely many lines pass without ever intersecting it &mdash; the angle of parallelism shrinks as curvature deepens.';
    } else {
        el.innerHTML='Gauss, Bolyai, and Lobachevsky independently discovered hyperbolic geometry in the 1820s&ndash;1830s. Riemann generalised further, creating the framework Einstein would use for General Relativity &mdash; gravity IS the curvature of spacetime.';
    }
}

/* ---- Main draw ---- */
function drawAll(){drawEuc();drawSph();drawHyp();}
drawAll();
drawParallels();
</script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Coded by <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
