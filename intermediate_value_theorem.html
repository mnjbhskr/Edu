<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intermediate Value Theorem</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a1a;color:#e0e0e0;font-family:Georgia,'Times New Roman',serif;line-height:1.6}
        .container{max-width:960px;margin:0 auto;padding:24px 28px 48px}
        .back{color:#606078;text-decoration:none;font-size:0.85em}
        .back:hover{color:#818cf8}
        h1{font-size:1.8em;font-weight:400;color:#fff;margin:16px 0 4px}
        .subtitle{color:#808098;font-style:italic;margin-bottom:28px}
        h2{font-size:1.15em;font-weight:400;color:#fff;margin:28px 0 12px}
        canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:crosshair}
        .panel{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:18px 22px;margin-bottom:20px}
        .panel h3{font-weight:400;font-size:0.8em;color:#808098;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
        .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
        .btn{background:rgba(255,255,255,0.035);border:1px solid rgba(255,255,255,0.07);color:#b0b0c4;padding:5px 13px;border-radius:6px;cursor:pointer;font-family:Georgia,serif;font-size:0.92em;transition:all 0.2s}
        .btn:hover{background:rgba(255,255,255,0.07);color:#e0e0ef}
        .btn.active{background:rgba(129,140,248,0.13);border-color:rgba(129,140,248,0.4);color:#818cf8}
        .math-line{font-family:'Courier New',monospace;font-size:0.92em;color:#c0c0d8;margin:4px 0;line-height:1.8}
        .math-line .indigo{color:#818cf8}.math-line .gold{color:#fbbf24}.math-line .green{color:#2ecc71}.math-line .red{color:#ef4444}
        .math-line .muted{color:#808098}
        .explain{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:20px 24px;margin-top:20px}
        .explain-name{color:#818cf8;font-size:1.1em;margin-bottom:6px}
        .explain-text{color:#a0a0b8;font-size:0.9em;line-height:1.75}
        .slider-row{display:flex;align-items:center;gap:14px;margin:10px 0}
        .slider-row input[type=range]{flex:1;max-width:300px;accent-color:#818cf8}
        .slider-label{color:#818cf8;font-family:'Courier New',monospace;font-size:1.05em;min-width:70px}
        .flex-row{display:flex;gap:20px;flex-wrap:wrap}
        .flex-row>.flex-half{flex:1 1 300px;min-width:280px}
        .info-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px 20px;font-family:'Courier New',monospace;font-size:0.88em;margin:10px 0}
        .info-grid .label{color:#808098}.info-grid .value{color:#c0c0d8}
        .convergence-table{width:100%;border-collapse:collapse;font-family:'Courier New',monospace;font-size:0.82em;margin-top:10px}
        .convergence-table th{color:#808098;font-weight:400;text-align:left;padding:4px 8px;border-bottom:1px solid rgba(255,255,255,0.06)}
        .convergence-table td{color:#c0c0d8;padding:4px 8px;border-bottom:1px solid rgba(255,255,255,0.03)}
        .app-card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05);border-radius:8px;padding:14px 18px;margin-bottom:14px}
        .app-card .app-title{color:#818cf8;font-size:0.95em;margin-bottom:6px}
        .app-card .app-text{color:#a0a0b8;font-size:0.88em;line-height:1.7}
        @media(max-width:600px){canvas{width:100%!important;height:auto!important}}
    </style>
</head>
<body>
<div class="container">
    <a class="back" href="index.html">&larr; Back to Index</a>
    <h1>Intermediate Value Theorem</h1>
    <p class="subtitle">Continuous functions must cross &mdash; the foundation of root finding</p>

    <!-- Section 1: The IVT Visualized -->
    <h2>The IVT Visualized</h2>
    <div class="panel">
        <h3>Preset Functions</h3>
        <div class="btn-row" id="ivtPresets"></div>
        <canvas id="ivtCanvas" width="700" height="400"></canvas>
        <div class="slider-row" style="margin-top:14px">
            <span class="math-line muted">y&#8320; =</span>
            <input type="range" id="y0Slider" min="0" max="1000" value="500">
            <span class="slider-label" id="y0Label">0.00</span>
            <button class="btn" id="animateBtn">Animate</button>
        </div>
        <div class="info-grid" id="ivtInfo"></div>
    </div>

    <!-- Section 2: Why Continuity Matters -->
    <h2>Why Continuity Matters</h2>
    <div class="panel">
        <h3>Discontinuous Function</h3>
        <canvas id="discCanvas" width="500" height="300"></canvas>
        <div style="margin-top:14px">
            <button class="btn" id="contToggle">Make Continuous</button>
            <span class="math-line muted" id="contLabel" style="margin-left:12px">The function has a jump discontinuity at x = 1</span>
        </div>
    </div>

    <!-- Section 3 & 4: Bisection and Newton's Method -->
    <h2>Root Finding: Bisection vs Newton's Method</h2>
    <div class="panel">
        <h3>Method</h3>
        <div class="btn-row" id="methodBtns"></div>
        <div class="btn-row">
            <button class="btn" id="rfPreset1">x&sup2; - 2 on [1, 2]</button>
            <button class="btn" id="rfPreset2">x&sup3; - x - 1 on [1, 2]</button>
            <button class="btn" id="rfPreset3">sin(x) - 0.5 on [0, 2]</button>
        </div>
        <canvas id="rootCanvas" width="700" height="350"></canvas>
        <div style="margin-top:14px;display:flex;gap:8px;flex-wrap:wrap">
            <button class="btn" id="stepBtn">Step</button>
            <button class="btn" id="autoBtn">Auto</button>
            <button class="btn" id="resetBtn">Reset</button>
        </div>
        <div class="info-grid" id="rfInfo" style="margin-top:10px"></div>
        <div id="rfHistory" style="margin-top:10px;max-height:200px;overflow-y:auto"></div>
    </div>

    <!-- Convergence Comparison -->
    <div class="panel">
        <h3>Convergence Comparison</h3>
        <canvas id="convCanvas" width="700" height="250"></canvas>
        <div class="math-line muted" style="margin-top:8px">Bisection: linear convergence, width = (b-a)/2<sup>n</sup> &mdash; Newton: quadratic convergence, error ~ error&sup2;</div>
    </div>

    <!-- Section 5: Applications -->
    <h2>Applications</h2>

    <div class="app-card">
        <div class="app-title">Temperature</div>
        <div class="app-text">"If it was 5&deg;C at dawn and 25&deg;C at noon, at some moment it was exactly 15&deg;C."</div>
        <canvas id="tempCanvas" width="460" height="180" style="margin-top:10px;cursor:default"></canvas>
    </div>

    <div class="app-card">
        <div class="app-title">Existence of &radic;2</div>
        <div class="app-text">f(x) = x&sup2; - 2 is continuous, f(1) = -1 &lt; 0, f(2) = 2 &gt; 0. By the IVT, there exists c in (1, 2) with f(c) = 0. This proves &radic;2 exists without constructing it!</div>
        <canvas id="sqrt2Canvas" width="460" height="180" style="margin-top:10px;cursor:default"></canvas>
    </div>

    <div class="app-card">
        <div class="app-title">Antipodal Points (Borsuk-Ulam, 1D)</div>
        <div class="app-text">At any moment, two diametrically opposite points on a circle (e.g., the equator of the Earth) have the same temperature. Define g(x) = T(x) - T(x + 180&deg;). Since g is continuous and g(0) = -g(180&deg;), the IVT guarantees g(c) = 0 for some c &mdash; meaning T(c) = T(c + 180&deg;).</div>
    </div>

    <!-- Section 6: Explanation -->
    <div class="explain">
        <div class="explain-name">What have we learnt?</div>
        <div class="explain-text">
            The Intermediate Value Theorem tells us a solution <em>exists</em> &mdash; not how to find it. But combined with bisection, it gives us a powerful root-finding algorithm: if f(a) and f(b) have opposite signs, repeatedly halve the interval. Newton's method converges far faster (quadratic vs linear), but requires differentiability and a good starting point.
            <br><br>
            The theorem depends crucially on two things: <strong>continuity</strong> of the function and the <strong>completeness</strong> of the real numbers. Completeness means the reals have no "gaps" &mdash; every bounded increasing sequence converges. This is why the rationals fail: x&sup2; = 2 has no rational solution, so IVT would be false over the rationals.
            <br><br>
            Philosophically, IVT captures something intuitive: a continuous path from below zero to above zero must cross zero somewhere. Yet making this rigorous required the 19th-century revolution in analysis &mdash; Bolzano (1817) gave the first proof, followed by Cauchy and Weierstrass, who formalized the epsilon-delta definition of continuity that makes IVT provable.
        </div>
    </div>
</div>

<script>
/* ====== SECTION 1: IVT VISUALIZED ====== */
const ACCENT = '#818cf8';
const ACCENT_DIM = 'rgba(129,140,248,0.3)';
const ACCENT_GLOW = 'rgba(129,140,248,0.5)';
const GOLD = '#fbbf24';
const GREEN = '#2ecc71';
const RED = '#ef4444';
const MUTED = '#808098';
const BG = '#0a0a1a';

const ivtCvs = document.getElementById('ivtCanvas');
const ivtCtx = ivtCvs.getContext('2d');
const IW = ivtCvs.width, IH = ivtCvs.height;

const ivtPresets = [
    { label: 'x\u00B3 - x', fn: x => x*x*x - x, a: -2, b: 2, name: 'x\u00B3 - x' },
    { label: 'sin(x)', fn: x => Math.sin(x), a: 0, b: Math.PI, name: 'sin(x)' },
    { label: 'x\u00B2 - 2', fn: x => x*x - 2, a: 0, b: 2, name: 'x\u00B2 - 2' },
    { label: 'e\u02E3 - 3', fn: x => Math.exp(x) - 3, a: 0, b: 2, name: 'e\u02E3 - 3' },
    { label: 'x\u2075 - x - 1', fn: x => Math.pow(x,5) - x - 1, a: 0, b: 2, name: 'x\u2075 - x - 1' }
];

let ivtPresetIdx = 0;
let ivtY0 = 0;
let ivtAnimating = false;
let ivtAnimId = null;

function getIVTFn() { return ivtPresets[ivtPresetIdx]; }

function evalRange(fn, a, b, n) {
    const pts = [];
    const dx = (b - a) / n;
    for (let i = 0; i <= n; i++) {
        const x = a + i * dx;
        pts.push({ x, y: fn(x) });
    }
    return pts;
}

function findIntersections(fn, a, b, y0, n) {
    const results = [];
    const dx = (b - a) / n;
    let prevX = a, prevY = fn(a) - y0;
    for (let i = 1; i <= n; i++) {
        const x = a + i * dx;
        const y = fn(x) - y0;
        if (prevY * y <= 0 && (prevY !== 0 || y !== 0)) {
            /* linear interpolation */
            const t = Math.abs(prevY) / (Math.abs(prevY) + Math.abs(y) + 1e-15);
            const cx = prevX + t * dx;
            results.push(cx);
        }
        prevX = x; prevY = y;
    }
    return results;
}

function renderIVTPresets() {
    const c = document.getElementById('ivtPresets');
    c.innerHTML = ivtPresets.map((p, i) =>
        '<button class="btn' + (i === ivtPresetIdx ? ' active' : '') + '" data-pi="' + i + '">' + p.label + '</button>'
    ).join('');
    c.querySelectorAll('.btn').forEach(b => b.addEventListener('click', () => {
        ivtPresetIdx = parseInt(b.dataset.pi);
        updateY0Slider();
        renderIVTPresets();
        drawIVT();
    }));
}

function updateY0Slider() {
    const p = getIVTFn();
    const pts = evalRange(p.fn, p.a, p.b, 500);
    const fa = p.fn(p.a), fb = p.fn(p.b);
    const yMin = Math.min(fa, fb);
    const yMax = Math.max(fa, fb);
    const slider = document.getElementById('y0Slider');
    const t = parseFloat(slider.value) / 1000;
    ivtY0 = yMin + t * (yMax - yMin);
    document.getElementById('y0Label').textContent = ivtY0.toFixed(4);
}

document.getElementById('y0Slider').addEventListener('input', () => {
    updateY0Slider();
    drawIVT();
});

function drawIVT() {
    const p = getIVTFn();
    const fn = p.fn;
    const a = p.a, b = p.b;
    const pts = evalRange(fn, a, b, 500);

    /* compute range for auto-scaling */
    let yMin = Infinity, yMax = -Infinity;
    for (const pt of pts) {
        if (pt.y < yMin) yMin = pt.y;
        if (pt.y > yMax) yMax = pt.y;
    }
    const yPad = (yMax - yMin) * 0.12 || 1;
    yMin -= yPad; yMax += yPad;
    const xPad = (b - a) * 0.08;
    const xMin = a - xPad, xMax = b + xPad;

    const ctx = ivtCtx;
    const W = IW, H = IH;
    const margin = { l: 60, r: 20, t: 20, b: 40 };
    const pw = W - margin.l - margin.r;
    const ph = H - margin.t - margin.b;

    function toSx(x) { return margin.l + (x - xMin) / (xMax - xMin) * pw; }
    function toSy(y) { return margin.t + (1 - (y - yMin) / (yMax - yMin)) * ph; }

    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);

    /* grid lines */
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
    const xStep = niceStep(xMax - xMin, 8);
    const yStep = niceStep(yMax - yMin, 6);
    for (let x = Math.ceil(xMin / xStep) * xStep; x <= xMax; x += xStep) {
        const sx = toSx(x);
        ctx.beginPath(); ctx.moveTo(sx, margin.t); ctx.lineTo(sx, H - margin.b); ctx.stroke();
    }
    for (let y = Math.ceil(yMin / yStep) * yStep; y <= yMax; y += yStep) {
        const sy = toSy(y);
        ctx.beginPath(); ctx.moveTo(margin.l, sy); ctx.lineTo(W - margin.r, sy); ctx.stroke();
    }

    /* axes */
    ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1;
    if (yMin <= 0 && yMax >= 0) {
        const sy0 = toSy(0);
        ctx.beginPath(); ctx.moveTo(margin.l, sy0); ctx.lineTo(W - margin.r, sy0); ctx.stroke();
    }
    if (xMin <= 0 && xMax >= 0) {
        const sx0 = toSx(0);
        ctx.beginPath(); ctx.moveTo(sx0, margin.t); ctx.lineTo(sx0, H - margin.b); ctx.stroke();
    }

    /* tick labels */
    ctx.font = '10px Georgia'; ctx.fillStyle = '#505068'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for (let x = Math.ceil(xMin / xStep) * xStep; x <= xMax; x += xStep) {
        ctx.fillText(formatNum(x), toSx(x), H - margin.b + 6);
    }
    ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
    for (let y = Math.ceil(yMin / yStep) * yStep; y <= yMax; y += yStep) {
        ctx.fillText(formatNum(y), margin.l - 8, toSy(y));
    }

    /* horizontal dashed lines at f(a) and f(b) */
    const fa = fn(a), fb = fn(b);
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = GOLD; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(toSx(xMin), toSy(fa)); ctx.lineTo(toSx(xMax), toSy(fa)); ctx.stroke();
    ctx.strokeStyle = GREEN;
    ctx.beginPath(); ctx.moveTo(toSx(xMin), toSy(fb)); ctx.lineTo(toSx(xMax), toSy(fb)); ctx.stroke();
    ctx.setLineDash([]);

    /* labels for f(a) and f(b) */
    ctx.font = '11px Georgia';
    ctx.fillStyle = GOLD; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
    ctx.fillText('f(a) = ' + fa.toFixed(3), toSx(xMin) + 4, toSy(fa) - 4);
    ctx.fillStyle = GREEN; ctx.textBaseline = 'top';
    ctx.fillText('f(b) = ' + fb.toFixed(3), toSx(xMin) + 4, toSy(fb) + 4);

    /* points at (a, f(a)) and (b, f(b)) */
    ctx.fillStyle = GOLD;
    ctx.beginPath(); ctx.arc(toSx(a), toSy(fa), 4, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = GREEN;
    ctx.beginPath(); ctx.arc(toSx(b), toSy(fb), 4, 0, Math.PI * 2); ctx.fill();

    /* the function curve */
    ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 2; ctx.lineCap = 'round';
    ctx.beginPath();
    for (let i = 0; i < pts.length; i++) {
        const sx = toSx(pts[i].x), sy = toSy(pts[i].y);
        if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.stroke();

    /* y0 horizontal line */
    const y0Clamped = ivtY0;
    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = ACCENT; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(toSx(xMin), toSy(y0Clamped)); ctx.lineTo(toSx(xMax), toSy(y0Clamped)); ctx.stroke();
    ctx.setLineDash([]);

    ctx.font = '11px Georgia'; ctx.fillStyle = ACCENT; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
    ctx.fillText('y\u2080 = ' + y0Clamped.toFixed(4), toSx(xMax) - 4, toSy(y0Clamped) - 4);

    /* find intersections */
    const crossings = findIntersections(fn, a, b, y0Clamped, 2000);

    for (const cx of crossings) {
        const cy = fn(cx);
        const sx = toSx(cx), sy = toSy(cy);

        /* vertical dashed line from c to x-axis */
        ctx.setLineDash([3, 3]);
        ctx.strokeStyle = ACCENT_DIM; ctx.lineWidth = 1;
        const xAxisY = (yMin <= 0 && yMax >= 0) ? toSy(0) : H - margin.b;
        ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(sx, xAxisY); ctx.stroke();
        ctx.setLineDash([]);

        /* glowing dot at intersection */
        ctx.shadowColor = ACCENT; ctx.shadowBlur = 12;
        ctx.fillStyle = ACCENT;
        ctx.beginPath(); ctx.arc(sx, sy, 6, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        /* label c */
        ctx.font = '11px Georgia'; ctx.fillStyle = ACCENT;
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText('c = ' + cx.toFixed(4), sx, xAxisY + 4);
    }

    /* axis labels */
    ctx.font = '12px Georgia'; ctx.fillStyle = MUTED;
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    ctx.fillText('x', W / 2, H - 12);
    ctx.save(); ctx.translate(14, H / 2); ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
    ctx.fillText('f(x)', 0, 0); ctx.restore();

    /* function name */
    ctx.font = '13px Georgia'; ctx.fillStyle = '#e0e0e0';
    ctx.textAlign = 'right'; ctx.textBaseline = 'top';
    ctx.fillText('f(x) = ' + p.name, W - margin.r - 6, margin.t + 6);

    /* update info */
    const infoDiv = document.getElementById('ivtInfo');
    let infoHtml = '<span class="label">f(a) = f(' + a.toFixed(1) + ')</span><span class="value" style="color:' + GOLD + '">' + fa.toFixed(6) + '</span>';
    infoHtml += '<span class="label">f(b) = f(' + b.toFixed(1) + ')</span><span class="value" style="color:' + GREEN + '">' + fb.toFixed(6) + '</span>';
    infoHtml += '<span class="label">Target y\u2080</span><span class="value" style="color:' + ACCENT + '">' + y0Clamped.toFixed(6) + '</span>';
    if (crossings.length > 0) {
        for (let i = 0; i < crossings.length; i++) {
            const lbl = crossings.length > 1 ? 'c\u2080' + (i + 1) : 'c';
            infoHtml += '<span class="label">' + lbl + '</span><span class="value" style="color:' + ACCENT + '">' + crossings[i].toFixed(6) + '</span>';
        }
    }
    infoDiv.innerHTML = infoHtml;
}

/* animate y0 sweep */
document.getElementById('animateBtn').addEventListener('click', () => {
    if (ivtAnimating) { ivtAnimating = false; return; }
    ivtAnimating = true;
    document.getElementById('animateBtn').textContent = 'Stop';
    document.getElementById('animateBtn').classList.add('active');
    const slider = document.getElementById('y0Slider');
    let val = 0;
    let dir = 1;
    function tick() {
        if (!ivtAnimating) {
            document.getElementById('animateBtn').textContent = 'Animate';
            document.getElementById('animateBtn').classList.remove('active');
            return;
        }
        val += dir * 3;
        if (val >= 1000) { val = 1000; dir = -1; }
        if (val <= 0) { val = 0; dir = 1; }
        slider.value = val;
        updateY0Slider();
        drawIVT();
        ivtAnimId = requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
});

/* click on canvas to pick y0 */
ivtCvs.addEventListener('click', (e) => {
    if (ivtAnimating) return;
    const p = getIVTFn();
    const fa = p.fn(p.a), fb = p.fn(p.b);
    const yLo = Math.min(fa, fb), yHi = Math.max(fa, fb);
    const rect = ivtCvs.getBoundingClientRect();
    const cy = (e.clientY - rect.top) * (IH / rect.height);
    const margin = { l: 60, r: 20, t: 20, b: 40 };
    const ph = IH - margin.t - margin.b;

    /* compute y range for mapping */
    const pts = evalRange(p.fn, p.a, p.b, 500);
    let yMin = Infinity, yMax = -Infinity;
    for (const pt of pts) { if (pt.y < yMin) yMin = pt.y; if (pt.y > yMax) yMax = pt.y; }
    const yPad = (yMax - yMin) * 0.12 || 1;
    yMin -= yPad; yMax += yPad;

    const yClicked = yMax - (cy - margin.t) / ph * (yMax - yMin);
    const t = (yClicked - yLo) / (yHi - yLo + 1e-15);
    const clamped = Math.max(0, Math.min(1, t));
    document.getElementById('y0Slider').value = Math.round(clamped * 1000);
    updateY0Slider();
    drawIVT();
});

/* touch support for IVT canvas */
ivtCvs.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    const ev = { clientX: t.clientX, clientY: t.clientY };
    ivtCvs.dispatchEvent(new MouseEvent('click', ev));
}, { passive: false });


/* ====== SECTION 2: WHY CONTINUITY MATTERS ====== */
const discCvs = document.getElementById('discCanvas');
const discCtx = discCvs.getContext('2d');
const DW = discCvs.width, DH = discCvs.height;
let isContinuous = false;
let contTransition = 0; /* 0 = discontinuous, 1 = continuous */
let contAnimating = false;

function discFn(x, t) {
    /* discontinuous: f(x) = x for x < 1, f(x) = x + 1.5 for x >= 1 */
    /* continuous blend: smoothly interpolates at x=1 */
    if (x < 1 - 0.15 * t) return x;
    if (x > 1 + 0.15 * t) return x + 1.5 * (1 - t);
    /* smooth blend in transition region */
    const mid = 1;
    const halfW = 0.15 * t + 0.001;
    const s = (x - (mid - halfW)) / (2 * halfW);
    const lo = mid - halfW;
    const hi = mid + halfW;
    const fLo = lo;
    const fHi = hi + 1.5 * (1 - t);
    return fLo + (fHi - fLo) * (3 * s * s - 2 * s * s * s); /* smoothstep */
}

function drawDisc() {
    const ctx = discCtx;
    const W = DW, H = DH;
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);

    const margin = { l: 50, r: 20, t: 20, b: 35 };
    const pw = W - margin.l - margin.r;
    const ph = H - margin.t - margin.b;
    const xMin = -0.5, xMax = 3, yMin = -0.5, yMax = 4;

    function toSx(x) { return margin.l + (x - xMin) / (xMax - xMin) * pw; }
    function toSy(y) { return margin.t + (1 - (y - yMin) / (yMax - yMin)) * ph; }

    /* grid */
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
    for (let x = 0; x <= 3; x++) {
        ctx.beginPath(); ctx.moveTo(toSx(x), margin.t); ctx.lineTo(toSx(x), H - margin.b); ctx.stroke();
    }
    for (let y = 0; y <= 4; y++) {
        ctx.beginPath(); ctx.moveTo(margin.l, toSy(y)); ctx.lineTo(W - margin.r, toSy(y)); ctx.stroke();
    }

    /* axes */
    ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(margin.l, toSy(0)); ctx.lineTo(W - margin.r, toSy(0)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(toSx(0), margin.t); ctx.lineTo(toSx(0), H - margin.b); ctx.stroke();

    /* tick labels */
    ctx.font = '10px Georgia'; ctx.fillStyle = '#505068';
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for (let x = 0; x <= 3; x++) ctx.fillText(x, toSx(x), H - margin.b + 5);
    ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
    for (let y = 0; y <= 4; y++) ctx.fillText(y, margin.l - 6, toSy(y));

    const t = contTransition;

    /* y0 target line */
    const y0 = 1.5;
    ctx.setLineDash([5, 4]);
    ctx.strokeStyle = ACCENT; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(toSx(xMin), toSy(y0)); ctx.lineTo(toSx(xMax), toSy(y0)); ctx.stroke();
    ctx.setLineDash([]);
    ctx.font = '11px Georgia'; ctx.fillStyle = ACCENT; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
    ctx.fillText('y\u2080 = 1.5', toSx(xMax) - 4, toSy(y0) - 4);

    /* the curve */
    ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 2; ctx.lineCap = 'round';

    if (t < 0.01) {
        /* draw two separate segments with open/closed circles */
        ctx.beginPath();
        for (let i = 0; i <= 200; i++) {
            const x = -0.3 + i / 200 * 1.3;
            if (x > 1) break;
            const y = discFn(x, 0);
            if (i === 0) ctx.moveTo(toSx(x), toSy(y)); else ctx.lineTo(toSx(x), toSy(y));
        }
        ctx.stroke();

        ctx.beginPath();
        for (let i = 0; i <= 200; i++) {
            const x = 1 + i / 200 * 1.8;
            const y = discFn(x, 0);
            if (i === 0) ctx.moveTo(toSx(x), toSy(y)); else ctx.lineTo(toSx(x), toSy(y));
        }
        ctx.stroke();

        /* open circle at (1, 2.5) — the "jumped to" value */
        ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(toSx(1), toSy(2.5), 5, 0, Math.PI * 2); ctx.stroke();
        /* closed circle at (1, 1) — the "left limit" value */
        ctx.fillStyle = '#e0e0e0';
        ctx.beginPath(); ctx.arc(toSx(1), toSy(1), 5, 0, Math.PI * 2); ctx.fill();

        /* highlight the gap */
        ctx.strokeStyle = RED; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(toSx(1), toSy(y0), 10, 0, Math.PI * 2); ctx.stroke();

        /* annotation */
        ctx.font = '11px Georgia'; ctx.fillStyle = RED;
        ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
        ctx.fillText('IVT fails \u2014 the function', toSx(1) + 18, toSy(y0) - 8);
        ctx.fillText('jumps over y\u2080', toSx(1) + 18, toSy(y0) + 10);

        /* dashed vertical showing the gap */
        ctx.setLineDash([3, 3]); ctx.strokeStyle = 'rgba(239,68,68,0.3)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(toSx(1), toSy(1)); ctx.lineTo(toSx(1), toSy(2.5)); ctx.stroke();
        ctx.setLineDash([]);
    } else {
        /* draw blended curve */
        ctx.beginPath();
        const n = 400;
        for (let i = 0; i <= n; i++) {
            const x = -0.3 + i / n * 3.1;
            const y = discFn(x, t);
            if (i === 0) ctx.moveTo(toSx(x), toSy(y)); else ctx.lineTo(toSx(x), toSy(y));
        }
        ctx.stroke();

        /* find intersection with y0 */
        if (t > 0.5) {
            for (let i = 1; i <= 2000; i++) {
                const x0 = -0.3 + (i - 1) / 2000 * 3.1;
                const x1 = -0.3 + i / 2000 * 3.1;
                const y0v = discFn(x0, t) - y0;
                const y1v = discFn(x1, t) - y0;
                if (y0v * y1v <= 0) {
                    const frac = Math.abs(y0v) / (Math.abs(y0v) + Math.abs(y1v) + 1e-15);
                    const cx = x0 + frac * (x1 - x0);
                    const sx = toSx(cx), sy = toSy(y0);
                    ctx.shadowColor = ACCENT; ctx.shadowBlur = 12;
                    ctx.fillStyle = ACCENT;
                    ctx.beginPath(); ctx.arc(sx, sy, 5, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.font = '11px Georgia'; ctx.fillStyle = ACCENT;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                    ctx.fillText('c = ' + cx.toFixed(3), sx, sy + 10);
                    break;
                }
            }
        }
    }

    /* f(a) and f(b) labels */
    const aVal = discFn(-0.3, t), bVal = discFn(2.8, t);
    ctx.font = '10px Georgia'; ctx.fillStyle = GOLD;
    ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
    ctx.fillText('f(a)=' + aVal.toFixed(1), toSx(-0.3) + 4, toSy(aVal) - 4);
    ctx.fillStyle = GREEN; ctx.textBaseline = 'top';
    ctx.fillText('f(b)=' + bVal.toFixed(1), toSx(2.8) - 40, toSy(bVal) + 4);
}

document.getElementById('contToggle').addEventListener('click', () => {
    isContinuous = !isContinuous;
    const btn = document.getElementById('contToggle');
    btn.textContent = isContinuous ? 'Make Discontinuous' : 'Make Continuous';
    btn.classList.toggle('active', isContinuous);
    const label = document.getElementById('contLabel');
    label.textContent = isContinuous
        ? 'The gap is filled \u2014 the IVT now guarantees an intersection'
        : 'The function has a jump discontinuity at x = 1';

    if (contAnimating) return;
    contAnimating = true;
    const target = isContinuous ? 1 : 0;
    const start = contTransition;
    const t0 = performance.now();
    const dur = 600;
    function animStep(now) {
        let frac = (now - t0) / dur;
        if (frac >= 1) { frac = 1; contAnimating = false; }
        contTransition = start + (target - start) * (frac < 0.5 ? 2 * frac * frac : 1 - Math.pow(-2 * frac + 2, 2) / 2);
        drawDisc();
        if (frac < 1) requestAnimationFrame(animStep);
    }
    requestAnimationFrame(animStep);
});


/* ====== SECTION 3 & 4: ROOT FINDING ====== */
const rfCvs = document.getElementById('rootCanvas');
const rfCtx = rfCvs.getContext('2d');
const RW = rfCvs.width, RH = rfCvs.height;

const rfFunctions = [
    {
        label: 'x\u00B2 - 2',
        fn: x => x * x - 2,
        dfn: x => 2 * x,
        a: 1, b: 2,
        root: Math.SQRT2,
        name: 'x\u00B2 - 2'
    },
    {
        label: 'x\u00B3 - x - 1',
        fn: x => x * x * x - x - 1,
        dfn: x => 3 * x * x - 1,
        a: 1, b: 2,
        root: 1.3247179572,
        name: 'x\u00B3 - x - 1'
    },
    {
        label: 'sin(x) - 0.5',
        fn: x => Math.sin(x) - 0.5,
        dfn: x => Math.cos(x),
        a: 0, b: 2,
        root: Math.PI / 6,
        name: 'sin(x) - 0.5'
    }
];

let rfIdx = 0;
let rfMethod = 'bisection'; /* 'bisection' or 'newton' */
let bisectState = null;
let newtonState = null;
let rfAutoInterval = null;

function getRF() { return rfFunctions[rfIdx]; }

function initBisection() {
    const p = getRF();
    bisectState = {
        a: p.a, b: p.b, step: 0,
        history: [{ a: p.a, b: p.b, m: (p.a + p.b) / 2, fm: p.fn((p.a + p.b) / 2) }]
    };
}

function initNewton() {
    const p = getRF();
    const x0 = (p.a + p.b) / 2;
    newtonState = {
        x: x0, step: 0, prevX: null,
        history: [{ x: x0, fx: p.fn(x0), err: Math.abs(x0 - p.root) }]
    };
}

function stepBisection() {
    const p = getRF();
    const s = bisectState;
    if (Math.abs(s.b - s.a) < 1e-12) return;
    const m = (s.a + s.b) / 2;
    const fm = p.fn(m);
    const fa = p.fn(s.a);
    if (fa * fm <= 0) { s.b = m; }
    else { s.a = m; }
    s.step++;
    s.history.push({ a: s.a, b: s.b, m: (s.a + s.b) / 2, fm: p.fn((s.a + s.b) / 2) });
}

function stepNewton() {
    const p = getRF();
    const s = newtonState;
    const fx = p.fn(s.x);
    const dfx = p.dfn(s.x);
    if (Math.abs(dfx) < 1e-15) return;
    s.prevX = s.x;
    s.x = s.x - fx / dfx;
    s.step++;
    s.history.push({ x: s.x, fx: p.fn(s.x), err: Math.abs(s.x - p.root) });
}

function drawRootFinding() {
    const p = getRF();
    const fn = p.fn;
    const ctx = rfCtx;
    const W = RW, H = RH;
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);

    const margin = { l: 60, r: 20, t: 20, b: 40 };
    const pw = W - margin.l - margin.r;
    const ph = H - margin.t - margin.b;

    /* compute plot bounds */
    const xPad = (p.b - p.a) * 0.3;
    const xMin = p.a - xPad, xMax = p.b + xPad;
    const pts = evalRange(fn, xMin, xMax, 500);
    let yMinV = Infinity, yMaxV = -Infinity;
    for (const pt of pts) { if (pt.y < yMinV) yMinV = pt.y; if (pt.y > yMaxV) yMaxV = pt.y; }
    const yPad = (yMaxV - yMinV) * 0.15 || 1;
    const yMin = yMinV - yPad, yMax = yMaxV + yPad;

    function toSx(x) { return margin.l + (x - xMin) / (xMax - xMin) * pw; }
    function toSy(y) { return margin.t + (1 - (y - yMin) / (yMax - yMin)) * ph; }

    /* grid */
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
    const xStep = niceStep(xMax - xMin, 8);
    const yStep = niceStep(yMax - yMin, 6);
    for (let x = Math.ceil(xMin / xStep) * xStep; x <= xMax; x += xStep) {
        ctx.beginPath(); ctx.moveTo(toSx(x), margin.t); ctx.lineTo(toSx(x), H - margin.b); ctx.stroke();
    }
    for (let y = Math.ceil(yMin / yStep) * yStep; y <= yMax; y += yStep) {
        ctx.beginPath(); ctx.moveTo(margin.l, toSy(y)); ctx.lineTo(W - margin.r, toSy(y)); ctx.stroke();
    }

    /* x-axis */
    if (yMin <= 0 && yMax >= 0) {
        ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(margin.l, toSy(0)); ctx.lineTo(W - margin.r, toSy(0)); ctx.stroke();
    }

    /* tick labels */
    ctx.font = '10px Georgia'; ctx.fillStyle = '#505068';
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for (let x = Math.ceil(xMin / xStep) * xStep; x <= xMax; x += xStep) {
        ctx.fillText(formatNum(x), toSx(x), H - margin.b + 6);
    }
    ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
    for (let y = Math.ceil(yMin / yStep) * yStep; y <= yMax; y += yStep) {
        ctx.fillText(formatNum(y), margin.l - 8, toSy(y));
    }

    /* the curve */
    ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 2; ctx.lineCap = 'round';
    ctx.beginPath();
    for (let i = 0; i < pts.length; i++) {
        const sx = toSx(pts[i].x), sy = toSy(pts[i].y);
        if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.stroke();

    /* function label */
    ctx.font = '13px Georgia'; ctx.fillStyle = '#e0e0e0';
    ctx.textAlign = 'right'; ctx.textBaseline = 'top';
    ctx.fillText('f(x) = ' + p.name, W - margin.r - 6, margin.t + 6);

    if (rfMethod === 'bisection' && bisectState) {
        const s = bisectState;
        const sa = toSx(s.a), sb = toSx(s.b);
        const y0s = toSy(0);

        /* interval band */
        ctx.fillStyle = 'rgba(129,140,248,0.08)';
        ctx.fillRect(sa, margin.t, sb - sa, ph);

        /* vertical lines at a, b */
        ctx.setLineDash([4, 3]);
        ctx.strokeStyle = fn(s.a) < 0 ? RED : GREEN; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(sa, margin.t); ctx.lineTo(sa, H - margin.b); ctx.stroke();
        ctx.strokeStyle = fn(s.b) < 0 ? RED : GREEN;
        ctx.beginPath(); ctx.moveTo(sb, margin.t); ctx.lineTo(sb, H - margin.b); ctx.stroke();
        ctx.setLineDash([]);

        /* midpoint */
        const m = (s.a + s.b) / 2;
        const sm = toSx(m);
        const fm = fn(m);
        ctx.strokeStyle = ACCENT; ctx.lineWidth = 1.5;
        ctx.setLineDash([2, 2]);
        ctx.beginPath(); ctx.moveTo(sm, margin.t); ctx.lineTo(sm, H - margin.b); ctx.stroke();
        ctx.setLineDash([]);

        /* point at midpoint on curve */
        ctx.shadowColor = ACCENT; ctx.shadowBlur = 10;
        ctx.fillStyle = ACCENT;
        ctx.beginPath(); ctx.arc(sm, toSy(fm), 5, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        /* points at a, b on curve */
        ctx.fillStyle = fn(s.a) < 0 ? RED : GREEN;
        ctx.beginPath(); ctx.arc(sa, toSy(fn(s.a)), 4, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = fn(s.b) < 0 ? RED : GREEN;
        ctx.beginPath(); ctx.arc(sb, toSy(fn(s.b)), 4, 0, Math.PI * 2); ctx.fill();

        /* labels */
        ctx.font = '10px Georgia';
        ctx.fillStyle = MUTED; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText('a', sa, H - margin.b + 5);
        ctx.fillText('b', sb, H - margin.b + 5);
        ctx.fillStyle = ACCENT;
        ctx.fillText('m', sm, H - margin.b + 5);

        /* info panel */
        const info = document.getElementById('rfInfo');
        info.innerHTML =
            '<span class="label">Step</span><span class="value">' + s.step + '</span>' +
            '<span class="label">Interval [a, b]</span><span class="value">[' + s.a.toFixed(10) + ', ' + s.b.toFixed(10) + ']</span>' +
            '<span class="label">Width</span><span class="value">' + (s.b - s.a).toExponential(4) + '</span>' +
            '<span class="label">Midpoint m</span><span class="value" style="color:' + ACCENT + '">' + m.toFixed(10) + '</span>' +
            '<span class="label">f(m)</span><span class="value">' + fm.toExponential(6) + '</span>' +
            '<span class="label">|f(m)|</span><span class="value">' + Math.abs(fm).toExponential(4) + '</span>' +
            '<span class="label">Convergence</span><span class="value" style="color:' + MUTED + '">width = ' + (p.b - p.a).toFixed(1) + '/2^' + s.step + ' = ' + ((p.b - p.a) / Math.pow(2, s.step)).toExponential(4) + '</span>';
    }

    if (rfMethod === 'newton' && newtonState) {
        const s = newtonState;
        const x = s.x;
        const fx = fn(x);
        const dfx = p.dfn(x);
        const sx = toSx(x), sy = toSy(fx);

        /* tangent line */
        if (Math.abs(dfx) > 1e-15) {
            const xInt = x - fx / dfx; /* x-intercept of tangent */
            /* draw tangent from edge to edge, clipped to plot */
            const tX1 = xMin, tX2 = xMax;
            const tY1 = fx + dfx * (tX1 - x);
            const tY2 = fx + dfx * (tX2 - x);
            ctx.strokeStyle = 'rgba(129,140,248,0.5)'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(toSx(tX1), toSy(tY1)); ctx.lineTo(toSx(tX2), toSy(tY2)); ctx.stroke();

            /* x-intercept marker */
            if (xInt >= xMin && xInt <= xMax) {
                ctx.fillStyle = ACCENT;
                ctx.beginPath(); ctx.arc(toSx(xInt), toSy(0), 4, 0, Math.PI * 2); ctx.fill();
            }

            /* arrow from current point down to x-axis */
            ctx.setLineDash([3, 3]); ctx.strokeStyle = ACCENT_DIM; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(sx, toSy(0)); ctx.stroke();
            ctx.setLineDash([]);
        }

        /* current point on curve */
        ctx.shadowColor = ACCENT; ctx.shadowBlur = 12;
        ctx.fillStyle = ACCENT;
        ctx.beginPath(); ctx.arc(sx, sy, 6, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        /* previous points */
        for (let i = 0; i < s.history.length - 1; i++) {
            const h = s.history[i];
            const hsx = toSx(h.x), hsy = toSy(fn(h.x));
            ctx.fillStyle = 'rgba(129,140,248,0.3)';
            ctx.beginPath(); ctx.arc(hsx, hsy, 3, 0, Math.PI * 2); ctx.fill();
        }

        /* label */
        ctx.font = '11px Georgia'; ctx.fillStyle = ACCENT;
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText('x\u2099 = ' + x.toFixed(6), sx, toSy(0) + 6);

        /* info */
        const info = document.getElementById('rfInfo');
        info.innerHTML =
            '<span class="label">Step</span><span class="value">' + s.step + '</span>' +
            '<span class="label">Current x</span><span class="value" style="color:' + ACCENT + '">' + x.toFixed(10) + '</span>' +
            '<span class="label">f(x)</span><span class="value">' + fx.toExponential(6) + '</span>' +
            '<span class="label">f\'(x)</span><span class="value">' + dfx.toFixed(6) + '</span>' +
            '<span class="label">Error |x - root|</span><span class="value">' + Math.abs(x - p.root).toExponential(6) + '</span>' +
            '<span class="label">True root</span><span class="value" style="color:' + MUTED + '">' + p.root.toFixed(10) + '</span>';
    }

    /* history table */
    drawHistory();
    drawConvergence();
}

function drawHistory() {
    const div = document.getElementById('rfHistory');
    let html = '<table class="convergence-table">';
    if (rfMethod === 'bisection' && bisectState) {
        html += '<tr><th>Step</th><th>a</th><th>b</th><th>m</th><th>f(m)</th><th>Width</th></tr>';
        const h = bisectState.history;
        const maxShow = Math.min(h.length, 20);
        const startIdx = Math.max(0, h.length - maxShow);
        for (let i = startIdx; i < h.length; i++) {
            const e = h[i];
            const signColor = e.fm < 0 ? RED : GREEN;
            html += '<tr><td>' + i + '</td><td>' + e.a.toFixed(8) + '</td><td>' + e.b.toFixed(8) + '</td><td>' + e.m.toFixed(8) + '</td><td style="color:' + signColor + '">' + e.fm.toExponential(4) + '</td><td>' + (e.b - e.a).toExponential(3) + '</td></tr>';
        }
    } else if (rfMethod === 'newton' && newtonState) {
        html += '<tr><th>Step</th><th>x</th><th>f(x)</th><th>Error</th></tr>';
        const h = newtonState.history;
        for (let i = 0; i < h.length; i++) {
            const e = h[i];
            html += '<tr><td>' + i + '</td><td>' + e.x.toFixed(10) + '</td><td>' + e.fx.toExponential(4) + '</td><td>' + e.err.toExponential(4) + '</td></tr>';
        }
    }
    html += '</table>';
    div.innerHTML = html;
}

/* convergence comparison canvas */
function drawConvergence() {
    const cvs = document.getElementById('convCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);

    /* we need both bisection and newton data for the current function */
    const p = getRF();

    /* run bisection from scratch to get convergence data */
    const bisErrors = [];
    {
        let a = p.a, b = p.b;
        for (let i = 0; i < 25; i++) {
            const m = (a + b) / 2;
            bisErrors.push(Math.abs(m - p.root));
            if (p.fn(a) * p.fn(m) <= 0) b = m; else a = m;
        }
    }

    /* run newton from scratch */
    const newErrors = [];
    {
        let x = (p.a + p.b) / 2;
        for (let i = 0; i < 10; i++) {
            newErrors.push(Math.abs(x - p.root));
            const fx = p.fn(x), dfx = p.dfn(x);
            if (Math.abs(dfx) < 1e-15) break;
            x = x - fx / dfx;
            if (Math.abs(x - p.root) < 1e-16) { newErrors.push(1e-16); break; }
        }
    }

    const margin = { l: 70, r: 30, t: 20, b: 35 };
    const pw = W - margin.l - margin.r;
    const ph = H - margin.t - margin.b;

    const maxSteps = Math.max(bisErrors.length, newErrors.length, 5);
    const minErr = 1e-16, maxErr = Math.max(bisErrors[0] || 1, newErrors[0] || 1, 1);

    function toSx(step) { return margin.l + step / (maxSteps - 1) * pw; }
    function toSy(err) {
        if (err < minErr) err = minErr;
        const logMin = Math.log10(minErr);
        const logMax = Math.log10(maxErr) + 0.5;
        return margin.t + (1 - (Math.log10(err) - logMin) / (logMax - logMin)) * ph;
    }

    /* grid */
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
    for (let s = 0; s < maxSteps; s++) {
        ctx.beginPath(); ctx.moveTo(toSx(s), margin.t); ctx.lineTo(toSx(s), H - margin.b); ctx.stroke();
    }
    for (let e = -16; e <= 0; e += 2) {
        const sy = toSy(Math.pow(10, e));
        ctx.beginPath(); ctx.moveTo(margin.l, sy); ctx.lineTo(W - margin.r, sy); ctx.stroke();
    }

    /* axes */
    ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(margin.l, H - margin.b); ctx.lineTo(W - margin.r, H - margin.b); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(margin.l, margin.t); ctx.lineTo(margin.l, H - margin.b); ctx.stroke();

    /* tick labels */
    ctx.font = '10px Georgia'; ctx.fillStyle = '#505068';
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for (let s = 0; s < maxSteps; s += 2) {
        ctx.fillText(s, toSx(s), H - margin.b + 5);
    }
    ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
    for (let e = -16; e <= 0; e += 4) {
        ctx.fillText('10^' + e, margin.l - 6, toSy(Math.pow(10, e)));
    }

    /* axis labels */
    ctx.font = '11px Georgia'; ctx.fillStyle = MUTED;
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    ctx.fillText('Step', W / 2, H - 10);
    ctx.save(); ctx.translate(14, H / 2); ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
    ctx.fillText('Error |x - root|', 0, 0); ctx.restore();

    /* bisection line */
    ctx.strokeStyle = GOLD; ctx.lineWidth = 2; ctx.lineCap = 'round';
    ctx.beginPath();
    for (let i = 0; i < bisErrors.length; i++) {
        const sx = toSx(i), sy = toSy(bisErrors[i]);
        if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.stroke();
    for (let i = 0; i < bisErrors.length; i++) {
        ctx.fillStyle = GOLD;
        ctx.beginPath(); ctx.arc(toSx(i), toSy(bisErrors[i]), 2.5, 0, Math.PI * 2); ctx.fill();
    }

    /* newton line */
    ctx.strokeStyle = ACCENT; ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < newErrors.length; i++) {
        const sx = toSx(i), sy = toSy(newErrors[i]);
        if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.stroke();
    for (let i = 0; i < newErrors.length; i++) {
        ctx.fillStyle = ACCENT;
        ctx.beginPath(); ctx.arc(toSx(i), toSy(newErrors[i]), 3, 0, Math.PI * 2); ctx.fill();
    }

    /* legend */
    const lx = W - margin.r - 150, ly = margin.t + 10;
    ctx.fillStyle = GOLD; ctx.fillRect(lx, ly, 14, 3);
    ctx.font = '11px Georgia'; ctx.fillStyle = GOLD; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
    ctx.fillText('Bisection (linear)', lx + 20, ly + 2);
    ctx.fillStyle = ACCENT; ctx.fillRect(lx, ly + 20, 14, 3);
    ctx.fillStyle = ACCENT;
    ctx.fillText('Newton (quadratic)', lx + 20, ly + 22);

    /* highlight current step markers */
    if (rfMethod === 'bisection' && bisectState && bisectState.step < bisErrors.length) {
        const i = bisectState.step;
        ctx.strokeStyle = GOLD; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(toSx(i), toSy(bisErrors[i]), 6, 0, Math.PI * 2); ctx.stroke();
    }
    if (rfMethod === 'newton' && newtonState && newtonState.step < newErrors.length) {
        const i = newtonState.step;
        ctx.strokeStyle = ACCENT; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(toSx(i), toSy(newErrors[i]), 6, 0, Math.PI * 2); ctx.stroke();
    }
}

/* method toggle buttons */
function renderMethodBtns() {
    const c = document.getElementById('methodBtns');
    c.innerHTML = ['bisection', 'newton'].map(m =>
        '<button class="btn' + (m === rfMethod ? ' active' : '') + '" data-m="' + m + '">' +
        (m === 'bisection' ? 'Bisection Method' : 'Newton\'s Method') + '</button>'
    ).join('');
    c.querySelectorAll('.btn').forEach(b => b.addEventListener('click', () => {
        rfMethod = b.dataset.m;
        resetRF();
        renderMethodBtns();
        drawRootFinding();
    }));
}

function resetRF() {
    if (rfAutoInterval) { clearInterval(rfAutoInterval); rfAutoInterval = null; }
    document.getElementById('autoBtn').classList.remove('active');
    document.getElementById('autoBtn').textContent = 'Auto';
    initBisection();
    initNewton();
}

/* preset buttons */
document.getElementById('rfPreset1').addEventListener('click', () => { rfIdx = 0; resetRF(); drawRootFinding(); });
document.getElementById('rfPreset2').addEventListener('click', () => { rfIdx = 1; resetRF(); drawRootFinding(); });
document.getElementById('rfPreset3').addEventListener('click', () => { rfIdx = 2; resetRF(); drawRootFinding(); });

document.getElementById('stepBtn').addEventListener('click', () => {
    if (rfMethod === 'bisection') stepBisection();
    else stepNewton();
    drawRootFinding();
});

document.getElementById('autoBtn').addEventListener('click', () => {
    if (rfAutoInterval) {
        clearInterval(rfAutoInterval);
        rfAutoInterval = null;
        document.getElementById('autoBtn').classList.remove('active');
        document.getElementById('autoBtn').textContent = 'Auto';
        return;
    }
    document.getElementById('autoBtn').classList.add('active');
    document.getElementById('autoBtn').textContent = 'Stop';
    rfAutoInterval = setInterval(() => {
        if (rfMethod === 'bisection') {
            if (bisectState && Math.abs(bisectState.b - bisectState.a) < 1e-12) {
                clearInterval(rfAutoInterval); rfAutoInterval = null;
                document.getElementById('autoBtn').classList.remove('active');
                document.getElementById('autoBtn').textContent = 'Auto';
                return;
            }
            stepBisection();
        } else {
            if (newtonState && newtonState.step >= 20) {
                clearInterval(rfAutoInterval); rfAutoInterval = null;
                document.getElementById('autoBtn').classList.remove('active');
                document.getElementById('autoBtn').textContent = 'Auto';
                return;
            }
            if (newtonState && Math.abs(getRF().fn(newtonState.x)) < 1e-15) {
                clearInterval(rfAutoInterval); rfAutoInterval = null;
                document.getElementById('autoBtn').classList.remove('active');
                document.getElementById('autoBtn').textContent = 'Auto';
                return;
            }
            stepNewton();
        }
        drawRootFinding();
    }, 500);
});

document.getElementById('resetBtn').addEventListener('click', () => {
    resetRF();
    drawRootFinding();
});


/* ====== SECTION 5: APPLICATIONS ====== */
function drawTempCanvas() {
    const cvs = document.getElementById('tempCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);

    const margin = { l: 50, r: 20, t: 15, b: 30 };
    const pw = W - margin.l - margin.r;
    const ph = H - margin.t - margin.b;

    /* time axis: 0 (dawn=6am) to 6 (noon=12pm) */
    const hours = ['6am', '7am', '8am', '9am', '10am', '11am', '12pm'];
    function toSx(t) { return margin.l + t / 6 * pw; }
    function toSy(temp) { return margin.t + (1 - (temp - 2) / 26) * ph; }

    /* grid */
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
    for (let t = 0; t <= 6; t++) {
        ctx.beginPath(); ctx.moveTo(toSx(t), margin.t); ctx.lineTo(toSx(t), H - margin.b); ctx.stroke();
    }
    for (let temp = 5; temp <= 25; temp += 5) {
        ctx.beginPath(); ctx.moveTo(margin.l, toSy(temp)); ctx.lineTo(W - margin.r, toSy(temp)); ctx.stroke();
    }

    /* axes */
    ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(margin.l, H - margin.b); ctx.lineTo(W - margin.r, H - margin.b); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(margin.l, margin.t); ctx.lineTo(margin.l, H - margin.b); ctx.stroke();

    /* tick labels */
    ctx.font = '9px Georgia'; ctx.fillStyle = '#505068';
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for (let t = 0; t <= 6; t++) ctx.fillText(hours[t], toSx(t), H - margin.b + 5);
    ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
    for (let temp = 5; temp <= 25; temp += 5) ctx.fillText(temp + '\u00B0C', margin.l - 5, toSy(temp));

    /* temperature curve: smooth from 5 to 25 */
    ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 2; ctx.lineCap = 'round';
    ctx.beginPath();
    for (let i = 0; i <= 200; i++) {
        const t = i / 200 * 6;
        const temp = 5 + 20 * (1 - Math.cos(t / 6 * Math.PI)) / 2 + 2 * Math.sin(t / 6 * Math.PI * 2) * Math.exp(-t / 4);
        if (i === 0) ctx.moveTo(toSx(t), toSy(temp)); else ctx.lineTo(toSx(t), toSy(temp));
    }
    ctx.stroke();

    /* 15 degree line */
    ctx.setLineDash([5, 4]);
    ctx.strokeStyle = ACCENT; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(margin.l, toSy(15)); ctx.lineTo(W - margin.r, toSy(15)); ctx.stroke();
    ctx.setLineDash([]);

    ctx.font = '10px Georgia'; ctx.fillStyle = ACCENT;
    ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
    ctx.fillText('15\u00B0C', W - margin.r - 4, toSy(15) - 4);

    /* find crossing */
    for (let i = 1; i <= 200; i++) {
        const t0 = (i - 1) / 200 * 6;
        const t1 = i / 200 * 6;
        const temp0 = 5 + 20 * (1 - Math.cos(t0 / 6 * Math.PI)) / 2 + 2 * Math.sin(t0 / 6 * Math.PI * 2) * Math.exp(-t0 / 4);
        const temp1 = 5 + 20 * (1 - Math.cos(t1 / 6 * Math.PI)) / 2 + 2 * Math.sin(t1 / 6 * Math.PI * 2) * Math.exp(-t1 / 4);
        if ((temp0 - 15) * (temp1 - 15) <= 0) {
            const frac = Math.abs(temp0 - 15) / (Math.abs(temp0 - 15) + Math.abs(temp1 - 15) + 1e-15);
            const tc = t0 + frac * (t1 - t0);
            ctx.shadowColor = ACCENT; ctx.shadowBlur = 10;
            ctx.fillStyle = ACCENT;
            ctx.beginPath(); ctx.arc(toSx(tc), toSy(15), 5, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            /* time label */
            const hr = Math.floor(tc) + 6;
            const mn = Math.round((tc - Math.floor(tc)) * 60);
            ctx.font = '10px Georgia'; ctx.fillStyle = ACCENT;
            ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            ctx.fillText(hr + ':' + (mn < 10 ? '0' : '') + mn, toSx(tc), toSy(15) + 8);
            break;
        }
    }

    /* endpoints */
    const startTemp = 5 + 20 * (1 - Math.cos(0)) / 2;
    const endTemp = 5 + 20 * (1 - Math.cos(Math.PI)) / 2;
    ctx.fillStyle = GOLD;
    ctx.beginPath(); ctx.arc(toSx(0), toSy(startTemp), 4, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = GREEN;
    ctx.beginPath(); ctx.arc(toSx(6), toSy(endTemp), 4, 0, Math.PI * 2); ctx.fill();
}

function drawSqrt2Canvas() {
    const cvs = document.getElementById('sqrt2Canvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = BG; ctx.fillRect(0, 0, W, H);

    const margin = { l: 50, r: 20, t: 15, b: 30 };
    const pw = W - margin.l - margin.r;
    const ph = H - margin.t - margin.b;
    const xMin = 0.5, xMax = 2.5, yMin = -1.8, yMax = 4.5;

    function toSx(x) { return margin.l + (x - xMin) / (xMax - xMin) * pw; }
    function toSy(y) { return margin.t + (1 - (y - yMin) / (yMax - yMin)) * ph; }

    /* grid */
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 1;
    for (let x = 1; x <= 2; x++) {
        ctx.beginPath(); ctx.moveTo(toSx(x), margin.t); ctx.lineTo(toSx(x), H - margin.b); ctx.stroke();
    }
    for (let y = -1; y <= 4; y++) {
        ctx.beginPath(); ctx.moveTo(margin.l, toSy(y)); ctx.lineTo(W - margin.r, toSy(y)); ctx.stroke();
    }

    /* x-axis */
    ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(margin.l, toSy(0)); ctx.lineTo(W - margin.r, toSy(0)); ctx.stroke();

    /* tick labels */
    ctx.font = '10px Georgia'; ctx.fillStyle = '#505068';
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for (let x = 1; x <= 2; x++) ctx.fillText(x, toSx(x), H - margin.b + 5);
    ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
    for (let y = -1; y <= 4; y++) ctx.fillText(y, margin.l - 6, toSy(y));

    /* curve f(x) = x^2 - 2 */
    ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 2; ctx.lineCap = 'round';
    ctx.beginPath();
    for (let i = 0; i <= 200; i++) {
        const x = xMin + i / 200 * (xMax - xMin);
        const y = x * x - 2;
        if (i === 0) ctx.moveTo(toSx(x), toSy(y)); else ctx.lineTo(toSx(x), toSy(y));
    }
    ctx.stroke();

    /* function label */
    ctx.font = '11px Georgia'; ctx.fillStyle = '#e0e0e0';
    ctx.textAlign = 'right'; ctx.textBaseline = 'top';
    ctx.fillText('f(x) = x\u00B2 - 2', W - margin.r - 6, margin.t + 4);

    /* points at f(1) and f(2) */
    ctx.fillStyle = RED;
    ctx.beginPath(); ctx.arc(toSx(1), toSy(-1), 5, 0, Math.PI * 2); ctx.fill();
    ctx.font = '10px Georgia'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
    ctx.fillText('f(1) = -1 < 0', toSx(1) + 8, toSy(-1));

    ctx.fillStyle = GREEN;
    ctx.beginPath(); ctx.arc(toSx(2), toSy(2), 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = GREEN;
    ctx.fillText('f(2) = 2 > 0', toSx(2) + 8, toSy(2));

    /* root at sqrt(2) */
    ctx.shadowColor = ACCENT; ctx.shadowBlur = 12;
    ctx.fillStyle = ACCENT;
    ctx.beginPath(); ctx.arc(toSx(Math.SQRT2), toSy(0), 6, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.font = '11px Georgia'; ctx.fillStyle = ACCENT;
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    ctx.fillText('\u221A2 \u2248 1.4142', toSx(Math.SQRT2), toSy(0) + 8);

    /* dashed vertical */
    ctx.setLineDash([3, 3]); ctx.strokeStyle = ACCENT_DIM; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(toSx(Math.SQRT2), toSy(0)); ctx.lineTo(toSx(Math.SQRT2), H - margin.b); ctx.stroke();
    ctx.setLineDash([]);
}


/* ====== UTILITY ====== */
function niceStep(range, maxTicks) {
    const rough = range / maxTicks;
    const mag = Math.pow(10, Math.floor(Math.log10(rough)));
    const norm = rough / mag;
    let step;
    if (norm < 1.5) step = 1;
    else if (norm < 3) step = 2;
    else if (norm < 7) step = 5;
    else step = 10;
    return step * mag;
}

function formatNum(n) {
    if (Math.abs(n) < 1e-10) return '0';
    if (Math.abs(n - Math.round(n)) < 1e-10) return Math.round(n).toString();
    return n.toFixed(2);
}


/* ====== INIT ====== */
renderIVTPresets();
updateY0Slider();
drawIVT();
drawDisc();
renderMethodBtns();
initBisection();
initNewton();
drawRootFinding();
drawTempCanvas();
drawSqrt2Canvas();
</script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Built in collaboration with <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude Code</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
