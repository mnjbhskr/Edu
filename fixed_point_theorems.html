<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Point Theorems</title>
    <meta name="description" content="Visualise fixed point theorems: Banach and Brouwer. Interactive iteration showing convergence to fixed points.">
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "LearningResource",
      "name": "Fixed Point Theorems",
      "url": "https://mathsedu.org/fixed_point_theorems.html",
      "description": "Visualise fixed point theorems: Banach and Brouwer. Interactive iteration showing convergence to fixed points.",
      "educationalLevel": "Advanced",
      "teaches": "Fixed point theorems",
      "learningResourceType": "Interactive visualisation",
      "interactivityType": "active",
      "inLanguage": "en",
      "isAccessibleForFree": true,
      "creator": {
        "@type": "Person",
        "name": "Manoj Bhaskar"
      },
      "license": "https://creativecommons.org/licenses/by-nc-sa/4.0/",
      "isPartOf": {
        "@type": "Course",
        "name": "Analysis & Topology",
        "url": "https://mathsedu.org/"
      }
    }
    </script>
    <meta property="og:title" content="Fixed Point Theorems">
    <meta property="og:description" content="Visualise fixed point theorems: Banach and Brouwer. Interactive iteration showing convergence to fixed points.">
    <meta property="og:url" content="https://mathsedu.org/fixed_point_theorems.html">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="A Visual Discovery of Mathematics">
    <meta property="og:locale" content="en_GB">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Fixed Point Theorems">
    <meta name="twitter:description" content="Visualise fixed point theorems: Banach and Brouwer. Interactive iteration showing convergence to fixed points.">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a1a;color:#e0e0e0;font-family:Georgia,'Times New Roman',serif;line-height:1.6}
        .container{max-width:960px;margin:0 auto;padding:24px 28px 48px}
        .back{color:#606078;text-decoration:none;font-size:0.85em}
        .back:hover{color:#818cf8}
        h1{font-size:1.8em;font-weight:400;color:#fff;margin:16px 0 4px}
        .subtitle{color:#808098;font-style:italic;margin-bottom:28px}
        h2{font-size:1.15em;font-weight:400;color:#fff;margin:28px 0 12px}
        canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:crosshair}
        .panel{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:18px 22px;margin-bottom:20px}
        .panel h3{font-weight:400;font-size:0.8em;color:#808098;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
        .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
        .btn{background:rgba(255,255,255,0.035);border:1px solid rgba(255,255,255,0.07);color:#b0b0c4;padding:5px 13px;border-radius:6px;cursor:pointer;font-family:Georgia,serif;font-size:0.92em;transition:all 0.2s}
        .btn:hover{background:rgba(255,255,255,0.07);color:#e0e0ef}
        .btn.active{background:rgba(129,140,248,0.13);border-color:rgba(129,140,248,0.4);color:#818cf8}
        .math-line{font-family:'Courier New',monospace;font-size:0.92em;color:#c0c0d8;margin:4px 0;line-height:1.8}
        .math-line .indigo{color:#818cf8}
        .math-line .muted{color:#808098}
        .math-line .green{color:#2ecc71}
        .math-line .gold{color:#fbbf24}
        .math-line .red{color:#f87171}
        .slider-row{display:flex;align-items:center;gap:14px;margin:10px 0}
        .slider-row input[type=range]{flex:1;max-width:260px;accent-color:#818cf8}
        .slider-label{color:#818cf8;font-family:'Courier New',monospace;font-size:1.05em;min-width:50px}
        .explain{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:20px 24px;margin-top:20px}
        .explain-name{color:#818cf8;font-size:1.1em;margin-bottom:6px}
        .explain-text{color:#a0a0b8;font-size:0.9em;line-height:1.75}
        .iter-values{font-family:'Courier New',monospace;font-size:0.82em;color:#a0a0b8;margin-top:8px;line-height:1.9;max-height:140px;overflow-y:auto}
        .app-grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
        .app-card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05);border-radius:8px;padding:16px 18px}
        .app-card h4{color:#818cf8;font-weight:400;font-size:0.95em;margin-bottom:6px}
        .app-card p{color:#a0a0b8;font-size:0.85em;line-height:1.6}
        .app-icon{font-size:1.6em;margin-bottom:6px;opacity:0.7}
        .stability-tag{display:inline-block;padding:2px 10px;border-radius:4px;font-family:'Courier New',monospace;font-size:0.82em;margin-left:8px}
        .stability-tag.stable{background:rgba(46,204,113,0.12);color:#2ecc71;border:1px solid rgba(46,204,113,0.25)}
        .stability-tag.unstable{background:rgba(248,113,113,0.12);color:#f87171;border:1px solid rgba(248,113,113,0.25)}
        .proof-panel{background:rgba(129,140,248,0.04);border:1px solid rgba(129,140,248,0.1);border-radius:8px;padding:14px 18px;margin-top:12px}
        .proof-panel h4{color:#818cf8;font-weight:400;font-size:0.85em;margin-bottom:8px;text-transform:uppercase;letter-spacing:0.5px}
        .proof-step{color:#a0a0b8;font-size:0.88em;margin:3px 0;font-family:'Courier New',monospace}
        @media(max-width:700px){.app-grid{grid-template-columns:1fr}canvas{width:100%!important;height:auto!important}}
    </style>
</head>
<body>
<div class="container">
    <a class="back" href="index.html">&larr; Back to Index</a>
    <h1>Fixed Point Theorems</h1>
    <p class="subtitle">Stir your coffee &mdash; one point must stay where it was</p>

    <!-- ═══════════════════════════════════════════════════════ -->
    <!-- SECTION 1: Brouwer 1D -->
    <!-- ═══════════════════════════════════════════════════════ -->
    <h2>1. Brouwer's Fixed Point Theorem &mdash; 1D</h2>
    <div class="panel">
        <h3>Function f : [0, 1] &rarr; [0, 1]</h3>
        <div class="btn-row" id="brouwer1dBtns"></div>
        <canvas id="brouwer1d" width="700" height="400"></canvas>
        <div id="brouwer1dInfo" class="math-line" style="margin-top:10px"></div>
        <div class="proof-panel">
            <h4>Proof via Intermediate Value Theorem</h4>
            <div class="proof-step">Define g(x) = f(x) - x</div>
            <div class="proof-step">g(0) = f(0) - 0 = f(0) &ge; 0 &ensp;<span class="muted">(since f(0) &isin; [0,1])</span></div>
            <div class="proof-step">g(1) = f(1) - 1 &le; 0 &ensp;<span class="muted">(since f(1) &isin; [0,1])</span></div>
            <div class="proof-step">By IVT, &exist; c &isin; [0,1] with g(c) = 0 &rArr; f(c) = c</div>
            <canvas id="gxCanvas" width="700" height="200" style="margin-top:10px;cursor:default"></canvas>
            <div class="math-line muted" style="font-size:0.82em;margin-top:4px">The g(x) = f(x) - x curve above: starts &ge; 0, ends &le; 0, must cross zero.</div>
        </div>
    </div>

    <!-- ═══════════════════════════════════════════════════════ -->
    <!-- SECTION 2: Cobweb / Iteration Diagram -->
    <!-- ═══════════════════════════════════════════════════════ -->
    <h2>2. Iteration &amp; Cobweb Diagram</h2>
    <div class="panel">
        <h3>Cobweb iteration: x<sub>n+1</sub> = f(x<sub>n</sub>)</h3>
        <div class="btn-row">
            <button class="btn" id="cobwebStep">Step</button>
            <button class="btn" id="cobwebAuto">Auto</button>
            <button class="btn" id="cobwebReset">Reset</button>
        </div>
        <div class="slider-row">
            <span class="math-line muted">x<sub>0</sub> =</span>
            <input type="range" id="x0Slider" min="0" max="100" value="20">
            <span class="slider-label" id="x0Label">0.20</span>
        </div>
        <canvas id="cobwebCanvas" width="700" height="400"></canvas>
        <div id="cobwebInfo" class="math-line" style="margin-top:8px"></div>
        <div id="cobwebValues" class="iter-values"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════ -->
    <!-- SECTION 3: Brouwer 2D -->
    <!-- ═══════════════════════════════════════════════════════ -->
    <h2>3. Brouwer's Fixed Point in 2D</h2>
    <div class="panel">
        <h3>Continuous mapping of the disk</h3>
        <div class="btn-row" id="brouwer2dBtns"></div>
        <canvas id="brouwer2d" width="500" height="500"></canvas>
        <div id="brouwer2dInfo" class="math-line" style="margin-top:10px"></div>
    </div>
    <div class="panel">
        <h3>&ldquo;Stir the Coffee&rdquo; Demo</h3>
        <div class="btn-row">
            <button class="btn" id="coffeeStir">Stir!</button>
            <button class="btn" id="coffeeReset">Reset</button>
        </div>
        <canvas id="coffeeCanvas" width="500" height="500" style="cursor:default"></canvas>
        <div class="math-line muted" style="margin-top:8px">No matter how you stir, one point stays put! The highlighted dot barely moves.</div>
    </div>

    <!-- ═══════════════════════════════════════════════════════ -->
    <!-- SECTION 4: Banach Contraction -->
    <!-- ═══════════════════════════════════════════════════════ -->
    <h2>4. Banach Contraction Mapping Theorem</h2>
    <div class="panel">
        <h3>Contraction: every starting point converges to the unique fixed point</h3>
        <div class="btn-row">
            <button class="btn" id="banachStep">Step All</button>
            <button class="btn" id="banachAuto">Auto</button>
            <button class="btn" id="banachReset">Reset</button>
        </div>
        <canvas id="banachCanvas" width="600" height="350"></canvas>
        <div id="banachInfo" class="math-line" style="margin-top:10px"></div>
        <div class="proof-panel" style="margin-top:14px">
            <h4>Brouwer vs Banach</h4>
            <div class="proof-step" style="color:#a0a0b8;font-family:Georgia,serif"><strong style="color:#818cf8">Brouwer</strong> says: "A fixed point exists." &ensp;(topological &mdash; non-constructive)</div>
            <div class="proof-step" style="color:#a0a0b8;font-family:Georgia,serif"><strong style="color:#818cf8">Banach</strong> says: "A unique fixed point exists, and here is how to find it." &ensp;(metric &mdash; constructive)</div>
        </div>
    </div>

    <!-- ═══════════════════════════════════════════════════════ -->
    <!-- SECTION 5: Applications -->
    <!-- ═══════════════════════════════════════════════════════ -->
    <h2>5. Applications</h2>
    <div class="app-grid">
        <div class="app-card">
            <div class="app-icon" style="color:#818cf8">&#9678;</div>
            <h4>GPS / Navigation</h4>
            <p>Finding your position from satellite data requires solving a system where the position estimate is updated by a function of distance measurements. The solution &mdash; your actual location &mdash; is the fixed point of this iterative refinement process.</p>
        </div>
        <div class="app-card">
            <div class="app-icon" style="color:#818cf8">&#9670;</div>
            <h4>Economics: Nash Equilibrium</h4>
            <p>In game theory, each player's optimal strategy depends on the others' strategies. A Nash equilibrium is a fixed point of the combined best-response mapping: no player can improve by changing strategy unilaterally. Nash used Brouwer's theorem to prove existence.</p>
        </div>
        <div class="app-card">
            <div class="app-icon" style="color:#818cf8">&#8734;</div>
            <h4>Differential Equations (Picard)</h4>
            <p>Picard's existence theorem for ODEs (dy/dx = f(x,y)) works by defining an integral operator T and showing it is a contraction on a function space. The fixed point of T is the solution to the ODE &mdash; a direct application of Banach's theorem.</p>
        </div>
        <div class="app-card">
            <div class="app-icon" style="color:#818cf8">&#9733;</div>
            <h4>Google PageRank</h4>
            <p>The PageRank vector r satisfies r = M &middot; r + (1-d)/n, where M encodes the link structure. This is a fixed point equation. Google's algorithm iterates this mapping until convergence &mdash; guaranteed by the contraction principle since the damping factor d &lt; 1.</p>
        </div>
    </div>

    <!-- ═══════════════════════════════════════════════════════ -->
    <!-- SECTION 6: What Have We Learnt? -->
    <!-- ═══════════════════════════════════════════════════════ -->
    <div class="explain" style="margin-top:28px">
        <div class="explain-name">What have we learnt?</div>
        <div class="explain-text">
            Fixed point theorems are existence results &mdash; they guarantee that certain equations have solutions, even when we cannot solve them explicitly. Brouwer's theorem is topological: any continuous function that maps a compact convex set to itself must have a fixed point. There is no escape from the disk. Banach's contraction principle is metric: if a function uniformly shrinks distances, it has a unique fixed point, and simple iteration finds it.
            <br><br>
            The coffee-stirring metaphor captures the topological intuition: no matter how you continuously deform a disk (or stir a cup), at least one point must end up exactly where it started. This simple-sounding result has profound consequences. It underpins numerical methods (Newton's method converges via contraction), game theory (Nash equilibria exist via Brouwer), differential equations (Picard's theorem uses Banach), and optimization (gradient descent finds fixed points of update maps).
            <br><br>
            The key conceptual distinction: Brouwer tells you a solution exists but gives no recipe to find it. Banach not only guarantees existence and uniqueness but also provides the algorithm &mdash; just iterate. This is the difference between a topological guarantee and a constructive method.
        </div>
    </div>
</div>

<script>
/* ════════════════════════════════════════════════════════════════
   FIXED POINT THEOREMS — Interactive Visualizations
   ════════════════════════════════════════════════════════════════ */

const INDIGO = '#818cf8';
const INDIGO_DIM = 'rgba(129,140,248,0.4)';
const INDIGO_GLOW = 'rgba(129,140,248,0.6)';
const BG = '#0a0a1a';

/* ── Shared Helpers ── */
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function lerp(a, b, t) { return a + (b - a) * t; }

/* ════════════════════════════════════════════════════════════════
   SECTION 1: Brouwer 1D
   ════════════════════════════════════════════════════════════════ */
(function() {
    const cvs = document.getElementById('brouwer1d');
    const ctx = cvs.getContext('2d');
    const gCvs = document.getElementById('gxCanvas');
    const gCtx = gCvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const gW = gCvs.width, gH = gCvs.height;

    /* Plot area within the canvas */
    const margin = { left: 60, right: 30, top: 30, bottom: 50 };
    const pw = W - margin.left - margin.right;
    const ph = H - margin.top - margin.bottom;

    /* g(x) canvas margins */
    const gm = { left: 60, right: 30, top: 20, bottom: 40 };
    const gpw = gW - gm.left - gm.right;
    const gph = gH - gm.top - gm.bottom;

    /* Preset functions mapping [0,1] -> [0,1] */
    const presets = [
        { label: 'cos(x)', fn: x => Math.cos(x), desc: 'f(x) = cos(x)' },
        { label: 'x\u00B2', fn: x => x * x, desc: 'f(x) = x\u00B2' },
        { label: '(x+1)/3', fn: x => (x + 1) / 3, desc: 'f(x) = (x+1)/3' },
        { label: 'sin(\u03C0x/2)', fn: x => Math.sin(Math.PI * x / 2), desc: 'f(x) = sin(\u03C0x/2)' },
        { label: 'Custom', fn: null, desc: 'Click canvas to set control points' }
    ];

    let activePreset = 0;
    let customPoints = [{ x: 0, y: 0.8 }, { x: 0.25, y: 0.6 }, { x: 0.5, y: 0.7 }, { x: 0.75, y: 0.3 }, { x: 1.0, y: 0.5 }];
    let dragIdx = -1;
    let glowPhase = 0;

    function getFunc() {
        if (activePreset < 4) return presets[activePreset].fn;
        return customSpline;
    }

    /* Cubic spline interpolation for custom points */
    function customSpline(x) {
        const pts = customPoints.sort((a, b) => a.x - b.x);
        if (x <= pts[0].x) return pts[0].y;
        if (x >= pts[pts.length - 1].x) return pts[pts.length - 1].y;
        /* Find segment */
        let i = 0;
        while (i < pts.length - 1 && pts[i + 1].x < x) i++;
        /* Catmull-Rom style */
        const p0 = pts[Math.max(0, i - 1)];
        const p1 = pts[i];
        const p2 = pts[Math.min(pts.length - 1, i + 1)];
        const p3 = pts[Math.min(pts.length - 1, i + 2)];
        const dx = p2.x - p1.x;
        if (dx < 1e-9) return p1.y;
        const t = (x - p1.x) / dx;
        const t2 = t * t, t3 = t2 * t;
        const v = 0.5 * ((2 * p1.y) +
            (-p0.y + p2.y) * t +
            (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
            (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);
        return clamp(v, 0, 1);
    }

    /* Find fixed points numerically */
    function findFixedPoints(f) {
        const fps = [];
        const N = 2000;
        for (let i = 0; i < N; i++) {
            const x1 = i / N, x2 = (i + 1) / N;
            const g1 = f(x1) - x1, g2 = f(x2) - x2;
            if (g1 * g2 <= 0) {
                /* Bisect */
                let lo = x1, hi = x2;
                for (let k = 0; k < 50; k++) {
                    const mid = (lo + hi) / 2;
                    if ((f(mid) - mid) * (f(lo) - lo) <= 0) hi = mid;
                    else lo = mid;
                }
                const fp = (lo + hi) / 2;
                if (fps.length === 0 || Math.abs(fp - fps[fps.length - 1]) > 0.001) {
                    fps.push(fp);
                }
            }
        }
        return fps;
    }

    /* Coordinate conversions */
    function toSx(x) { return margin.left + x * pw; }
    function toSy(y) { return margin.top + (1 - y) * ph; }
    function fromSx(sx) { return (sx - margin.left) / pw; }
    function fromSy(sy) { return 1 - (sy - margin.top) / ph; }

    function draw() {
        const f = getFunc();
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        /* Grid */
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
            const v = i / 10;
            ctx.beginPath(); ctx.moveTo(toSx(v), margin.top); ctx.lineTo(toSx(v), H - margin.bottom); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(margin.left, toSy(v)); ctx.lineTo(W - margin.right, toSy(v)); ctx.stroke();
        }

        /* Axes */
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(margin.left, H - margin.bottom); ctx.lineTo(W - margin.right, H - margin.bottom); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(margin.left, margin.top); ctx.lineTo(margin.left, H - margin.bottom); ctx.stroke();

        /* Tick labels */
        ctx.font = '11px Georgia';
        ctx.fillStyle = '#505068';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let i = 0; i <= 10; i += 2) {
            ctx.fillText((i / 10).toFixed(1), toSx(i / 10), H - margin.bottom + 6);
        }
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i <= 10; i += 2) {
            ctx.fillText((i / 10).toFixed(1), margin.left - 8, toSy(i / 10));
        }

        /* Axis labels */
        ctx.font = '13px Georgia';
        ctx.fillStyle = '#808098';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('x', margin.left + pw / 2, H - margin.bottom + 28);
        ctx.save();
        ctx.translate(16, margin.top + ph / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('y', 0, 0);
        ctx.restore();

        /* y = x diagonal (white, thin) */
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(toSx(0), toSy(0));
        ctx.lineTo(toSx(1), toSy(1));
        ctx.stroke();
        ctx.setLineDash([]);

        /* Label y = x */
        ctx.font = '11px Georgia';
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillText('y = x', toSx(0.88), toSy(0.9));

        /* f(x) curve */
        ctx.strokeStyle = INDIGO;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        const steps = 400;
        for (let i = 0; i <= steps; i++) {
            const x = i / steps;
            const y = clamp(f(x), 0, 1);
            const sx = toSx(x), sy = toSy(y);
            if (i === 0) ctx.moveTo(sx, sy);
            else ctx.lineTo(sx, sy);
        }
        ctx.stroke();

        /* Label f(x) */
        ctx.font = '12px Georgia';
        ctx.fillStyle = INDIGO;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        const labelX = 0.85;
        const labelY = clamp(f(labelX), 0, 1);
        ctx.fillText('f(x)', toSx(labelX) + 8, toSy(labelY) - 4);

        /* Fixed points with glow */
        const fps = findFixedPoints(f);
        glowPhase += 0.03;
        const glowAlpha = 0.5 + 0.3 * Math.sin(glowPhase);
        fps.forEach(fp => {
            const sx = toSx(fp), sy = toSy(fp);
            /* Glow */
            const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, 16);
            grad.addColorStop(0, 'rgba(129,140,248,' + glowAlpha * 0.5 + ')');
            grad.addColorStop(1, 'rgba(129,140,248,0)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(sx, sy, 16, 0, Math.PI * 2); ctx.fill();
            /* Dot */
            ctx.fillStyle = INDIGO;
            ctx.beginPath(); ctx.arc(sx, sy, 6, 0, Math.PI * 2); ctx.fill();
            /* Label */
            ctx.font = '11px Courier New';
            ctx.fillStyle = INDIGO;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            ctx.fillText('x*=' + fp.toFixed(4), sx + 10, sy - 6);
        });

        /* Custom control points */
        if (activePreset === 4) {
            customPoints.forEach((pt, i) => {
                const sx = toSx(pt.x), sy = toSy(pt.y);
                ctx.strokeStyle = 'rgba(129,140,248,0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(sx, sy, 8, 0, Math.PI * 2); ctx.stroke();
                ctx.fillStyle = 'rgba(129,140,248,0.2)';
                ctx.beginPath(); ctx.arc(sx, sy, 8, 0, Math.PI * 2); ctx.fill();
            });
        }

        /* Info */
        const infoEl = document.getElementById('brouwer1dInfo');
        if (fps.length > 0) {
            infoEl.innerHTML = '<span class="indigo">Fixed point' + (fps.length > 1 ? 's' : '') + ': ' +
                fps.map(fp => 'x* = ' + fp.toFixed(4)).join(', ') + '</span>' +
                ' &ensp;<span class="muted">(' + presets[activePreset].desc + ')</span>';
        } else {
            infoEl.innerHTML = '<span class="muted">Searching for fixed points...</span>';
        }

        /* Draw g(x) = f(x) - x on the secondary canvas */
        drawGx(f, fps);
    }

    function drawGx(f, fps) {
        gCtx.clearRect(0, 0, gW, gH);
        gCtx.fillStyle = BG;
        gCtx.fillRect(0, 0, gW, gH);

        const toGx = x => gm.left + x * gpw;
        const toGy = y => {
            /* g(x) ranges from roughly -1 to 1 but typically [-0.5, 1] */
            /* Map [-0.5, 1] to canvas */
            const lo = -0.6, hi = 1.0;
            return gm.top + (1 - (y - lo) / (hi - lo)) * gph;
        };

        /* Grid line at y = 0 */
        const zeroY = toGy(0);
        gCtx.strokeStyle = 'rgba(255,255,255,0.15)';
        gCtx.lineWidth = 1;
        gCtx.beginPath(); gCtx.moveTo(gm.left, zeroY); gCtx.lineTo(gW - gm.right, zeroY); gCtx.stroke();

        /* Axis */
        gCtx.strokeStyle = 'rgba(255,255,255,0.12)';
        gCtx.beginPath(); gCtx.moveTo(gm.left, gH - gm.bottom); gCtx.lineTo(gW - gm.right, gH - gm.bottom); gCtx.stroke();
        gCtx.beginPath(); gCtx.moveTo(gm.left, gm.top); gCtx.lineTo(gm.left, gH - gm.bottom); gCtx.stroke();

        /* Labels */
        gCtx.font = '11px Georgia';
        gCtx.fillStyle = '#808098';
        gCtx.textAlign = 'right';
        gCtx.textBaseline = 'middle';
        gCtx.fillText('0', gm.left - 8, zeroY);
        gCtx.textAlign = 'center';
        gCtx.textBaseline = 'top';
        gCtx.fillText('x', gm.left + gpw / 2, gH - gm.bottom + 10);
        gCtx.textAlign = 'left';
        gCtx.textBaseline = 'bottom';
        gCtx.fillText('g(x) = f(x) - x', gm.left + 4, gm.top - 2);

        /* g(0) and g(1) markers */
        const g0 = f(0) - 0;
        const g1 = f(1) - 1;
        /* g(0) >= 0 marker */
        gCtx.fillStyle = 'rgba(46,204,113,0.7)';
        gCtx.beginPath(); gCtx.arc(toGx(0), toGy(g0), 5, 0, Math.PI * 2); gCtx.fill();
        gCtx.font = '10px Courier New';
        gCtx.textAlign = 'left';
        gCtx.fillText('g(0)=' + g0.toFixed(2) + ' \u2265 0', toGx(0) + 8, toGy(g0) + 3);

        /* g(1) <= 0 marker */
        gCtx.fillStyle = 'rgba(248,113,113,0.7)';
        gCtx.beginPath(); gCtx.arc(toGx(1), toGy(g1), 5, 0, Math.PI * 2); gCtx.fill();
        gCtx.textAlign = 'right';
        gCtx.fillStyle = 'rgba(248,113,113,0.7)';
        gCtx.fillText('g(1)=' + g1.toFixed(2) + ' \u2264 0', toGx(1) - 8, toGy(g1) + 3);

        /* g(x) curve */
        gCtx.strokeStyle = 'rgba(129,140,248,0.7)';
        gCtx.lineWidth = 2;
        gCtx.beginPath();
        const steps = 400;
        for (let i = 0; i <= steps; i++) {
            const x = i / steps;
            const gv = f(x) - x;
            const sx = toGx(x), sy = toGy(gv);
            if (i === 0) gCtx.moveTo(sx, sy);
            else gCtx.lineTo(sx, sy);
        }
        gCtx.stroke();

        /* Fill above zero green, below zero red */
        /* Positive fill */
        gCtx.fillStyle = 'rgba(46,204,113,0.06)';
        gCtx.beginPath();
        gCtx.moveTo(toGx(0), zeroY);
        for (let i = 0; i <= steps; i++) {
            const x = i / steps;
            const gv = f(x) - x;
            const sy = Math.min(toGy(gv), zeroY);
            gCtx.lineTo(toGx(x), sy);
        }
        gCtx.lineTo(toGx(1), zeroY);
        gCtx.closePath();
        gCtx.fill();

        /* Negative fill */
        gCtx.fillStyle = 'rgba(248,113,113,0.06)';
        gCtx.beginPath();
        gCtx.moveTo(toGx(0), zeroY);
        for (let i = 0; i <= steps; i++) {
            const x = i / steps;
            const gv = f(x) - x;
            const sy = Math.max(toGy(gv), zeroY);
            gCtx.lineTo(toGx(x), sy);
        }
        gCtx.lineTo(toGx(1), zeroY);
        gCtx.closePath();
        gCtx.fill();

        /* Zero crossings */
        fps.forEach(fp => {
            const sx = toGx(fp), sy = zeroY;
            gCtx.fillStyle = INDIGO;
            gCtx.beginPath(); gCtx.arc(sx, sy, 5, 0, Math.PI * 2); gCtx.fill();
            /* Vertical dashed line */
            gCtx.setLineDash([3, 3]);
            gCtx.strokeStyle = 'rgba(129,140,248,0.3)';
            gCtx.lineWidth = 1;
            gCtx.beginPath(); gCtx.moveTo(sx, gm.top); gCtx.lineTo(sx, gH - gm.bottom); gCtx.stroke();
            gCtx.setLineDash([]);
        });
    }

    /* Buttons */
    function renderButtons() {
        const c = document.getElementById('brouwer1dBtns');
        c.innerHTML = presets.map((p, i) =>
            '<button class="btn' + (i === activePreset ? ' active' : '') + '" data-pi="' + i + '">' + p.label + '</button>'
        ).join('');
        c.querySelectorAll('.btn').forEach(b => b.addEventListener('click', () => {
            activePreset = parseInt(b.dataset.pi);
            renderButtons();
            draw();
            /* Also update cobweb */
            if (typeof window.cobwebDraw === 'function') window.cobwebDraw();
        }));
    }
    renderButtons();

    /* Mouse interaction for custom points */
    function getCanvasPos(e) {
        const r = cvs.getBoundingClientRect();
        return { x: (e.clientX - r.left) * (W / r.width), y: (e.clientY - r.top) * (H / r.height) };
    }

    cvs.addEventListener('mousedown', e => {
        if (activePreset !== 4) return;
        const p = getCanvasPos(e);
        const fx = fromSx(p.x), fy = fromSy(p.y);
        /* Find nearest control point */
        let bestDist = Infinity, bestI = -1;
        customPoints.forEach((pt, i) => {
            const d = (pt.x - fx) ** 2 + (pt.y - fy) ** 2;
            if (d < bestDist) { bestDist = d; bestI = i; }
        });
        if (bestDist < 0.01) {
            dragIdx = bestI;
        }
    });

    cvs.addEventListener('mousemove', e => {
        if (dragIdx < 0) return;
        const p = getCanvasPos(e);
        let fx = fromSx(p.x), fy = fromSy(p.y);
        /* First and last x are fixed at 0 and 1 */
        if (dragIdx === 0) fx = 0;
        else if (dragIdx === customPoints.length - 1) fx = 1;
        else fx = clamp(fx, 0.05, 0.95);
        fy = clamp(fy, 0, 1);
        customPoints[dragIdx] = { x: fx, y: fy };
        draw();
    });

    cvs.addEventListener('mouseup', () => { dragIdx = -1; });
    cvs.addEventListener('mouseleave', () => { dragIdx = -1; });

    /* Touch support */
    cvs.addEventListener('touchstart', e => {
        if (activePreset !== 4) return;
        e.preventDefault();
        const t = e.touches[0];
        const r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        const fx = fromSx(p.x), fy = fromSy(p.y);
        let bestDist = Infinity, bestI = -1;
        customPoints.forEach((pt, i) => {
            const d = (pt.x - fx) ** 2 + (pt.y - fy) ** 2;
            if (d < bestDist) { bestDist = d; bestI = i; }
        });
        if (bestDist < 0.02) dragIdx = bestI;
    }, { passive: false });

    cvs.addEventListener('touchmove', e => {
        if (dragIdx < 0) return;
        e.preventDefault();
        const t = e.touches[0];
        const r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        let fx = fromSx(p.x), fy = fromSy(p.y);
        if (dragIdx === 0) fx = 0;
        else if (dragIdx === customPoints.length - 1) fx = 1;
        else fx = clamp(fx, 0.05, 0.95);
        fy = clamp(fy, 0, 1);
        customPoints[dragIdx] = { x: fx, y: fy };
        draw();
    }, { passive: false });

    cvs.addEventListener('touchend', () => { dragIdx = -1; });

    /* Export for cobweb section */
    window.brouwerGetFunc = getFunc;
    window.brouwerGetPreset = () => activePreset;
    window.brouwerFindFixedPoints = findFixedPoints;

    /* Animate glow */
    function animate() {
        draw();
        requestAnimationFrame(animate);
    }
    animate();
})();


/* ════════════════════════════════════════════════════════════════
   SECTION 2: Cobweb / Iteration Diagram
   ════════════════════════════════════════════════════════════════ */
(function() {
    const cvs = document.getElementById('cobwebCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const margin = { left: 60, right: 30, top: 30, bottom: 50 };
    const pw = W - margin.left - margin.right;
    const ph = H - margin.top - margin.bottom;

    const x0Slider = document.getElementById('x0Slider');
    const x0Label = document.getElementById('x0Label');

    let x0 = 0.2;
    let iterValues = [0.2];
    let cobwebLines = []; /* {x1,y1,x2,y2} */
    let autoInterval = null;

    function toSx(x) { return margin.left + x * pw; }
    function toSy(y) { return margin.top + (1 - y) * ph; }

    function getFunc() { return window.brouwerGetFunc(); }

    function reset() {
        x0 = parseFloat(x0Slider.value) / 100;
        iterValues = [x0];
        cobwebLines = [];
        if (autoInterval) { clearInterval(autoInterval); autoInterval = null; }
        draw();
    }

    function step() {
        const f = getFunc();
        const xn = iterValues[iterValues.length - 1];
        const fxn = clamp(f(xn), 0, 1);
        /* Vertical: (xn, xn) -> (xn, f(xn)) */
        cobwebLines.push({ x1: xn, y1: iterValues.length === 1 ? 0 : xn, x2: xn, y2: fxn });
        /* Horizontal: (xn, f(xn)) -> (f(xn), f(xn)) */
        cobwebLines.push({ x1: xn, y1: fxn, x2: fxn, y2: fxn });
        iterValues.push(fxn);
        draw();
    }

    function autoRun() {
        if (autoInterval) { clearInterval(autoInterval); autoInterval = null; return; }
        autoInterval = setInterval(() => {
            if (iterValues.length > 80) { clearInterval(autoInterval); autoInterval = null; return; }
            step();
        }, 150);
    }

    x0Slider.addEventListener('input', () => {
        x0 = parseFloat(x0Slider.value) / 100;
        x0Label.textContent = x0.toFixed(2);
        reset();
    });

    document.getElementById('cobwebStep').addEventListener('click', step);
    document.getElementById('cobwebAuto').addEventListener('click', autoRun);
    document.getElementById('cobwebReset').addEventListener('click', reset);

    function draw() {
        const f = getFunc();
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        /* Grid */
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
            const v = i / 10;
            ctx.beginPath(); ctx.moveTo(toSx(v), margin.top); ctx.lineTo(toSx(v), H - margin.bottom); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(margin.left, toSy(v)); ctx.lineTo(W - margin.right, toSy(v)); ctx.stroke();
        }

        /* Axes */
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(margin.left, H - margin.bottom); ctx.lineTo(W - margin.right, H - margin.bottom); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(margin.left, margin.top); ctx.lineTo(margin.left, H - margin.bottom); ctx.stroke();

        /* Tick labels */
        ctx.font = '11px Georgia';
        ctx.fillStyle = '#505068';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let i = 0; i <= 10; i += 2) {
            ctx.fillText((i / 10).toFixed(1), toSx(i / 10), H - margin.bottom + 6);
        }
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i <= 10; i += 2) {
            ctx.fillText((i / 10).toFixed(1), margin.left - 8, toSy(i / 10));
        }

        /* y = x */
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath(); ctx.moveTo(toSx(0), toSy(0)); ctx.lineTo(toSx(1), toSy(1)); ctx.stroke();
        ctx.setLineDash([]);

        /* f(x) */
        ctx.strokeStyle = INDIGO;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        for (let i = 0; i <= 400; i++) {
            const x = i / 400;
            const y = clamp(f(x), 0, 1);
            if (i === 0) ctx.moveTo(toSx(x), toSy(y));
            else ctx.lineTo(toSx(x), toSy(y));
        }
        ctx.stroke();

        /* Cobweb lines */
        const totalLines = cobwebLines.length;
        cobwebLines.forEach((l, i) => {
            const alpha = 0.15 + 0.85 * (i / Math.max(totalLines, 1));
            ctx.strokeStyle = 'rgba(129,140,248,' + alpha.toFixed(2) + ')';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(toSx(l.x1), toSy(l.y1));
            ctx.lineTo(toSx(l.x2), toSy(l.y2));
            ctx.stroke();
        });

        /* Starting point marker */
        ctx.fillStyle = 'rgba(251,191,36,0.8)';
        ctx.beginPath(); ctx.arc(toSx(x0), toSy(0), 5, 0, Math.PI * 2); ctx.fill();
        ctx.font = '10px Courier New';
        ctx.fillStyle = '#fbbf24';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('x\u2080', toSx(x0), toSy(0) + 8);

        /* Fixed points */
        const fps = window.brouwerFindFixedPoints(f);
        fps.forEach(fp => {
            ctx.fillStyle = INDIGO;
            ctx.beginPath(); ctx.arc(toSx(fp), toSy(fp), 5, 0, Math.PI * 2); ctx.fill();
        });

        /* Stability info */
        const infoEl = document.getElementById('cobwebInfo');
        const valEl = document.getElementById('cobwebValues');
        let html = '';

        if (fps.length > 0 && iterValues.length > 1) {
            const lastVal = iterValues[iterValues.length - 1];
            /* Find nearest fixed point */
            let nearestFp = fps[0], minD = Math.abs(lastVal - fps[0]);
            fps.forEach(fp => {
                if (Math.abs(lastVal - fp) < minD) { minD = Math.abs(lastVal - fp); nearestFp = fp; }
            });

            /* Numerical derivative at fixed point */
            const h = 1e-6;
            const deriv = (f(nearestFp + h) - f(nearestFp - h)) / (2 * h);
            const absDeriv = Math.abs(deriv);
            const isStable = absDeriv < 1;

            html = '<span class="indigo">Approaching x* = ' + nearestFp.toFixed(4) + '</span>';
            html += ' &ensp; |f\'(x*)| = ' + absDeriv.toFixed(3);
            html += '<span class="stability-tag ' + (isStable ? 'stable' : 'unstable') + '">' +
                (isStable ? 'Stable (attracting)' : 'Unstable (repelling)') + '</span>';
        }
        infoEl.innerHTML = html;

        /* Iteration values */
        let valHtml = '';
        const maxShow = Math.min(iterValues.length, 25);
        for (let i = 0; i < maxShow; i++) {
            valHtml += '<span style="color:' + (i === 0 ? '#fbbf24' : INDIGO) + '">x<sub>' + i + '</sub> = ' + iterValues[i].toFixed(6) + '</span>';
            if (i < maxShow - 1) valHtml += ' &rarr; ';
        }
        if (iterValues.length > 25) valHtml += ' &hellip;';
        valEl.innerHTML = valHtml;
    }

    window.cobwebDraw = () => { reset(); };

    draw();
})();


/* ════════════════════════════════════════════════════════════════
   SECTION 3: Brouwer 2D — Vector Field
   ════════════════════════════════════════════════════════════════ */
(function() {
    const cvs = document.getElementById('brouwer2d');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const cx = W / 2, cy = H / 2;
    const R = 210; /* disk radius in pixels */

    const presets2d = [
        {
            label: 'Contraction + Rotation',
            fn: (x, y) => {
                const c = Math.cos(Math.PI / 6), s = Math.sin(Math.PI / 6);
                return { x: 0.9 * (c * x - s * y), y: 0.9 * (s * x + c * y) };
            },
            desc: 'f(x,y) = 0.9 R\u2083\u2080(x,y) -- contraction with 30\u00B0 rotation',
            fp: { x: 0, y: 0 }
        },
        {
            label: 'Contraction + Shift',
            fn: (x, y) => ({ x: x / 2 + 0.3, y: y / 2 - 0.1 }),
            desc: 'f(x,y) = (x/2 + 0.3, y/2 - 0.1)',
            fp: { x: 0.6, y: -0.2 }
        },
        {
            label: 'Twist',
            fn: (x, y) => {
                const r = Math.sqrt(x * x + y * y);
                const theta = Math.atan2(y, x) + 0.5 * (1 - r);
                const nr = r * 0.85 + 0.1;
                return { x: nr * Math.cos(theta), y: nr * Math.sin(theta) };
            },
            desc: 'Smooth swirl: radius contracts, angle twists',
            fp: null /* computed numerically */
        }
    ];

    let active2d = 0;

    function findFP2d(fn) {
        /* Newton-ish iteration to find fixed point */
        let x = 0, y = 0;
        for (let i = 0; i < 500; i++) {
            const p = fn(x, y);
            const dx = p.x - x, dy = p.y - y;
            if (dx * dx + dy * dy < 1e-14) break;
            x = p.x; y = p.y;
        }
        return { x, y };
    }

    function renderButtons() {
        const c = document.getElementById('brouwer2dBtns');
        c.innerHTML = presets2d.map((p, i) =>
            '<button class="btn' + (i === active2d ? ' active' : '') + '" data-pi="' + i + '">' + p.label + '</button>'
        ).join('');
        c.querySelectorAll('.btn').forEach(b => b.addEventListener('click', () => {
            active2d = parseInt(b.dataset.pi);
            renderButtons();
            draw();
        }));
    }
    renderButtons();

    let glowPhase2d = 0;

    function draw() {
        const preset = presets2d[active2d];
        const fn = preset.fn;
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        /* Unit disk */
        ctx.fillStyle = 'rgba(129,140,248,0.03)';
        ctx.strokeStyle = 'rgba(129,140,248,0.2)';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

        /* Axes */
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath(); ctx.moveTo(cx - R - 20, cy); ctx.lineTo(cx + R + 20, cy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx, cy - R - 20); ctx.lineTo(cx, cy + R + 20); ctx.stroke();
        ctx.setLineDash([]);

        /* Vector field on 15x15 grid */
        const gridN = 15;
        const arrowScale = R * 0.08;
        for (let i = 0; i < gridN; i++) {
            for (let j = 0; j < gridN; j++) {
                const gx = -1 + 2 * i / (gridN - 1);
                const gy = -1 + 2 * j / (gridN - 1);
                if (gx * gx + gy * gy > 1.0) continue; /* outside disk */

                const mapped = fn(gx, gy);
                /* Clamp mapped to disk */
                let mx = mapped.x, my = mapped.y;
                const mr = Math.sqrt(mx * mx + my * my);
                if (mr > 1) { mx /= mr; my /= mr; }

                const dx = mx - gx, dy = my - gy;
                const mag = Math.sqrt(dx * dx + dy * dy);

                const sx = cx + gx * R;
                const sy = cy - gy * R;
                const ex = sx + dx * R * 0.35;
                const ey = sy - dy * R * 0.35;

                /* Arrow color: magnitude */
                const alpha = clamp(0.15 + mag * 2, 0.1, 0.8);
                ctx.strokeStyle = 'rgba(129,140,248,' + alpha.toFixed(2) + ')';
                ctx.fillStyle = 'rgba(129,140,248,' + alpha.toFixed(2) + ')';
                ctx.lineWidth = 1.2;

                ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();

                /* Arrowhead */
                if (mag > 0.01) {
                    const ang = Math.atan2(ey - sy, ex - sx);
                    const hl = 4;
                    ctx.beginPath();
                    ctx.moveTo(ex, ey);
                    ctx.lineTo(ex - hl * Math.cos(ang - 0.4), ey - hl * Math.sin(ang - 0.4));
                    ctx.lineTo(ex - hl * Math.cos(ang + 0.4), ey - hl * Math.sin(ang + 0.4));
                    ctx.closePath(); ctx.fill();
                }
            }
        }

        /* Fixed point */
        const fp = preset.fp || findFP2d(fn);
        glowPhase2d += 0.03;
        const ga = 0.4 + 0.3 * Math.sin(glowPhase2d);
        const fpSx = cx + fp.x * R;
        const fpSy = cy - fp.y * R;

        const grad = ctx.createRadialGradient(fpSx, fpSy, 0, fpSx, fpSy, 20);
        grad.addColorStop(0, 'rgba(129,140,248,' + ga * 0.6 + ')');
        grad.addColorStop(1, 'rgba(129,140,248,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(fpSx, fpSy, 20, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = INDIGO;
        ctx.beginPath(); ctx.arc(fpSx, fpSy, 6, 0, Math.PI * 2); ctx.fill();

        ctx.font = '11px Courier New';
        ctx.fillStyle = INDIGO;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillText('fixed point (' + fp.x.toFixed(2) + ', ' + fp.y.toFixed(2) + ')', fpSx + 12, fpSy - 8);

        /* Info */
        document.getElementById('brouwer2dInfo').innerHTML =
            '<span class="indigo">' + preset.desc + '</span>' +
            ' &ensp;<span class="muted">Fixed point where arrows vanish: (' + fp.x.toFixed(3) + ', ' + fp.y.toFixed(3) + ')</span>';
    }

    function animate2d() {
        draw();
        requestAnimationFrame(animate2d);
    }
    animate2d();
})();


/* ════════════════════════════════════════════════════════════════
   SECTION 3b: Coffee Stirring Demo
   ════════════════════════════════════════════════════════════════ */
(function() {
    const cvs = document.getElementById('coffeeCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const cx = W / 2, cy = H / 2;
    const R = 210;

    const NUM_DOTS = 250;
    let dots = [];
    let stirCount = 0;
    let fixedDotIdx = -1;
    let animating = false;
    let animProgress = 0;
    let prevPositions = [];
    let targetPositions = [];

    /* Coffee-like colors */
    const coffeeColors = [
        '#8B4513', '#A0522D', '#D2691E', '#CD853F', '#DEB887',
        '#F5DEB3', '#FFDEAD', '#FFE4C4', '#C8A882', '#B8860B',
        '#DAA520', '#F4A460', '#D2B48C', '#BC8F8F', '#E6BE8A'
    ];

    function initDots() {
        dots = [];
        for (let i = 0; i < NUM_DOTS; i++) {
            /* Random in unit disk */
            let x, y;
            do {
                x = Math.random() * 2 - 1;
                y = Math.random() * 2 - 1;
            } while (x * x + y * y > 0.95);
            dots.push({
                x, y,
                color: coffeeColors[Math.floor(Math.random() * coffeeColors.length)],
                origX: x, origY: y
            });
        }
        stirCount = 0;
        fixedDotIdx = -1;
    }

    /* The stirring transformation - a continuous map of the disk to itself */
    function stirMap(x, y) {
        const r = Math.sqrt(x * x + y * y);
        if (r < 1e-9) return { x: 0, y: 0 };
        /* Angle-dependent rotation + mild radial contraction */
        const theta = Math.atan2(y, x);
        const twist = 1.2 * (1 - r * r); /* More twist near center */
        const newTheta = theta + twist;
        const newR = r * 0.92 + 0.04; /* Slight contraction toward r~0.5 */
        const clampR = Math.min(newR, 0.98);
        return {
            x: clampR * Math.cos(newTheta),
            y: clampR * Math.sin(newTheta)
        };
    }

    function findFixedDot() {
        /* After stirring, find the dot that moved least */
        let minDist = Infinity;
        let minIdx = 0;
        dots.forEach((d, i) => {
            const dist = Math.sqrt((d.x - prevPositions[i].x) ** 2 + (d.y - prevPositions[i].y) ** 2);
            if (dist < minDist) { minDist = dist; minIdx = i; }
        });
        fixedDotIdx = minIdx;
    }

    function stir() {
        if (animating) return;
        prevPositions = dots.map(d => ({ x: d.x, y: d.y }));
        targetPositions = dots.map(d => stirMap(d.x, d.y));
        animating = true;
        animProgress = 0;
        stirCount++;

        function animStep() {
            animProgress += 0.025;
            if (animProgress >= 1) {
                animProgress = 1;
                animating = false;
                dots.forEach((d, i) => {
                    d.x = targetPositions[i].x;
                    d.y = targetPositions[i].y;
                });
                findFixedDot();
                drawCoffee();
                return;
            }
            /* Interpolate */
            dots.forEach((d, i) => {
                d.x = lerp(prevPositions[i].x, targetPositions[i].x, animProgress);
                d.y = lerp(prevPositions[i].y, targetPositions[i].y, animProgress);
            });
            drawCoffee();
            requestAnimationFrame(animStep);
        }
        requestAnimationFrame(animStep);
    }

    function drawCoffee() {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        /* Disk (coffee cup) */
        ctx.fillStyle = 'rgba(80,50,20,0.15)';
        ctx.strokeStyle = 'rgba(139,69,19,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

        /* Dots */
        dots.forEach((d, i) => {
            const sx = cx + d.x * R;
            const sy = cy - d.y * R;
            const isFixed = i === fixedDotIdx;
            const dotR = isFixed ? 7 : 3.5;

            if (isFixed) {
                /* Glow for fixed dot */
                const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, 18);
                grad.addColorStop(0, 'rgba(129,140,248,0.5)');
                grad.addColorStop(1, 'rgba(129,140,248,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(sx, sy, 18, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = INDIGO;
                ctx.beginPath(); ctx.arc(sx, sy, dotR, 0, Math.PI * 2); ctx.fill();

                ctx.strokeStyle = INDIGO;
                ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(sx, sy, 12, 0, Math.PI * 2); ctx.stroke();
            } else {
                ctx.fillStyle = d.color;
                ctx.beginPath(); ctx.arc(sx, sy, dotR, 0, Math.PI * 2); ctx.fill();
            }
        });

        /* Stir count */
        ctx.font = '12px Georgia';
        ctx.fillStyle = '#808098';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('Stirs: ' + stirCount, 14, 14);

        if (fixedDotIdx >= 0) {
            const d = dots[fixedDotIdx];
            ctx.fillStyle = INDIGO;
            ctx.textAlign = 'right';
            ctx.fillText('Least-moved dot: (' + d.x.toFixed(3) + ', ' + d.y.toFixed(3) + ')', W - 14, 14);
        }
    }

    document.getElementById('coffeeStir').addEventListener('click', stir);
    document.getElementById('coffeeReset').addEventListener('click', () => {
        initDots();
        drawCoffee();
    });

    initDots();
    drawCoffee();
})();


/* ════════════════════════════════════════════════════════════════
   SECTION 4: Banach Contraction
   ════════════════════════════════════════════════════════════════ */
(function() {
    const cvs = document.getElementById('banachCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const margin = { left: 60, right: 30, top: 30, bottom: 50 };
    const pw = W - margin.left - margin.right;
    const ph = H - margin.top - margin.bottom;

    const f = x => (x + 1) / 3;
    const q = 1 / 3; /* contraction factor */
    const fixedPt = 0.5;

    const startColors = ['#818cf8', '#f87171', '#2ecc71', '#fbbf24', '#c084fc'];
    const startX0s = [0.0, 0.25, 0.5, 0.75, 1.0];

    let tracks = []; /* [{values: [x0, x1, ...], color}] */
    let iterStep = 0;
    let autoInterval = null;

    function toSx(x) { return margin.left + x * pw; }
    function toSy(y) { return margin.top + (1 - y) * ph; }

    function reset() {
        tracks = startX0s.map((x0, i) => ({
            values: [x0],
            color: startColors[i]
        }));
        iterStep = 0;
        if (autoInterval) { clearInterval(autoInterval); autoInterval = null; }
        draw();
    }

    function step() {
        tracks.forEach(track => {
            const last = track.values[track.values.length - 1];
            track.values.push(f(last));
        });
        iterStep++;
        draw();
    }

    function autoRun() {
        if (autoInterval) { clearInterval(autoInterval); autoInterval = null; return; }
        autoInterval = setInterval(() => {
            if (iterStep > 25) { clearInterval(autoInterval); autoInterval = null; return; }
            step();
        }, 300);
    }

    document.getElementById('banachStep').addEventListener('click', step);
    document.getElementById('banachAuto').addEventListener('click', autoRun);
    document.getElementById('banachReset').addEventListener('click', reset);

    function draw() {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        /* Grid */
        ctx.strokeStyle = 'rgba(255,255,255,0.04)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
            const v = i / 10;
            ctx.beginPath(); ctx.moveTo(toSx(v), margin.top); ctx.lineTo(toSx(v), H - margin.bottom); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(margin.left, toSy(v)); ctx.lineTo(W - margin.right, toSy(v)); ctx.stroke();
        }

        /* Axes */
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(margin.left, H - margin.bottom); ctx.lineTo(W - margin.right, H - margin.bottom); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(margin.left, margin.top); ctx.lineTo(margin.left, H - margin.bottom); ctx.stroke();

        /* Tick labels */
        ctx.font = '11px Georgia';
        ctx.fillStyle = '#505068';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        for (let i = 0; i <= 10; i += 2) {
            ctx.fillText((i / 10).toFixed(1), toSx(i / 10), H - margin.bottom + 6);
        }
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i <= 10; i += 2) {
            ctx.fillText((i / 10).toFixed(1), margin.left - 8, toSy(i / 10));
        }

        /* y = x */
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath(); ctx.moveTo(toSx(0), toSy(0)); ctx.lineTo(toSx(1), toSy(1)); ctx.stroke();
        ctx.setLineDash([]);

        /* f(x) = (x+1)/3 */
        ctx.strokeStyle = INDIGO;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(toSx(0), toSy(f(0)));
        ctx.lineTo(toSx(1), toSy(f(1)));
        ctx.stroke();

        /* Label f(x) */
        ctx.font = '12px Georgia';
        ctx.fillStyle = INDIGO;
        ctx.textAlign = 'left';
        ctx.fillText('f(x) = (x+1)/3', toSx(0.65), toSy(f(0.65)) - 14);

        /* Fixed point with glow */
        const fpSx = toSx(fixedPt), fpSy = toSy(fixedPt);
        ctx.fillStyle = INDIGO;
        ctx.beginPath(); ctx.arc(fpSx, fpSy, 6, 0, Math.PI * 2); ctx.fill();
        ctx.font = '10px Courier New';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillText('x* = 0.5', fpSx + 10, fpSy - 8);

        /* Draw tracks: each starting point iterating */
        tracks.forEach(track => {
            const vals = track.values;
            /* Draw dots on the x-axis showing current value */
            const lastVal = vals[vals.length - 1];
            /* Small cobweb for this track */
            ctx.strokeStyle = track.color;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5;
            for (let i = 0; i < vals.length - 1; i++) {
                const xn = vals[i];
                const fxn = vals[i + 1];
                /* Vertical: (xn, xn) to (xn, f(xn)) */
                ctx.beginPath();
                ctx.moveTo(toSx(xn), toSy(i === 0 ? 0 : xn));
                ctx.lineTo(toSx(xn), toSy(fxn));
                ctx.stroke();
                /* Horizontal: (xn, f(xn)) to (f(xn), f(xn)) */
                ctx.beginPath();
                ctx.moveTo(toSx(xn), toSy(fxn));
                ctx.lineTo(toSx(fxn), toSy(fxn));
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            /* Current dot */
            ctx.fillStyle = track.color;
            ctx.beginPath(); ctx.arc(toSx(lastVal), toSy(lastVal), 5, 0, Math.PI * 2); ctx.fill();
        });

        /* Info */
        const infoEl = document.getElementById('banachInfo');
        if (iterStep > 0) {
            const error = Math.pow(q, iterStep) / (1 - q) * Math.abs(tracks[0].values[1] - tracks[0].values[0]);
            infoEl.innerHTML =
                '<span class="indigo">Iteration n = ' + iterStep + '</span>' +
                ' &ensp; <span class="muted">Contraction factor q = 1/3</span>' +
                ' &ensp; <span class="muted">Error bound: |x<sub>n</sub> - x*| &le; q<sup>n</sup>/(1-q) &middot; |x<sub>1</sub> - x<sub>0</sub>| = ' + error.toExponential(2) + '</span>' +
                '<br><span class="muted" style="font-size:0.85em">All 5 starting points converge to x* = 0.5 at geometric rate q = 1/3</span>';
        } else {
            infoEl.innerHTML = '<span class="muted">Click "Step All" or "Auto" to iterate all 5 starting points simultaneously</span>';
        }
    }

    reset();
})();
</script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Coded by <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
