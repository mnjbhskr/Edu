<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group Theory &amp; Symmetry</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a1a;color:#e0e0e0;font-family:Georgia,'Times New Roman',serif;line-height:1.6}
        .container{max-width:960px;margin:0 auto;padding:24px 28px 48px}
        .back{color:#606078;text-decoration:none;font-size:0.85em}
        .back:hover{color:#fcd34d}
        h1{font-size:1.8em;font-weight:400;color:#fff;margin:16px 0 4px}
        .subtitle{color:#808098;font-style:italic;margin-bottom:28px}
        h2{font-size:1.15em;font-weight:400;color:#fff;margin:28px 0 12px}
        canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:crosshair}
        .panel{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:18px 22px;margin-bottom:20px}
        .panel h3{font-weight:400;font-size:0.8em;color:#808098;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
        .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
        .btn{background:rgba(255,255,255,0.035);border:1px solid rgba(255,255,255,0.07);color:#b0b0c4;padding:5px 13px;border-radius:6px;cursor:pointer;font-family:Georgia,serif;font-size:0.92em;transition:all 0.2s}
        .btn:hover{background:rgba(255,255,255,0.07);color:#e0e0ef}
        .btn.active{background:rgba(252,211,77,0.13);border-color:rgba(252,211,77,0.4);color:#fcd34d}
        .math-line{font-family:'Courier New',monospace;font-size:0.92em;color:#c0c0d8;margin:4px 0;line-height:1.8}
        .math-line .gold{color:#fcd34d}.math-line .indigo{color:#818cf8}.math-line .green{color:#2ecc71}
        .math-line .muted{color:#808098}
        .explain{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:20px 24px;margin-top:20px}
        .explain-name{color:#fcd34d;font-size:1.1em;margin-bottom:6px}
        .explain-text{color:#a0a0b8;font-size:0.9em;line-height:1.75}
        .slider-row{display:flex;align-items:center;gap:14px;margin:10px 0}
        .slider-row input[type=range]{flex:1;max-width:260px;accent-color:#fcd34d}
        .slider-label{color:#fcd34d;font-family:'Courier New',monospace;font-size:1.05em;min-width:50px}
        .flex-row{display:flex;gap:20px;flex-wrap:wrap}
        .flex-row>.flex-half{flex:1 1 300px;min-width:280px}
        .cayley-table{border-collapse:collapse;margin:10px 0;font-family:'Courier New',monospace;font-size:0.82em}
        .cayley-table th,.cayley-table td{padding:4px 7px;text-align:center;border:1px solid rgba(255,255,255,0.06);min-width:38px;cursor:pointer;transition:background 0.15s}
        .cayley-table th{color:#808098;background:rgba(255,255,255,0.02);font-weight:400}
        .cayley-table td:hover{background:rgba(252,211,77,0.12)}
        .cayley-table td.rot{color:#fcd34d}
        .cayley-table td.ref{color:#818cf8}
        .cayley-table td.highlight{background:rgba(252,211,77,0.2);outline:1px solid rgba(252,211,77,0.5)}
        .cayley-table th.highlight{background:rgba(252,211,77,0.15);color:#fcd34d}
        .axiom-box{border:1px solid rgba(255,255,255,0.06);border-radius:8px;padding:12px 16px;margin:8px 0;background:rgba(255,255,255,0.015)}
        .axiom-box .axiom-title{color:#fcd34d;font-size:0.95em;margin-bottom:4px}
        .axiom-box .axiom-desc{color:#808098;font-size:0.85em;margin-bottom:8px}
        .axiom-box .axiom-result{color:#c0c0d8;font-family:'Courier New',monospace;font-size:0.85em;min-height:20px;line-height:1.7}
        .axiom-box .axiom-result .pass{color:#2ecc71}
        .axiom-box .axiom-result .gold{color:#fcd34d}
        .subgroup-node{display:inline-block;padding:4px 10px;border-radius:6px;font-family:'Courier New',monospace;font-size:0.82em;margin:2px;background:rgba(252,211,77,0.08);border:1px solid rgba(252,211,77,0.2);color:#fcd34d;cursor:pointer;transition:all 0.2s}
        .subgroup-node:hover,.subgroup-node.active{background:rgba(252,211,77,0.2);border-color:rgba(252,211,77,0.5)}
        .info-line{color:#808098;font-size:0.88em;margin:6px 0;line-height:1.7}
        .status-line{color:#fcd34d;font-family:'Courier New',monospace;font-size:0.88em;margin:6px 0;min-height:22px}
        @media(max-width:600px){canvas{width:100%!important;height:auto!important}.cayley-table{font-size:0.72em}.cayley-table th,.cayley-table td{padding:3px 4px;min-width:28px}}
    </style>
</head>
<body>
<div class="container">
    <a class="back" href="index.html">&larr; Back to Index</a>
    <h1>Group Theory &amp; Symmetry</h1>
    <p class="subtitle">The mathematics of symmetry &mdash; rotations, reflections, and beyond</p>

    <!-- Section 1: Symmetries of a Shape -->
    <h2>Symmetries of a Shape</h2>
    <div class="panel">
        <h3>Select Shape</h3>
        <div class="btn-row" id="shapeBtns"></div>
        <div class="status-line" id="symCount"></div>
    </div>
    <canvas id="shapeCanvas" width="600" height="450"></canvas>
    <div class="panel" style="margin-top:20px">
        <h3>Symmetry Operations</h3>
        <div class="btn-row" id="rotBtns"></div>
        <div class="btn-row" id="refBtns"></div>
        <div class="status-line" id="currentState"></div>
    </div>

    <!-- Section 2: Cayley Table -->
    <h2>Group Multiplication Table (Cayley Table)</h2>
    <div class="panel">
        <h3>Composition Table for the Selected Group</h3>
        <div style="overflow-x:auto">
            <table class="cayley-table" id="cayleyTable"></table>
        </div>
        <div class="info-line" id="cayleyInfo">Click any cell to see the composition animated on the shape above.</div>
        <div class="status-line" id="cayleyResult"></div>
    </div>

    <!-- Section 3: Axiom Verification -->
    <h2>Group Axioms Verification</h2>
    <div class="panel" id="axiomPanel">
        <h3>Verify the four axioms for the selected group</h3>
        <div class="axiom-box">
            <div class="axiom-title">1. Closure</div>
            <div class="axiom-desc">Any two operations composed give another operation in the group.</div>
            <button class="btn" id="verifyClosure">Verify</button>
            <div class="axiom-result" id="closureResult"></div>
        </div>
        <div class="axiom-box">
            <div class="axiom-title">2. Associativity</div>
            <div class="axiom-desc">(a * b) * c = a * (b * c) for all a, b, c in G.</div>
            <button class="btn" id="verifyAssoc">Verify</button>
            <div class="axiom-result" id="assocResult"></div>
        </div>
        <div class="axiom-box">
            <div class="axiom-title">3. Identity</div>
            <div class="axiom-desc">There exists e such that e * g = g * e = g for all g.</div>
            <button class="btn" id="verifyIdentity">Verify</button>
            <div class="axiom-result" id="identityResult"></div>
        </div>
        <div class="axiom-box">
            <div class="axiom-title">4. Inverses</div>
            <div class="axiom-desc">For each g, there exists g&supmin;&sup1; such that g * g&supmin;&sup1; = e.</div>
            <button class="btn" id="verifyInverse">Verify</button>
            <div class="axiom-result" id="inverseResult"></div>
        </div>
    </div>

    <!-- Section 4: Cyclic Groups -->
    <h2>Cyclic Groups &amp; Modular Arithmetic</h2>
    <div class="panel">
        <h3>Z_n &mdash; Integers mod n</h3>
        <div class="slider-row">
            <span class="math-line muted">n =</span>
            <input type="range" id="cyclicN" min="2" max="12" value="6">
            <span class="slider-label" id="cyclicNLabel">6</span>
        </div>
        <canvas id="cyclicCanvas" width="450" height="350" style="margin:10px 0;cursor:pointer"></canvas>
        <div class="info-line" id="cyclicInfo">Click two elements on the circle to add them mod n.</div>
        <div class="status-line" id="cyclicResult"></div>
        <div style="margin-top:10px">
            <h3 style="margin-bottom:8px">Generators</h3>
            <div class="btn-row" id="generatorBtns"></div>
            <div class="info-line" id="generatorInfo"></div>
        </div>
    </div>

    <!-- Section 5: Subgroups & Lagrange's Theorem -->
    <h2>Subgroups &amp; Lagrange's Theorem</h2>
    <div class="panel">
        <h3>Subgroups of the Selected Dihedral Group</h3>
        <div id="subgroupList"></div>
        <canvas id="hassCanvas" width="450" height="300" style="margin:10px 0;cursor:default"></canvas>
        <div class="status-line" id="lagrangeResult"></div>
    </div>

    <!-- Section 6: Explanation -->
    <div class="explain">
        <div class="explain-name">What have we learnt?</div>
        <div class="explain-text">
            Group theory reveals that symmetry itself has structure. The symmetries of any object form a group, and understanding the group tells us everything about the object's symmetry. The same abstract group can appear as symmetries of completely different things &mdash; a triangle's rotational symmetry is the same group as integers mod 3 under addition.
            <br><br>
            The four group axioms (closure, associativity, identity, inverses) are remarkably economical: from these four simple rules, an enormous edifice of structure emerges. Lagrange's theorem shows that subgroup sizes must divide the group order &mdash; a constraint that has deep consequences, from the impossibility of trisecting an angle to the structure of particle physics.
            <br><br>
            <span style="color:#fcd34d">Applications:</span> Physics (particle physics via Lie groups, crystallography via space groups), chemistry (molecular symmetry and spectroscopy), cryptography (elliptic curve groups), the Rubik's cube (a subgroup of S&sub;4&sub;8; with ~4.3 &times; 10&sup1;&sup9; elements), and error-correcting codes.
            <br><br>
            <span style="color:#808098">Historical note:</span> Evariste Galois (1811&ndash;1832) invented group theory the night before his fatal duel, to prove that quintic equations have no general formula. Niels Henrik Abel independently proved the impossibility result. Arthur Cayley introduced the multiplication table in 1854, and Felix Klein's Erlangen Programme (1872) reimagined all of geometry as the study of group invariants.
        </div>
    </div>
</div>

<script>
/* ============================================================
   GROUP THEORY & SYMMETRY — Interactive Visualisation
   ============================================================ */

/* ── Dihedral Group Engine ── */

// Represent elements as [r, s] where r = rotation index, s = 0 (rotation) or 1 (reflection)
// Composition rule for D_n:
//   (r1, 0) * (r2, 0) = ((r1+r2) mod n, 0)
//   (r1, 0) * (r2, 1) = ((r1+r2) mod n, 1)
//   (r1, 1) * (r2, 0) = ((r1-r2+n) mod n, 1)
//   (r1, 1) * (r2, 1) = ((r1-r2+n) mod n, 0)

let N = 3; // current polygon sides
let currentPerm = null; // current vertex permutation [0..n-1]
let animating = false;
const VCOLORS = ['#fcd34d','#f87171','#22d3ee','#2ecc71','#818cf8','#fb923c'];

function mod(a, n) { return ((a % n) + n) % n; }

function compose(a, b, n) {
    // a = [ra, sa], b = [rb, sb]
    if (a[1] === 0 && b[1] === 0) return [mod(a[0] + b[0], n), 0];
    if (a[1] === 0 && b[1] === 1) return [mod(a[0] + b[0], n), 1];
    if (a[1] === 1 && b[1] === 0) return [mod(a[0] - b[0], n), 1];
    return [mod(a[0] - b[0], n), 0]; // a[1]===1 && b[1]===1
}

function elemEqual(a, b) { return a[0] === b[0] && a[1] === b[1]; }

function allElements(n) {
    const elems = [];
    for (let r = 0; r < n; r++) elems.push([r, 0]);
    for (let r = 0; r < n; r++) elems.push([r, 1]);
    return elems;
}

function elemName(e, n) {
    if (e[1] === 0) {
        return 'R\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089'.charAt(0) + subscript(e[0]);
    }
    return 's' + subscript(e[0] + 1);
}

function subscript(k) {
    const subs = '\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089';
    if (k < 10) return subs[k];
    return subs[Math.floor(k / 10)] + subs[k % 10];
}

function elemNameStr(e) {
    if (e[1] === 0) return 'R' + subscript(e[0]);
    return 's' + subscript(e[0] + 1);
}

function elemIndex(e, n) {
    if (e[1] === 0) return e[0];
    return n + e[0];
}

// Compute what a symmetry element does to vertex positions
// Vertices start at positions 0..n-1
// R_k rotates by k positions: vertex at position i goes to position (i+k) mod n
// s_k: reflect. First rotate by k, then reflect across axis through vertex 0
// We track where each vertex LABEL ends up (not positions)
function applyToVertices(e, n) {
    // returns permutation: result[i] = label of vertex now at position i
    const result = new Array(n);
    if (e[1] === 0) {
        // rotation by e[0]: vertex at label j is now at position (j + e[0]) mod n
        // so position i has label (i - e[0] + n) mod n
        for (let i = 0; i < n; i++) result[i] = mod(i - e[0], n);
    } else {
        // reflection s_{e[0]+1}: first apply rotation e[0], then reflect
        // Reflection across vertex-0 axis: position i -> position (n - i) mod n
        // Combined: position i has label from rotation then reflection
        for (let i = 0; i < n; i++) {
            const reflected = mod(n - i, n);
            result[i] = mod(reflected - e[0], n);
        }
    }
    return result;
}

function composePerms(perm1, perm2, n) {
    // Apply perm2 first, then perm1
    // perm[i] = label at position i
    // Actually we want: applying operation a then b
    // perm_b applied to current state perm_a:
    // new label at position i = perm_a[perm_b^{-1}(i)]...
    // Let's think differently:
    // perm1 is "after applying operation a, position i has label perm1[i]"
    // Then applying operation b on top: position i gets the label that was at position perm2_inv[i]
    // Hmm, let's just compose by applying b to the current arrangement of a:
    // If currently position i has label perm1[i], and b moves what's at position j to position b(j),
    // then new position i has the label that was at position b^{-1}(i) in old arrangement.
    // b is given as "position i has label perm_b[i]" from identity.
    // Actually simpler: if we have a state (permutation) and apply another element,
    // the result is just applying the element's permutation composed with current.
    // result[i] = perm1[perm2_inv[i]] where perm2 represents where things go
    //
    // Let me reconsider. Let state = array where state[i] = label at position i.
    // Element e moves position i to position sigma_e(i).
    // After applying e to state: new_state[sigma_e(i)] = state[i]
    // => new_state[j] = state[sigma_e_inv(j)]
    // applyToVertices gives us: for the identity state [0,1,...,n-1], where does each label end up
    // perm[i] = label at position i after applying e to identity state
    // So sigma_e maps old positions to labels... it IS the resulting state from identity.
    // To apply e to an existing state: new[i] = state[sigma_e_inv(i)]... no
    // Actually: perm from applyToVertices(e) means "position i now contains vertex label perm[i]"
    // So if e maps identity to perm_e, and we want to apply another element f after e:
    // We need perm_{e*f} which is applyToVertices(compose(e,f))
    // But if we just have an arbitrary state and want to apply f:
    // state after f: position i had label state[i], f rearranges positions
    // f says "in the new arrangement, position i has what was at position ..."
    // Let's just use the group composition directly and compute the permutation from scratch.
    return applyToVertices(perm2, n); // This isn't right either for arbitrary states
}

/* ── Shape Canvas ── */
const shapeCvs = document.getElementById('shapeCanvas');
const shapeCtx = shapeCvs.getContext('2d');
const SW = shapeCvs.width, SH = shapeCvs.height;
const sCtr = { x: SW / 2, y: SH / 2 };
const polyR = 140;

// Track the current group element (cumulative composition)
let currentElement = [0, 0]; // identity

function polygonVertices(n, radius, cx, cy) {
    const pts = [];
    for (let k = 0; k < n; k++) {
        const angle = (2 * Math.PI * k) / n - Math.PI / 2;
        pts.push({ x: cx + radius * Math.cos(angle), y: cy + radius * Math.sin(angle) });
    }
    return pts;
}

function drawShape(vertexLabels, reflectionAxes, highlightAxis) {
    const ctx = shapeCtx;
    ctx.clearRect(0, 0, SW, SH);
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, SW, SH);

    const pts = polygonVertices(N, polyR, sCtr.x, sCtr.y);

    // Draw reflection axes as dashed lines
    if (reflectionAxes) {
        for (let k = 0; k < reflectionAxes.length; k++) {
            const ax = reflectionAxes[k];
            const isHighlighted = highlightAxis === k;
            ctx.setLineDash([6, 4]);
            ctx.strokeStyle = isHighlighted ? 'rgba(129,140,248,0.6)' : 'rgba(255,255,255,0.08)';
            ctx.lineWidth = isHighlighted ? 1.5 : 1;
            ctx.beginPath();
            ctx.moveTo(sCtr.x + ax.dx * 200, sCtr.y + ax.dy * 200);
            ctx.lineTo(sCtr.x - ax.dx * 200, sCtr.y - ax.dy * 200);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    // Draw polygon edges
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let i = 0; i <= N; i++) {
        const p = pts[i % N];
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();

    // Fill polygon lightly
    ctx.fillStyle = 'rgba(252,211,77,0.03)';
    ctx.beginPath();
    for (let i = 0; i <= N; i++) {
        const p = pts[i % N];
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
    }
    ctx.fill();

    // Draw center dot
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath();
    ctx.arc(sCtr.x, sCtr.y, 3, 0, Math.PI * 2);
    ctx.fill();

    // Draw vertices with colors based on labels
    if (!vertexLabels) vertexLabels = Array.from({ length: N }, (_, i) => i);
    for (let i = 0; i < N; i++) {
        const p = pts[i];
        const label = vertexLabels[i];
        const color = VCOLORS[label % VCOLORS.length];

        // Vertex dot
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
        ctx.fill();

        // Vertex label
        const labelR = polyR + 28;
        const angle = (2 * Math.PI * i) / N - Math.PI / 2;
        const lx = sCtr.x + labelR * Math.cos(angle);
        const ly = sCtr.y + labelR * Math.sin(angle);
        ctx.font = '14px Georgia';
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText((label + 1).toString(), lx, ly);
    }

    // Position labels (small, muted)
    for (let i = 0; i < N; i++) {
        const posR = polyR - 22;
        const angle = (2 * Math.PI * i) / N - Math.PI / 2;
        const lx = sCtr.x + posR * Math.cos(angle);
        const ly = sCtr.y + posR * Math.sin(angle);
        ctx.font = '10px Courier New';
        ctx.fillStyle = '#505068';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('p' + i, lx, ly);
    }
}

function getReflectionAxes(n) {
    const axes = [];
    for (let k = 0; k < n; k++) {
        // Axis through vertex k and center
        // For even n, also through edge midpoints, but dihedral reflections are indexed differently
        // s_{k+1} reflects across an axis. The axis for s_{k+1} is at angle (pi*k/n - pi/2)
        // Actually, for our representation:
        // s_1 reflects across the axis through vertex 0 (angle = -pi/2 for top vertex)
        // s_2 is R_1 then reflect, so axis is rotated by pi/n from s_1's axis
        // General: axis for s_{k+1} is at angle (-pi/2 + pi*k/n)
        const axAngle = -Math.PI / 2 + Math.PI * k / n;
        axes.push({ dx: Math.cos(axAngle), dy: Math.sin(axAngle) });
    }
    return axes;
}

function getCurrentVertexLabels() {
    return applyToVertices(currentElement, N);
}

function drawCurrentState() {
    const labels = getCurrentVertexLabels();
    const axes = getReflectionAxes(N);
    drawShape(labels, axes, null);
    updateStateDisplay();
}

function updateStateDisplay() {
    const el = document.getElementById('currentState');
    const labels = getCurrentVertexLabels();
    const labelStr = labels.map(l => (l + 1)).join(', ');
    el.innerHTML = 'Current transformation: <span style="color:#fcd34d">' + elemNameStr(currentElement) +
        '</span> &mdash; Vertex positions: [' + labelStr + ']';
}

/* ── Animation ── */
function animateTransformation(element, callback) {
    if (animating) return;
    animating = true;

    const oldLabels = getCurrentVertexLabels();
    const newElement = compose(currentElement, element, N);
    const newLabels = applyToVertices(newElement, N);

    const pts = polygonVertices(N, polyR, sCtr.x, sCtr.y);
    const axes = getReflectionAxes(N);

    // For each vertex label, find its old position index and new position index
    const moves = [];
    for (let label = 0; label < N; label++) {
        let oldPos = -1, newPos = -1;
        for (let i = 0; i < N; i++) {
            if (oldLabels[i] === label) oldPos = i;
            if (newLabels[i] === label) newPos = i;
        }
        moves.push({ label, from: pts[oldPos], to: pts[newPos] });
    }

    const isReflection = element[1] === 1;
    const highlightAxis = isReflection ? element[0] : null;

    const duration = 500;
    const t0 = performance.now();

    function ease(t) { return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; }

    function step(now) {
        let frac = (now - t0) / duration;
        if (frac >= 1) {
            frac = 1;
            currentElement = newElement;
            animating = false;
            drawCurrentState();
            if (callback) callback();
            return;
        }
        const t = ease(frac);

        const ctx = shapeCtx;
        ctx.clearRect(0, 0, SW, SH);
        ctx.fillStyle = '#0a0a1a';
        ctx.fillRect(0, 0, SW, SH);

        // Draw axes
        for (let k = 0; k < axes.length; k++) {
            const ax = axes[k];
            const isHL = highlightAxis === k;
            ctx.setLineDash([6, 4]);
            ctx.strokeStyle = isHL ? 'rgba(129,140,248,' + (0.3 + 0.3 * t) + ')' : 'rgba(255,255,255,0.08)';
            ctx.lineWidth = isHL ? 1.5 : 1;
            ctx.beginPath();
            ctx.moveTo(sCtr.x + ax.dx * 200, sCtr.y + ax.dy * 200);
            ctx.lineTo(sCtr.x - ax.dx * 200, sCtr.y - ax.dy * 200);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw polygon edges (static)
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i <= N; i++) {
            const p = pts[i % N];
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        ctx.fillStyle = 'rgba(252,211,77,0.03)';
        ctx.beginPath();
        for (let i = 0; i <= N; i++) {
            const p = pts[i % N];
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.fill();

        // Center
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.beginPath();
        ctx.arc(sCtr.x, sCtr.y, 3, 0, Math.PI * 2);
        ctx.fill();

        // Position labels
        for (let i = 0; i < N; i++) {
            const posR = polyR - 22;
            const angle = (2 * Math.PI * i) / N - Math.PI / 2;
            const lx = sCtr.x + posR * Math.cos(angle);
            const ly = sCtr.y + posR * Math.sin(angle);
            ctx.font = '10px Courier New';
            ctx.fillStyle = '#505068';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('p' + i, lx, ly);
        }

        // Animated vertices
        for (const mv of moves) {
            const cx = mv.from.x + (mv.to.x - mv.from.x) * t;
            const cy = mv.from.y + (mv.to.y - mv.from.y) * t;
            const color = VCOLORS[mv.label % VCOLORS.length];
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fill();

            // Trail
            ctx.globalAlpha = 0.15;
            ctx.beginPath();
            ctx.arc(mv.from.x, mv.from.y, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Label
            const dx = cx - sCtr.x;
            const dy = cy - sCtr.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const lx = cx + (dx / dist) * 28;
            const ly = cy + (dy / dist) * 28;
            ctx.font = '14px Georgia';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText((mv.label + 1).toString(), lx, ly);
        }

        requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
}

/* ── Shape Selector ── */
const shapes = [
    { name: 'Triangle', n: 3 },
    { name: 'Square', n: 4 },
    { name: 'Pentagon', n: 5 },
    { name: 'Hexagon', n: 6 }
];

function renderShapeBtns() {
    const c = document.getElementById('shapeBtns');
    c.innerHTML = shapes.map(s =>
        '<button class="btn' + (s.n === N ? ' active' : '') + '" data-n="' + s.n + '">' +
        s.name + ' (D' + subscript(s.n) + '=' + (2 * s.n) + ')</button>'
    ).join('');
    c.querySelectorAll('.btn').forEach(b => b.addEventListener('click', () => {
        N = parseInt(b.dataset.n);
        currentElement = [0, 0];
        renderShapeBtns();
        renderSymBtns();
        drawCurrentState();
        buildCayleyTable();
        clearAxiomResults();
        buildSubgroups();
    }));
    document.getElementById('symCount').innerHTML =
        'This shape has <span style="color:#fcd34d">' + (2 * N) + ' symmetries</span> &mdash; ' +
        N + ' rotations + ' + N + ' reflections (the dihedral group D' + subscript(N) + ')';
}

function renderSymBtns() {
    // Rotation buttons
    const rc = document.getElementById('rotBtns');
    let rhtml = '<span style="color:#808098;font-size:0.85em;margin-right:6px">Rotations:</span>';
    for (let r = 0; r < N; r++) {
        const deg = Math.round(360 * r / N);
        const label = 'R' + subscript(r);
        const title = r === 0 ? 'identity' : deg + '\u00B0';
        rhtml += '<button class="btn" data-r="' + r + '" data-s="0" title="' + title + '">' + label + '</button>';
    }
    rc.innerHTML = rhtml;

    // Reflection buttons
    const fc = document.getElementById('refBtns');
    let fhtml = '<span style="color:#808098;font-size:0.85em;margin-right:6px">Reflections:</span>';
    for (let r = 0; r < N; r++) {
        const label = 's' + subscript(r + 1);
        fhtml += '<button class="btn" data-r="' + r + '" data-s="1">' + label + '</button>';
    }
    fc.innerHTML = fhtml;

    // Add click handlers
    document.querySelectorAll('#rotBtns .btn, #refBtns .btn').forEach(b => {
        b.addEventListener('click', () => {
            if (animating) return;
            const elem = [parseInt(b.dataset.r), parseInt(b.dataset.s)];
            animateTransformation(elem);
        });
    });

    // Reset button
    rc.innerHTML += ' <button class="btn" id="resetBtn" style="margin-left:12px;color:#808098">Reset</button>';
    document.getElementById('resetBtn').addEventListener('click', () => {
        if (animating) return;
        currentElement = [0, 0];
        drawCurrentState();
    });
}

/* ── Cayley Table ── */
function buildCayleyTable() {
    const elems = allElements(N);
    const table = document.getElementById('cayleyTable');
    let html = '<tr><th style="color:#fcd34d">*</th>';
    for (const e of elems) {
        html += '<th>' + elemNameStr(e) + '</th>';
    }
    html += '</tr>';
    for (let i = 0; i < elems.length; i++) {
        html += '<tr><th>' + elemNameStr(elems[i]) + '</th>';
        for (let j = 0; j < elems.length; j++) {
            const result = compose(elems[i], elems[j], N);
            const cls = result[1] === 0 ? 'rot' : 'ref';
            html += '<td class="' + cls + '" data-i="' + i + '" data-j="' + j + '">' +
                elemNameStr(result) + '</td>';
        }
        html += '</tr>';
    }
    table.innerHTML = html;

    // Click handler for cells
    table.querySelectorAll('td').forEach(td => {
        td.addEventListener('click', () => {
            if (animating) return;
            const i = parseInt(td.dataset.i);
            const j = parseInt(td.dataset.j);
            const a = elems[i];
            const b = elems[j];
            const result = compose(a, b, N);

            // Reset to identity first, then apply a, then b
            currentElement = [0, 0];
            drawCurrentState();

            // Show composition info
            document.getElementById('cayleyResult').innerHTML =
                elemNameStr(a) + ' * ' + elemNameStr(b) + ' = <span style="color:#fcd34d">' +
                elemNameStr(result) + '</span>';

            // Highlight the cell, its row header and column header
            table.querySelectorAll('td.highlight, th.highlight').forEach(el => el.classList.remove('highlight'));
            td.classList.add('highlight');
            // Highlight row and column headers
            const rows = table.querySelectorAll('tr');
            if (rows[i + 1]) {
                const rowTh = rows[i + 1].querySelector('th');
                if (rowTh) rowTh.classList.add('highlight');
            }
            const headerCells = rows[0].querySelectorAll('th');
            if (headerCells[j + 1]) headerCells[j + 1].classList.add('highlight');

            // Animate: first apply a, then b
            setTimeout(() => {
                animateTransformation(a, () => {
                    setTimeout(() => {
                        animateTransformation(b);
                    }, 200);
                });
            }, 100);
        });
    });

    // Check commutativity
    let isAbelian = true;
    for (let i = 0; i < elems.length && isAbelian; i++) {
        for (let j = i + 1; j < elems.length && isAbelian; j++) {
            const ab = compose(elems[i], elems[j], N);
            const ba = compose(elems[j], elems[i], N);
            if (!elemEqual(ab, ba)) isAbelian = false;
        }
    }
    const infoEl = document.getElementById('cayleyInfo');
    if (!isAbelian) {
        // Find a non-commutative example
        let ex = '';
        for (let i = 0; i < elems.length; i++) {
            for (let j = i + 1; j < elems.length; j++) {
                const ab = compose(elems[i], elems[j], N);
                const ba = compose(elems[j], elems[i], N);
                if (!elemEqual(ab, ba)) {
                    ex = elemNameStr(elems[i]) + ' * ' + elemNameStr(elems[j]) + ' = ' + elemNameStr(ab) +
                        ', but ' + elemNameStr(elems[j]) + ' * ' + elemNameStr(elems[i]) + ' = ' + elemNameStr(ba);
                    break;
                }
            }
            if (ex) break;
        }
        infoEl.innerHTML = 'Click any cell to animate. <span style="color:#818cf8">Non-abelian</span>: the table is NOT symmetric. ' + ex;
    } else {
        infoEl.innerHTML = 'Click any cell to animate. This group is abelian (commutative) &mdash; the table is symmetric.';
    }
}

/* ── Axiom Verification ── */
function clearAxiomResults() {
    ['closureResult', 'assocResult', 'identityResult', 'inverseResult'].forEach(id => {
        document.getElementById(id).innerHTML = '';
    });
}

document.getElementById('verifyClosure').addEventListener('click', () => {
    const elems = allElements(N);
    let html = '<span class="pass">Closure verified.</span> All ' + (2 * N) + ' &times; ' + (2 * N) +
        ' = ' + (4 * N * N) + ' compositions produce group elements.<br>';
    // Show one row as example
    const exRow = 1; // R_1
    html += 'Example row (' + elemNameStr(elems[exRow]) + '): ';
    for (let j = 0; j < elems.length; j++) {
        const r = compose(elems[exRow], elems[j], N);
        html += '<span class="gold">' + elemNameStr(r) + '</span>';
        if (j < elems.length - 1) html += ', ';
    }
    html += ' &mdash; all are group elements.';

    // Highlight the corresponding row in the Cayley table
    const table = document.getElementById('cayleyTable');
    table.querySelectorAll('td.highlight, th.highlight').forEach(el => el.classList.remove('highlight'));
    const rows = table.querySelectorAll('tr');
    if (rows[exRow + 1]) {
        rows[exRow + 1].querySelectorAll('td').forEach(td => td.classList.add('highlight'));
        const rowTh = rows[exRow + 1].querySelector('th');
        if (rowTh) rowTh.classList.add('highlight');
    }

    document.getElementById('closureResult').innerHTML = html;
});

document.getElementById('verifyAssoc').addEventListener('click', () => {
    const elems = allElements(N);
    // Pick 3 random elements
    const pick = () => elems[Math.floor(Math.random() * elems.length)];
    const a = pick(), b = pick(), c = pick();
    const ab = compose(a, b, N);
    const bc = compose(b, c, N);
    const ab_c = compose(ab, c, N);
    const a_bc = compose(a, bc, N);
    const ok = elemEqual(ab_c, a_bc);

    let html = '(' + elemNameStr(a) + ' * ' + elemNameStr(b) + ') * ' + elemNameStr(c) +
        ' = ' + elemNameStr(ab) + ' * ' + elemNameStr(c) + ' = <span class="gold">' + elemNameStr(ab_c) + '</span><br>';
    html += elemNameStr(a) + ' * (' + elemNameStr(b) + ' * ' + elemNameStr(c) +
        ') = ' + elemNameStr(a) + ' * ' + elemNameStr(bc) + ' = <span class="gold">' + elemNameStr(a_bc) + '</span><br>';
    html += ok ? '<span class="pass">Equal. Associativity holds.</span> (Click again for another random triple.)' :
        '<span style="color:#f87171">NOT equal!</span>';

    // Full verification
    let allOk = true;
    let count = 0;
    for (const ea of elems) {
        for (const eb of elems) {
            for (const ec of elems) {
                const lab = compose(ea, eb, N);
                const lbc = compose(eb, ec, N);
                if (!elemEqual(compose(lab, ec, N), compose(ea, lbc, N))) { allOk = false; }
                count++;
            }
        }
    }
    html += '<br><span class="pass">Exhaustive check: all ' + count + ' triples verified.</span>';

    document.getElementById('assocResult').innerHTML = html;
});

document.getElementById('verifyIdentity').addEventListener('click', () => {
    const elems = allElements(N);
    const identity = [0, 0];
    let html = 'Identity element: <span class="gold">' + elemNameStr(identity) + '</span> (the "do nothing" symmetry)<br>';

    let allOk = true;
    for (const e of elems) {
        const left = compose(identity, e, N);
        const right = compose(e, identity, N);
        if (!elemEqual(left, e) || !elemEqual(right, e)) allOk = false;
    }

    html += '<span class="pass">Verified:</span> ';
    for (const e of elems) {
        html += elemNameStr(identity) + '*' + elemNameStr(e) + '=' + elemNameStr(e);
        if (e !== elems[elems.length - 1]) html += ', ';
    }

    // Highlight identity row and column in Cayley table
    const table = document.getElementById('cayleyTable');
    table.querySelectorAll('td.highlight, th.highlight').forEach(el => el.classList.remove('highlight'));
    const rows = table.querySelectorAll('tr');
    // Identity is first row (index 1 in rows, since row 0 is header)
    if (rows[1]) {
        rows[1].querySelectorAll('td').forEach(td => td.classList.add('highlight'));
    }
    // Identity column (first data column)
    for (let i = 1; i < rows.length; i++) {
        const tds = rows[i].querySelectorAll('td');
        if (tds[0]) tds[0].classList.add('highlight');
    }

    document.getElementById('identityResult').innerHTML = html;
});

document.getElementById('verifyInverse').addEventListener('click', () => {
    const elems = allElements(N);
    let html = '<span class="pass">Every element has an inverse:</span><br>';

    for (const e of elems) {
        // Find inverse
        let inv = null;
        for (const f of elems) {
            if (elemEqual(compose(e, f, N), [0, 0])) { inv = f; break; }
        }
        html += elemNameStr(e) + ' * ' + elemNameStr(inv) + ' = ' + elemNameStr([0, 0]);
        // Note: reflections are self-inverse
        if (elemEqual(e, inv)) html += ' <span style="color:#808098">(self-inverse)</span>';
        html += '<br>';
    }

    // Highlight inverse pairs in Cayley table: cells that equal R0
    const table = document.getElementById('cayleyTable');
    table.querySelectorAll('td.highlight, th.highlight').forEach(el => el.classList.remove('highlight'));
    table.querySelectorAll('td').forEach(td => {
        if (td.textContent === 'R' + subscript(0)) {
            td.classList.add('highlight');
        }
    });

    document.getElementById('inverseResult').innerHTML = html;
});

/* ── Cyclic Groups ── */
const cyclicCvs = document.getElementById('cyclicCanvas');
const cyclicCtx = cyclicCvs.getContext('2d');
const CW = cyclicCvs.width, CH = cyclicCvs.height;
const cCtr = { x: CW / 2, y: CH / 2 };
const circR = 120;

let cyclicN = 6;
let cyclicSelected = []; // up to 2 selected elements
let generatorHighlight = -1;
let generatorSequence = [];

function drawCyclicGroup() {
    const ctx = cyclicCtx;
    const n = cyclicN;
    ctx.clearRect(0, 0, CW, CH);
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, CW, CH);

    // Circle
    ctx.setLineDash([3, 3]);
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(cCtr.x, cCtr.y, circR, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);

    // Generator arrows
    if (generatorSequence.length > 1) {
        for (let i = 0; i < generatorSequence.length - 1; i++) {
            const from = generatorSequence[i];
            const to = generatorSequence[i + 1];
            const a1 = (2 * Math.PI * from) / n - Math.PI / 2;
            const a2 = (2 * Math.PI * to) / n - Math.PI / 2;
            const arrowR = circR - 18;
            const x1 = cCtr.x + arrowR * Math.cos(a1);
            const y1 = cCtr.y + arrowR * Math.sin(a1);
            const x2 = cCtr.x + arrowR * Math.cos(a2);
            const y2 = cCtr.y + arrowR * Math.sin(a2);

            // Draw curved arrow along the circle
            const midAngle = (a1 + a2) / 2;
            // Handle wrap-around
            let angleDiff = a2 - a1;
            if (angleDiff < 0) angleDiff += 2 * Math.PI;
            if (angleDiff > Math.PI) {
                // Going the long way, use short way
                angleDiff -= 2 * Math.PI;
            }
            const midA = a1 + angleDiff / 2;

            const alpha = Math.max(0.15, 0.5 - i * 0.03);
            ctx.strokeStyle = 'rgba(252,211,77,' + alpha + ')';
            ctx.lineWidth = 1.5;

            // Draw arc
            const startA = a1;
            const endA = a1 + angleDiff;
            ctx.beginPath();
            if (angleDiff > 0) {
                ctx.arc(cCtr.x, cCtr.y, arrowR, startA, endA);
            } else {
                ctx.arc(cCtr.x, cCtr.y, arrowR, startA, endA, true);
            }
            ctx.stroke();

            // Small arrowhead at end
            const tipAngle = endA;
            const tipX = cCtr.x + arrowR * Math.cos(tipAngle);
            const tipY = cCtr.y + arrowR * Math.sin(tipAngle);
            const perpAngle = angleDiff > 0 ? tipAngle + Math.PI / 2 : tipAngle - Math.PI / 2;
            ctx.fillStyle = 'rgba(252,211,77,' + alpha + ')';
            ctx.beginPath();
            ctx.moveTo(tipX, tipY);
            ctx.lineTo(tipX - 6 * Math.cos(perpAngle - 0.5), tipY - 6 * Math.sin(perpAngle - 0.5));
            ctx.lineTo(tipX - 6 * Math.cos(perpAngle + 0.5), tipY - 6 * Math.sin(perpAngle + 0.5));
            ctx.closePath();
            ctx.fill();
        }
    }

    // Addition result line
    if (cyclicSelected.length === 2) {
        const sum = mod(cyclicSelected[0] + cyclicSelected[1], n);
        const a1 = (2 * Math.PI * cyclicSelected[0]) / n - Math.PI / 2;
        const a2 = (2 * Math.PI * cyclicSelected[1]) / n - Math.PI / 2;
        const a3 = (2 * Math.PI * sum) / n - Math.PI / 2;

        // Lines from selected to sum
        ctx.setLineDash([4, 3]);
        ctx.strokeStyle = 'rgba(46,204,113,0.3)';
        ctx.lineWidth = 1;
        const r2 = circR + 2;
        ctx.beginPath();
        ctx.moveTo(cCtr.x + r2 * Math.cos(a1), cCtr.y + r2 * Math.sin(a1));
        ctx.lineTo(cCtr.x + (r2 + 30) * Math.cos(a3), cCtr.y + (r2 + 30) * Math.sin(a3));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cCtr.x + r2 * Math.cos(a2), cCtr.y + r2 * Math.sin(a2));
        ctx.lineTo(cCtr.x + (r2 + 30) * Math.cos(a3), cCtr.y + (r2 + 30) * Math.sin(a3));
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Points on circle
    for (let k = 0; k < n; k++) {
        const angle = (2 * Math.PI * k) / n - Math.PI / 2;
        const px = cCtr.x + circR * Math.cos(angle);
        const py = cCtr.y + circR * Math.sin(angle);

        const isSelected = cyclicSelected.includes(k);
        const isSum = cyclicSelected.length === 2 && mod(cyclicSelected[0] + cyclicSelected[1], n) === k;
        const isGenerator = generatorHighlight >= 0 && generatorSequence.includes(k);

        let color = 'rgba(255,255,255,0.25)';
        let radius = 6;
        if (isSum) { color = '#2ecc71'; radius = 9; }
        else if (isSelected) { color = '#fcd34d'; radius = 8; }
        else if (isGenerator) { color = 'rgba(252,211,77,0.6)'; radius = 7; }

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);
        ctx.fill();

        // Label
        const lr = circR + 22;
        const lx = cCtr.x + lr * Math.cos(angle);
        const ly = cCtr.y + lr * Math.sin(angle);
        ctx.font = '13px Courier New';
        ctx.fillStyle = isSelected ? '#fcd34d' : isSum ? '#2ecc71' : '#808098';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(k.toString(), lx, ly);
    }

    // Center label
    ctx.font = '16px Georgia';
    ctx.fillStyle = '#fcd34d';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Z' + subscript(n), cCtr.x, cCtr.y);

    // "+" label
    ctx.font = '11px Georgia';
    ctx.fillStyle = '#808098';
    ctx.fillText('addition mod ' + n, cCtr.x, cCtr.y + 20);
}

function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }

function updateGenerators() {
    const n = cyclicN;
    const c = document.getElementById('generatorBtns');
    let html = '';
    for (let g = 0; g < n; g++) {
        const isGen = gcd(g, n) === 1 || g === 0;
        const genLabel = g === 0 ? '(trivial)' : (isGen ? 'generator' : 'not a generator');
        const cls = isGen && g > 0 ? ' active' : '';
        html += '<button class="btn' + cls + '" data-g="' + g + '">' + g + '</button>';
    }
    c.innerHTML = html;

    const gens = [];
    for (let g = 1; g < n; g++) {
        if (gcd(g, n) === 1) gens.push(g);
    }
    document.getElementById('generatorInfo').innerHTML =
        'Generators of Z' + subscript(n) + ': {' + gens.join(', ') + '} &mdash; elements coprime to ' + n +
        '. An element g generates the group if gcd(g, ' + n + ') = 1.';

    c.querySelectorAll('.btn').forEach(b => {
        b.addEventListener('click', () => {
            const g = parseInt(b.dataset.g);
            generatorHighlight = g;
            // Build sequence
            generatorSequence = [0];
            if (g > 0) {
                let current = 0;
                for (let i = 0; i < n; i++) {
                    current = mod(current + g, n);
                    generatorSequence.push(current);
                    if (current === 0) break;
                }
            }

            // Update info
            const isGen = g > 0 && gcd(g, n) === 1;
            const generated = new Set(generatorSequence);
            const genAll = generated.size >= n || (generated.has(0) && generatorSequence.length > n);
            let info = 'Powers of ' + g + ': ' + generatorSequence.join(' -> ');
            if (g === 0) {
                info = '0 generates only {0} &mdash; the trivial subgroup.';
            } else if (isGen) {
                info += ' &mdash; generates ALL of Z' + subscript(n);
            } else {
                const subgroup = [...new Set(generatorSequence)].sort((a, b) => a - b);
                info += ' &mdash; generates only {' + subgroup.join(', ') + '} (order ' + (subgroup.length) + ')';
            }
            document.getElementById('cyclicResult').innerHTML = info;

            drawCyclicGroup();
        });
    });
}

// Click on cyclic canvas to select elements
cyclicCvs.addEventListener('click', (e) => {
    const rect = cyclicCvs.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (CW / rect.width);
    const my = (e.clientY - rect.top) * (CH / rect.height);
    const n = cyclicN;

    // Find closest element
    let closest = -1, minDist = 30;
    for (let k = 0; k < n; k++) {
        const angle = (2 * Math.PI * k) / n - Math.PI / 2;
        const px = cCtr.x + circR * Math.cos(angle);
        const py = cCtr.y + circR * Math.sin(angle);
        const d = Math.sqrt((mx - px) ** 2 + (my - py) ** 2);
        if (d < minDist) { minDist = d; closest = k; }
    }

    if (closest >= 0) {
        if (cyclicSelected.length < 2) {
            cyclicSelected.push(closest);
        } else {
            cyclicSelected = [closest];
        }

        if (cyclicSelected.length === 2) {
            const sum = mod(cyclicSelected[0] + cyclicSelected[1], n);
            document.getElementById('cyclicResult').innerHTML =
                cyclicSelected[0] + ' + ' + cyclicSelected[1] + ' = <span style="color:#2ecc71">' +
                sum + '</span> (mod ' + n + ')';
        } else {
            document.getElementById('cyclicResult').innerHTML =
                'Selected: ' + cyclicSelected[0] + '. Click another element to add.';
        }
        generatorHighlight = -1;
        generatorSequence = [];
        drawCyclicGroup();
    }
});

// Touch support for cyclic canvas
cyclicCvs.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    const rect = cyclicCvs.getBoundingClientRect();
    const mx = (t.clientX - rect.left) * (CW / rect.width);
    const my = (t.clientY - rect.top) * (CH / rect.height);
    const n = cyclicN;

    let closest = -1, minDist = 40;
    for (let k = 0; k < n; k++) {
        const angle = (2 * Math.PI * k) / n - Math.PI / 2;
        const px = cCtr.x + circR * Math.cos(angle);
        const py = cCtr.y + circR * Math.sin(angle);
        const d = Math.sqrt((mx - px) ** 2 + (my - py) ** 2);
        if (d < minDist) { minDist = d; closest = k; }
    }

    if (closest >= 0) {
        if (cyclicSelected.length < 2) {
            cyclicSelected.push(closest);
        } else {
            cyclicSelected = [closest];
        }
        if (cyclicSelected.length === 2) {
            const sum = mod(cyclicSelected[0] + cyclicSelected[1], n);
            document.getElementById('cyclicResult').innerHTML =
                cyclicSelected[0] + ' + ' + cyclicSelected[1] + ' = <span style="color:#2ecc71">' +
                sum + '</span> (mod ' + n + ')';
        } else {
            document.getElementById('cyclicResult').innerHTML =
                'Selected: ' + cyclicSelected[0] + '. Tap another element to add.';
        }
        generatorHighlight = -1;
        generatorSequence = [];
        drawCyclicGroup();
    }
}, { passive: false });

const cyclicSlider = document.getElementById('cyclicN');
cyclicSlider.addEventListener('input', () => {
    cyclicN = parseInt(cyclicSlider.value);
    document.getElementById('cyclicNLabel').textContent = cyclicN;
    cyclicSelected = [];
    generatorHighlight = -1;
    generatorSequence = [];
    document.getElementById('cyclicResult').innerHTML = '';
    drawCyclicGroup();
    updateGenerators();
});

/* ── Subgroups & Lagrange's Theorem ── */
function buildSubgroups() {
    const n = N;
    const elems = allElements(n);
    const order = 2 * n;

    // Find all subgroups of D_n
    // Known subgroups:
    // 1. {e} - trivial
    // 2. Cyclic rotation subgroups: for each d dividing n, <R_{n/d}> has order d
    // 3. Reflection subgroups: {e, s_k} for each reflection s_k
    // 4. Dihedral subgroups: for each d dividing n, D_d subgroups
    // 5. D_n itself

    const subgroups = [];

    // Trivial subgroup
    subgroups.push({ elements: [[0, 0]], name: '{e}', order: 1 });

    // Cyclic subgroups of rotations
    const divisors = [];
    for (let d = 1; d <= n; d++) {
        if (n % d === 0) divisors.push(d);
    }

    for (const d of divisors) {
        if (d === 1) continue; // already have trivial
        const step = n / d;
        const sub = [];
        for (let k = 0; k < d; k++) {
            sub.push([mod(k * step, n), 0]);
        }
        if (d === n) {
            subgroups.push({ elements: sub, name: 'C' + subscript(n) + ' (all rotations)', order: d });
        } else {
            const genStr = 'R' + subscript(step);
            subgroups.push({ elements: sub, name: '<' + genStr + '> (cyclic, order ' + d + ')', order: d });
        }
    }

    // Reflection subgroups {e, s_k}
    for (let k = 0; k < n; k++) {
        subgroups.push({ elements: [[0, 0], [k, 1]], name: '{e, s' + subscript(k + 1) + '}', order: 2 });
    }

    // Dihedral subgroups (for composite n)
    for (const d of divisors) {
        if (d <= 2 || d === n) continue;
        // D_d subgroups: for each coset of reflections
        const step = n / d;
        for (let offset = 0; offset < step; offset++) {
            const sub = [];
            // Rotations: multiples of step
            for (let k = 0; k < d; k++) {
                sub.push([mod(k * step, n), 0]);
            }
            // Reflections
            for (let k = 0; k < d; k++) {
                sub.push([mod(k * step + offset, n), 1]);
            }
            // Verify it's actually a subgroup (closure)
            let isSub = true;
            for (const a of sub) {
                for (const b of sub) {
                    const c = compose(a, b, n);
                    if (!sub.some(s => elemEqual(s, c))) { isSub = false; break; }
                }
                if (!isSub) break;
            }
            if (isSub) {
                subgroups.push({ elements: sub, name: 'D' + subscript(d) + ' (order ' + (2 * d) + ')', order: 2 * d });
            }
        }
    }

    // Full group
    subgroups.push({ elements: elems.slice(), name: 'D' + subscript(n) + ' (full group)', order: order });

    // Remove duplicates (based on sorted element sets)
    const unique = [];
    const seen = new Set();
    for (const sg of subgroups) {
        const key = sg.elements.map(e => e[0] + ',' + e[1]).sort().join('|');
        if (!seen.has(key)) {
            seen.add(key);
            unique.push(sg);
        }
    }
    unique.sort((a, b) => a.order - b.order);

    // Render subgroup list
    const listEl = document.getElementById('subgroupList');
    let html = '';
    for (let i = 0; i < unique.length; i++) {
        const sg = unique[i];
        const elemStr = '{' + sg.elements.map(e => elemNameStr(e)).join(', ') + '}';
        html += '<div class="subgroup-node" data-idx="' + i + '" title="' + elemStr + '">' +
            sg.name + ' &mdash; |H|=' + sg.order + '</div> ';
    }
    listEl.innerHTML = html;

    // Lagrange info
    const orderStr = [...new Set(unique.map(s => s.order))].sort((a, b) => a - b).join(', ');
    document.getElementById('lagrangeResult').innerHTML =
        '|D' + subscript(n) + '| = ' + order + '. Subgroup orders: ' + orderStr +
        ' &mdash; all divide ' + order + '. <span style="color:#2ecc71">Lagrange\'s theorem confirmed.</span>';

    // Click handler for subgroup nodes
    listEl.querySelectorAll('.subgroup-node').forEach(node => {
        node.addEventListener('click', () => {
            listEl.querySelectorAll('.subgroup-node').forEach(n2 => n2.classList.remove('active'));
            node.classList.add('active');
            const idx = parseInt(node.dataset.idx);
            const sg = unique[idx];
            const cosets = order / sg.order;
            document.getElementById('lagrangeResult').innerHTML =
                '<span style="color:#fcd34d">' + sg.name + '</span>: |H| = ' + sg.order +
                ', cosets = ' + order + ' / ' + sg.order + ' = ' + cosets +
                '. Elements: {' + sg.elements.map(e => elemNameStr(e)).join(', ') + '}';
        });
    });

    // Draw Hasse diagram
    drawHasseDiagram(unique, order);
}

function drawHasseDiagram(subgroups, groupOrder) {
    const cvs = document.getElementById('hassCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, W, H);

    if (subgroups.length === 0) return;

    // Group subgroups by order for vertical positioning
    const orderLevels = {};
    for (const sg of subgroups) {
        if (!orderLevels[sg.order]) orderLevels[sg.order] = [];
        orderLevels[sg.order].push(sg);
    }
    const orders = Object.keys(orderLevels).map(Number).sort((a, b) => a - b);
    const numLevels = orders.length;

    // Assign positions
    const padding = { top: 30, bottom: 30, left: 40, right: 40 };
    const levelHeight = (H - padding.top - padding.bottom) / Math.max(numLevels - 1, 1);

    const positions = new Map();
    for (let li = 0; li < orders.length; li++) {
        const ord = orders[li];
        const sgs = orderLevels[ord];
        const y = H - padding.bottom - li * levelHeight;
        const totalWidth = W - padding.left - padding.right;
        for (let si = 0; si < sgs.length; si++) {
            const x = padding.left + totalWidth * (si + 0.5) / sgs.length;
            positions.set(sgs[si], { x, y });
        }
    }

    // Draw edges: connect subgroups where one contains the other and they differ by one level
    // Check containment: sg1 is subgroup of sg2
    function isSubOf(sg1, sg2) {
        if (sg1.order >= sg2.order) return false;
        if (sg2.order % sg1.order !== 0) return false;
        for (const e of sg1.elements) {
            if (!sg2.elements.some(f => elemEqual(e, f))) return false;
        }
        return true;
    }

    // Find direct containment (no intermediate subgroup)
    const edges = [];
    for (let i = 0; i < subgroups.length; i++) {
        for (let j = i + 1; j < subgroups.length; j++) {
            if (isSubOf(subgroups[i], subgroups[j])) {
                // Check if there's an intermediate subgroup
                let direct = true;
                for (let k = 0; k < subgroups.length; k++) {
                    if (k === i || k === j) continue;
                    if (isSubOf(subgroups[i], subgroups[k]) && isSubOf(subgroups[k], subgroups[j])) {
                        direct = false;
                        break;
                    }
                }
                if (direct) {
                    edges.push([subgroups[i], subgroups[j]]);
                }
            }
        }
    }

    // Draw edges
    ctx.strokeStyle = 'rgba(252,211,77,0.2)';
    ctx.lineWidth = 1;
    for (const [a, b] of edges) {
        const pa = positions.get(a);
        const pb = positions.get(b);
        if (pa && pb) {
            ctx.beginPath();
            ctx.moveTo(pa.x, pa.y);
            ctx.lineTo(pb.x, pb.y);
            ctx.stroke();
        }
    }

    // Draw nodes
    for (const sg of subgroups) {
        const pos = positions.get(sg);
        if (!pos) continue;

        ctx.fillStyle = 'rgba(252,211,77,0.15)';
        ctx.strokeStyle = 'rgba(252,211,77,0.35)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Label
        ctx.font = '10px Courier New';
        ctx.fillStyle = '#fcd34d';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';

        // Abbreviated name
        let shortName = sg.name.split(' ')[0];
        if (shortName === '{e}') shortName = '{e}';
        if (shortName === '{e,') shortName = sg.name.split('}')[0] + '}';
        ctx.fillText(shortName, pos.x, pos.y - 10);

        // Order label
        ctx.font = '9px Courier New';
        ctx.fillStyle = '#808098';
        ctx.textBaseline = 'top';
        ctx.fillText('|' + sg.order + '|', pos.x, pos.y + 10);
    }

    // Level labels on the right
    ctx.font = '9px Georgia';
    ctx.fillStyle = '#505068';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (let li = 0; li < orders.length; li++) {
        const y = H - padding.bottom - li * levelHeight;
        ctx.fillText('order ' + orders[li], W - 8, y);
    }
}

/* ── Initialization ── */
function init() {
    renderShapeBtns();
    renderSymBtns();
    drawCurrentState();
    buildCayleyTable();
    drawCyclicGroup();
    updateGenerators();
    buildSubgroups();
}

init();
</script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
