<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Curvature</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a1a;color:#e0e0e0;font-family:Georgia,'Times New Roman',serif;line-height:1.6}
        .container{max-width:960px;margin:0 auto;padding:24px 28px 48px}
        .back{color:#606078;text-decoration:none;font-size:0.85em}
        .back:hover{color:#818cf8}
        h1{font-size:1.8em;font-weight:400;color:#fff;margin:16px 0 4px}
        .subtitle{color:#808098;font-style:italic;margin-bottom:28px}
        h2{font-size:1.15em;font-weight:400;color:#fff;margin:28px 0 12px}
        canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:crosshair}
        .panel{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:18px 22px;margin-bottom:20px}
        .panel h3{font-weight:400;font-size:0.8em;color:#808098;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
        .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
        .btn{background:rgba(255,255,255,0.035);border:1px solid rgba(255,255,255,0.07);color:#b0b0c4;padding:5px 13px;border-radius:6px;cursor:pointer;font-family:Georgia,serif;font-size:0.92em;transition:all 0.2s}
        .btn:hover{background:rgba(255,255,255,0.07);color:#e0e0ef}
        .btn.active{background:rgba(129,140,248,0.13);border-color:rgba(129,140,248,0.4);color:#818cf8}
        .math-line{font-family:'Courier New',monospace;font-size:0.92em;color:#c0c0d8;margin:4px 0;line-height:1.8}
        .math-line .indigo{color:#818cf8}
        .math-line .red{color:#f87171}
        .math-line .muted{color:#808098}
        .math-line .white{color:#e0e0e0}
        .explain{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:20px 24px;margin-top:20px}
        .explain-name{color:#818cf8;font-size:1.1em;margin-bottom:6px}
        .explain-text{color:#a0a0b8;font-size:0.9em;line-height:1.75}
        .explain-text p{margin-bottom:10px}
        .slider-row{display:flex;align-items:center;gap:14px;margin:10px 0}
        .slider-row input[type=range]{flex:1;max-width:300px;accent-color:#818cf8}
        .slider-label{color:#818cf8;font-family:'Courier New',monospace;font-size:1.05em;min-width:80px}
        .color-bar{display:flex;align-items:center;gap:6px;margin:10px 0;font-size:0.82em;color:#808098}
        .color-bar canvas{border:none;border-radius:4px;cursor:default}
        .info-box{background:rgba(129,140,248,0.06);border:1px solid rgba(129,140,248,0.15);border-radius:8px;padding:12px 16px;margin:10px 0;font-size:0.88em;color:#b0b0c4;line-height:1.7}
        @media(max-width:600px){canvas{width:100%!important;height:auto!important}}
    </style>
</head>
<body>
<div class="container">
    <a class="back" href="index.html">&larr; Back to Index</a>
    <h1>Gaussian Curvature</h1>
    <p class="subtitle">The intrinsic geometry of curved surfaces &mdash; Theorema Egregium</p>

    <!-- ═══════════════════════════════════════════════════════════════ -->
    <!-- SECTION 1: Surface Gallery -->
    <!-- ═══════════════════════════════════════════════════════════════ -->
    <h2>Surface Gallery &mdash; Curvature Coloring</h2>
    <div class="panel">
        <h3>Surface</h3>
        <div class="btn-row" id="surfBtns"></div>
        <canvas id="surfCanvas" width="650" height="450"></canvas>
        <div class="color-bar" style="margin-top:12px">
            <span>K &lt; 0 (saddle)</span>
            <canvas id="colorBar" width="200" height="14" style="flex:0 0 200px"></canvas>
            <span>K &gt; 0 (dome)</span>
        </div>
        <div id="surfInfo" class="math-line muted" style="margin-top:6px"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════ -->
    <!-- SECTION 2: Principal Curvatures -->
    <!-- ═══════════════════════════════════════════════════════════════ -->
    <h2>Principal Curvatures</h2>
    <div class="panel">
        <h3>Analysis Point</h3>
        <div class="slider-row">
            <span class="math-line muted">u =</span>
            <input type="range" id="princU" min="0" max="100" value="50">
            <span class="slider-label" id="princULabel">0.00</span>
        </div>
        <div class="slider-row">
            <span class="math-line muted">v =</span>
            <input type="range" id="princV" min="0" max="100" value="50">
            <span class="slider-label" id="princVLabel">0.00</span>
        </div>
        <canvas id="princCanvas" width="550" height="400"></canvas>
        <div id="princInfo" class="info-box" style="margin-top:12px"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════ -->
    <!-- SECTION 3: Theorema Egregium -->
    <!-- ═══════════════════════════════════════════════════════════════ -->
    <h2>Theorema Egregium &mdash; The Remarkable Theorem</h2>
    <div class="panel">
        <h3>Bending preserves Gaussian curvature</h3>
        <div class="info-box">
            Gaussian curvature is <em>intrinsic</em> &mdash; it depends only on distances measured ON the surface,
            not on how the surface sits in 3D space. A flat sheet (K=0) can be bent into a cylinder (still K=0!)
            but never into a sphere (K&gt;0) without stretching or tearing.
        </div>
        <div class="slider-row">
            <span class="math-line muted">Bend:</span>
            <input type="range" id="bendSlider" min="0" max="100" value="0">
            <span class="slider-label" id="bendLabel">Flat</span>
        </div>
        <canvas id="egreCanvas" width="600" height="300"></canvas>
        <div id="egreInfo" class="math-line muted" style="margin-top:8px"></div>
        <div class="info-box" style="margin-top:12px">
            <strong style="color:#818cf8">Pizza theorem:</strong> You stiffen a pizza slice by folding it lengthwise &mdash;
            making one curvature nonzero forces the other toward zero to keep K=0.
            <br><br>
            <strong style="color:#f87171">Map distortion:</strong> You cannot flatten an orange peel (K&gt;0) onto a table
            without distortion &mdash; this is why every world map is distorted.
        </div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════ -->
    <!-- SECTION 4: Gauss-Bonnet Theorem -->
    <!-- ═══════════════════════════════════════════════════════════════ -->
    <h2>Gauss-Bonnet Theorem</h2>
    <div class="panel">
        <h3>Total curvature = 2&pi; &times; Euler characteristic</h3>
        <div class="info-box">
            For any closed surface: &int;&int; K dA = 2&pi; &middot; &chi;
            <br>Sphere: &int;&int; K dA = 4&pi;, &chi; = 2.
            Torus: &int;&int; K dA = 0, &chi; = 0 (positive and negative curvature cancel exactly).
        </div>
        <div class="btn-row" id="gbBtns"></div>
        <canvas id="gbCanvas" width="500" height="300"></canvas>
        <div id="gbInfo" class="math-line muted" style="margin-top:8px"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════ -->
    <!-- SECTION 5: Curvature Deformation Slider -->
    <!-- ═══════════════════════════════════════════════════════════════ -->
    <h2>Curvature Slider &mdash; Deform a Surface</h2>
    <div class="panel">
        <h3>Watch curvature change in real time</h3>
        <div class="slider-row">
            <span class="math-line muted">Bump height:</span>
            <input type="range" id="bumpSlider" min="0" max="100" value="0">
            <span class="slider-label" id="bumpLabel">0.00</span>
        </div>
        <div class="slider-row">
            <span class="math-line muted">Saddle depth:</span>
            <input type="range" id="saddleSlider" min="0" max="100" value="0">
            <span class="slider-label" id="saddleLabel">0.00</span>
        </div>
        <canvas id="deformCanvas" width="600" height="400"></canvas>
        <div id="deformInfo" class="math-line" style="margin-top:8px"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════ -->
    <!-- SECTION 6: Explanation -->
    <!-- ═══════════════════════════════════════════════════════════════ -->
    <div class="explain">
        <div class="explain-name">What have we learnt?</div>
        <div class="explain-text">
            <p><strong style="color:#818cf8">Gaussian curvature K</strong> captures the intrinsic geometry
            of a surface &mdash; what a two-dimensional creature living on the surface could measure without
            knowing about the three-dimensional space around it. At every point, K is the product of the two
            principal curvatures: K = &kappa;&sub1; &middot; &kappa;&sub2;.</p>
            <p><strong style="color:#818cf8">Theorema Egregium</strong> (Gauss, 1827): Bending a surface
            without stretching preserves K. This is why maps distort, pizza folds stiffen, and Pringles
            are saddle-shaped. A cylinder has K=0 everywhere, just like the flat sheet it was bent from.</p>
            <p><strong style="color:#818cf8">The Gauss-Bonnet theorem</strong> links local curvature to
            global topology &mdash; a profound bridge between analysis and topology. No matter how you
            deform a sphere (without tearing), its total curvature remains 4&pi;. For a torus, the positive
            curvature on the outer rim cancels exactly with the negative curvature on the inner rim,
            giving total curvature 0.</p>
            <p><strong style="color:#808098">What can we improve?</strong> Explore the Gauss map (how the
            normal vector sweeps out a region on the unit sphere), geodesic curvature, and how Gaussian
            curvature generalises to Riemannian curvature in higher dimensions &mdash; the foundation
            of general relativity.</p>
        </div>
    </div>
</div>

<script>
/* ═══════════════════════════════════════════════════════════════════
   SHARED UTILITIES
   ═══════════════════════════════════════════════════════════════════ */

/* -- 3D rotation & projection -- */
function rotX(p,a){var c=Math.cos(a),s=Math.sin(a);return[p[0],p[1]*c-p[2]*s,p[1]*s+p[2]*c];}
function rotY(p,a){var c=Math.cos(a),s=Math.sin(a);return[p[0]*c+p[2]*s,p[1],-p[0]*s+p[2]*c];}
function rotZ(p,a){var c=Math.cos(a),s=Math.sin(a);return[p[0]*c-p[1]*s,p[0]*s+p[1]*c,p[2]];}

function project(p,cx,cy,sc){
    /* simple perspective-ish projection */
    var d=5;
    var f=d/(d+p[2]*0.3);
    return[cx+p[0]*sc*f, cy-p[1]*sc*f, p[2]];
}

function rotatePoint(p,ax,ay){
    var r=rotY(p,ay);
    r=rotX(r,ax);
    return r;
}

/* -- Curvature color mapping -- */
function curvatureColor(K,maxK){
    /* Diverging: indigo (#818cf8) for K>0, white for K=0, red (#f87171) for K<0 */
    var t=Math.max(-1,Math.min(1,K/maxK));
    var r,g,b;
    if(t>0){
        /* white to indigo */
        r=Math.round(255-(255-129)*t);
        g=Math.round(255-(255-140)*t);
        b=Math.round(255-(255-248)*t);
    } else {
        /* white to red */
        var s=-t;
        r=Math.round(255-(255-248)*s);
        g=Math.round(255-(255-113)*s);
        b=Math.round(255-(255-113)*s);
    }
    return 'rgb('+r+','+g+','+b+')';
}

function curvatureColorAlpha(K,maxK,alpha){
    var t=Math.max(-1,Math.min(1,K/maxK));
    var r,g,b;
    if(t>0){
        r=Math.round(255-(255-129)*t);
        g=Math.round(255-(255-140)*t);
        b=Math.round(255-(255-248)*t);
    } else {
        var s=-t;
        r=Math.round(255-(255-248)*s);
        g=Math.round(255-(255-113)*s);
        b=Math.round(255-(255-113)*s);
    }
    return 'rgba('+r+','+g+','+b+','+alpha+')';
}

/* Draw color bar */
(function(){
    var cb=document.getElementById('colorBar');
    var cx=cb.getContext('2d');
    for(var i=0;i<200;i++){
        var t=(i/199)*2-1;
        cx.fillStyle=curvatureColor(t,1);
        cx.fillRect(i,0,1,14);
    }
})();


/* ═══════════════════════════════════════════════════════════════════
   SECTION 1: SURFACE GALLERY
   ═══════════════════════════════════════════════════════════════════ */
(function(){
    var cvs=document.getElementById('surfCanvas');
    var ctx=cvs.getContext('2d');
    var W=cvs.width, H=cvs.height;

    var angleX=-0.5, angleY=0.4;
    var dragging=false, lastMx=0, lastMy=0;
    var autoRotate=true;
    var currentSurface='sphere';

    var surfaces={
        sphere:{label:'Sphere',desc:'K = 1/R\u00B2 = 1 everywhere (positive, constant)'},
        cylinder:{label:'Cylinder',desc:'K = 0 everywhere (zero \u2014 it can be unrolled flat!)'},
        saddle:{label:'Saddle',desc:'z = x\u00B2 \u2212 y\u00B2: K < 0 at origin (hyperbolic)'},
        torus:{label:'Torus',desc:'K varies: positive on outer rim, negative on inner rim, zero on top/bottom'},
        bump:{label:'Gaussian Bump',desc:'z = e^(\u2212(x\u00B2+y\u00B2)): K > 0 at peak, K < 0 in the ring'},
        monkey:{label:'Monkey Saddle',desc:'z = x\u00B3 \u2212 3xy\u00B2: exotic saddle with K < 0'}
    };

    var surfOrder=['sphere','cylinder','saddle','torus','bump','monkey'];

    /* Generate surface mesh */
    function genSurface(name){
        var pts=[], faces=[], Kvals=[];
        var nu,nv,i,j;
        if(name==='sphere'){
            nu=30;nv=30;
            for(i=0;i<=nu;i++) for(j=0;j<=nv;j++){
                var u=Math.PI*i/nu;
                var v=2*Math.PI*j/nv;
                pts.push([Math.sin(u)*Math.cos(v), Math.sin(u)*Math.sin(v), Math.cos(u)]);
            }
            for(i=0;i<nu;i++) for(j=0;j<nv;j++){
                var a=i*(nv+1)+j, b=a+1, c=(i+1)*(nv+1)+j, d=c+1;
                faces.push([a,b,d,c]);
                Kvals.push(1.0); /* K=1 for unit sphere */
            }
        } else if(name==='cylinder'){
            nu=1;nv=30;
            var cyl_h=2.0;
            var cyl_n=20;
            for(i=0;i<=cyl_n;i++) for(j=0;j<=nv;j++){
                var u=-cyl_h/2+cyl_h*i/cyl_n;
                var v=2*Math.PI*j/nv;
                pts.push([Math.cos(v), Math.sin(v), u]);
            }
            for(i=0;i<cyl_n;i++) for(j=0;j<nv;j++){
                var a=i*(nv+1)+j, b=a+1, c=(i+1)*(nv+1)+j, d=c+1;
                faces.push([a,b,d,c]);
                Kvals.push(0.0);
            }
        } else if(name==='saddle'){
            nu=25;nv=25;
            var range=1.5;
            for(i=0;i<=nu;i++) for(j=0;j<=nv;j++){
                var x=-range+2*range*i/nu;
                var y=-range+2*range*j/nv;
                var z=x*x-y*y;
                pts.push([x, z*0.5, y]);
            }
            /* compute K for saddle: z=x^2-y^2, K=(fxx*fyy-fxy^2)/(1+fx^2+fy^2)^2 */
            for(i=0;i<nu;i++) for(j=0;j<nv;j++){
                var a=i*(nv+1)+j, b=a+1, c=(i+1)*(nv+1)+j, d=c+1;
                faces.push([a,b,d,c]);
                var cx2=-range+2*range*(i+0.5)/nu;
                var cy2=-range+2*range*(j+0.5)/nv;
                var fx=2*cx2, fy=-2*cy2;
                var fxx=2, fyy=-2, fxy=0;
                var denom=(1+fx*fx+fy*fy);
                var K=(fxx*fyy-fxy*fxy)/(denom*denom);
                Kvals.push(K);
            }
        } else if(name==='torus'){
            var R=1.0, r=0.4;
            nu=40;nv=20;
            for(i=0;i<=nu;i++) for(j=0;j<=nv;j++){
                var u=2*Math.PI*i/nu;
                var v=2*Math.PI*j/nv;
                var x=(R+r*Math.cos(v))*Math.cos(u);
                var y=(R+r*Math.cos(v))*Math.sin(u);
                var z=r*Math.sin(v);
                pts.push([x,z,y]);
            }
            for(i=0;i<nu;i++) for(j=0;j<nv;j++){
                var a=i*(nv+1)+j, b=a+1, c=(i+1)*(nv+1)+j, d=c+1;
                faces.push([a,b,d,c]);
                var v=2*Math.PI*(j+0.5)/nv;
                var K=Math.cos(v)/(r*(R+r*Math.cos(v)));
                Kvals.push(K);
            }
        } else if(name==='bump'){
            nu=30;nv=30;
            var range=2.0;
            for(i=0;i<=nu;i++) for(j=0;j<=nv;j++){
                var x=-range+2*range*i/nu;
                var y=-range+2*range*j/nv;
                var z=Math.exp(-(x*x+y*y));
                pts.push([x, z*0.8, y]);
            }
            for(i=0;i<nu;i++) for(j=0;j<nv;j++){
                var a=i*(nv+1)+j, b=a+1, c=(i+1)*(nv+1)+j, d=c+1;
                faces.push([a,b,d,c]);
                var cx3=-range+2*range*(i+0.5)/nu;
                var cy3=-range+2*range*(j+0.5)/nv;
                var r2=cx3*cx3+cy3*cy3;
                var ez=Math.exp(-r2);
                var fx=-2*cx3*ez, fy=-2*cy3*ez;
                var fxx=(-2+4*cx3*cx3)*ez;
                var fyy=(-2+4*cy3*cy3)*ez;
                var fxy=4*cx3*cy3*ez;
                var denom=(1+fx*fx+fy*fy);
                var K=(fxx*fyy-fxy*fxy)/(denom*denom);
                Kvals.push(K);
            }
        } else if(name==='monkey'){
            nu=30;nv=30;
            var range=1.2;
            for(i=0;i<=nu;i++) for(j=0;j<=nv;j++){
                var x=-range+2*range*i/nu;
                var y=-range+2*range*j/nv;
                var z=x*x*x-3*x*y*y;
                pts.push([x, z*0.3, y]);
            }
            for(i=0;i<nu;i++) for(j=0;j<nv;j++){
                var a=i*(nv+1)+j, b=a+1, c=(i+1)*(nv+1)+j, d=c+1;
                faces.push([a,b,d,c]);
                var cx4=-range+2*range*(i+0.5)/nu;
                var cy4=-range+2*range*(j+0.5)/nv;
                var fx=3*cx4*cx4-3*cy4*cy4;
                var fy=-6*cx4*cy4;
                var fxx=6*cx4;
                var fyy=-6*cx4;
                var fxy=-6*cy4;
                var denom=(1+fx*fx+fy*fy);
                var K=(fxx*fyy-fxy*fxy)/(denom*denom);
                Kvals.push(K);
            }
        }
        return{pts:pts,faces:faces,Kvals:Kvals};
    }

    var mesh=genSurface('sphere');

    function renderSurf(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle='#0a0a1a';
        ctx.fillRect(0,0,W,H);

        var m=mesh;
        var sc=120;
        if(currentSurface==='torus') sc=130;
        if(currentSurface==='saddle') sc=80;
        if(currentSurface==='bump') sc=75;
        if(currentSurface==='monkey') sc=85;

        /* Transform all points */
        var tp=[];
        for(var i=0;i<m.pts.length;i++){
            var r=rotatePoint(m.pts[i],angleX,angleY);
            tp.push(r);
        }

        /* Determine K range for color mapping */
        var maxK=0.1;
        for(var i=0;i<m.Kvals.length;i++){
            var ak=Math.abs(m.Kvals[i]);
            if(ak>maxK) maxK=ak;
        }
        maxK=Math.min(maxK,2.0);

        /* Build face list with depth */
        var faceList=[];
        for(var i=0;i<m.faces.length;i++){
            var f=m.faces[i];
            var cz=(tp[f[0]][2]+tp[f[1]][2]+tp[f[2]][2]+tp[f[3]][2])/4;
            faceList.push({idx:i,z:cz});
        }
        faceList.sort(function(a,b){return a.z-b.z;});

        /* Render faces (painter's algorithm) */
        for(var fi=0;fi<faceList.length;fi++){
            var idx=faceList[fi].idx;
            var f=m.faces[idx];
            var K=m.Kvals[idx];

            /* Project */
            var p0=project(tp[f[0]],W/2,H/2,sc);
            var p1=project(tp[f[1]],W/2,H/2,sc);
            var p2=project(tp[f[2]],W/2,H/2,sc);
            var p3=project(tp[f[3]],W/2,H/2,sc);

            /* Backface normal (for subtle shading) */
            var nx=(p1[0]-p0[0])*(p2[1]-p0[1])-(p1[1]-p0[1])*(p2[0]-p0[0]);
            var shade=nx>0?0.7:1.0;

            /* Fill with curvature color */
            var col=curvatureColor(K,maxK);
            ctx.fillStyle=col;
            ctx.globalAlpha=0.55*shade;
            ctx.beginPath();
            ctx.moveTo(p0[0],p0[1]);
            ctx.lineTo(p1[0],p1[1]);
            ctx.lineTo(p2[0],p2[1]);
            ctx.lineTo(p3[0],p3[1]);
            ctx.closePath();
            ctx.fill();

            /* Wireframe */
            ctx.globalAlpha=0.25*shade;
            ctx.strokeStyle='rgba(255,255,255,0.4)';
            ctx.lineWidth=0.5;
            ctx.stroke();
        }

        ctx.globalAlpha=1;

        /* Info label */
        ctx.font='13px Georgia';
        ctx.fillStyle='#818cf8';
        ctx.textAlign='left';
        ctx.textBaseline='top';
        ctx.fillText(surfaces[currentSurface].label,16,16);
        ctx.font='11px Georgia';
        ctx.fillStyle='#808098';
        ctx.fillText('Drag to rotate',16,34);

        document.getElementById('surfInfo').textContent=surfaces[currentSurface].desc;
    }

    /* Buttons */
    function renderBtns(){
        var c=document.getElementById('surfBtns');
        c.innerHTML=surfOrder.map(function(s){
            return '<button class="btn'+(s===currentSurface?' active':'')+'" data-s="'+s+'">'+surfaces[s].label+'</button>';
        }).join('');
        c.querySelectorAll('.btn').forEach(function(b){
            b.addEventListener('click',function(){
                currentSurface=b.dataset.s;
                mesh=genSurface(currentSurface);
                renderBtns();
                renderSurf();
            });
        });
    }
    renderBtns();

    /* Mouse drag */
    cvs.addEventListener('mousedown',function(e){
        dragging=true;autoRotate=false;
        lastMx=e.clientX;lastMy=e.clientY;
    });
    window.addEventListener('mousemove',function(e){
        if(!dragging) return;
        var dx=e.clientX-lastMx, dy=e.clientY-lastMy;
        angleY+=dx*0.008;
        angleX+=dy*0.008;
        lastMx=e.clientX;lastMy=e.clientY;
        renderSurf();
    });
    window.addEventListener('mouseup',function(){dragging=false;});

    /* Touch drag */
    cvs.addEventListener('touchstart',function(e){
        e.preventDefault();dragging=true;autoRotate=false;
        lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;
    },{passive:false});
    cvs.addEventListener('touchmove',function(e){
        e.preventDefault();if(!dragging) return;
        var dx=e.touches[0].clientX-lastMx, dy=e.touches[0].clientY-lastMy;
        angleY+=dx*0.008;angleX+=dy*0.008;
        lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;
        renderSurf();
    },{passive:false});
    cvs.addEventListener('touchend',function(){dragging=false;});

    /* Auto-rotation */
    function animSurf(){
        if(autoRotate){
            angleY+=0.005;
            renderSurf();
        }
        requestAnimationFrame(animSurf);
    }
    renderSurf();
    requestAnimationFrame(animSurf);
})();


/* ═══════════════════════════════════════════════════════════════════
   SECTION 2: PRINCIPAL CURVATURES
   ═══════════════════════════════════════════════════════════════════ */
(function(){
    var cvs=document.getElementById('princCanvas');
    var ctx=cvs.getContext('2d');
    var W=cvs.width, H=cvs.height;
    var sliderU=document.getElementById('princU');
    var sliderV=document.getElementById('princV');
    var labelU=document.getElementById('princULabel');
    var labelV=document.getElementById('princVLabel');

    var angleX=-0.5, angleY=0.5;
    var dragging=false, lastMx=0, lastMy=0;

    /* Surface: z = x^2 - y^2 (saddle) for rich curvature variation */
    var range=1.5;
    var N=25;

    function saddleZ(x,y){ return x*x-y*y; }

    function computeK(x,y){
        var fx=2*x, fy=-2*y;
        var fxx=2, fyy=-2, fxy=0;
        var d=(1+fx*fx+fy*fy);
        return (fxx*fyy-fxy*fxy)/(d*d);
    }

    function computePrincipal(x,y){
        var fx=2*x, fy=-2*y;
        var fxx=2, fyy=-2, fxy=0;
        var d2=(1+fx*fx+fy*fy);
        var d=Math.sqrt(d2);
        /* Mean curvature H and Gaussian curvature K from first/second fundamental forms */
        var E=1+fx*fx, F=fx*fy, G=1+fy*fy;
        var n1=-fx/d, n2=-fy/d, n3=1/d;
        var L=fxx/d, M=fxy/d, N2=fyy/d;
        var K=(L*N2-M*M)/(E*G-F*F);
        var H2=(E*N2-2*F*M+G*L)/(E*G-F*F);
        var disc=H2*H2/4-K;
        if(disc<0) disc=0;
        var k1=H2/2+Math.sqrt(disc);
        var k2=H2/2-Math.sqrt(disc);

        /* Principal directions (eigenvectors of the shape operator) */
        /* For z=f(x,y), the principal directions in the tangent plane */
        var dir1, dir2;
        if(Math.abs(M)<1e-10){
            if(Math.abs(L-k1*E)<Math.abs(N2-k1*G)){
                dir1=[1,0];
            } else {
                dir1=[0,1];
            }
        } else {
            dir1=[-(N2-k1*G),M*1];
            var len=Math.sqrt(dir1[0]*dir1[0]+dir1[1]*dir1[1]);
            if(len>1e-10){dir1[0]/=len;dir1[1]/=len;}
        }
        /* Second direction is perpendicular */
        dir2=[-dir1[1],dir1[0]];

        return{k1:k1,k2:k2,K:K,H:H2/2,dir1:dir1,dir2:dir2};
    }

    function render(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle='#0a0a1a';
        ctx.fillRect(0,0,W,H);

        var uParam=parseFloat(sliderU.value)/100;
        var vParam=parseFloat(sliderV.value)/100;
        var px=-range+2*range*uParam;
        var py=-range+2*range*vParam;
        labelU.textContent=px.toFixed(2);
        labelV.textContent=py.toFixed(2);

        var sc=70;
        var centerX=W*0.45, centerY=H*0.5;

        /* Draw surface mesh */
        var pts=[];
        for(var i=0;i<=N;i++) for(var j=0;j<=N;j++){
            var x=-range+2*range*i/N;
            var y=-range+2*range*j/N;
            var z=saddleZ(x,y)*0.5;
            pts.push([x,z,y]);
        }

        /* Transform */
        var tp=[];
        for(var i=0;i<pts.length;i++){
            tp.push(rotatePoint(pts[i],angleX,angleY));
        }

        /* Faces with depth sort */
        var faces=[];
        for(var i=0;i<N;i++) for(var j=0;j<N;j++){
            var a=i*(N+1)+j, b=a+1, c=(i+1)*(N+1)+j, d=c+1;
            var cz=(tp[a][2]+tp[b][2]+tp[c][2]+tp[d][2])/4;
            var cx2=-range+2*range*(i+0.5)/N;
            var cy2=-range+2*range*(j+0.5)/N;
            var K=computeK(cx2,cy2);
            faces.push({verts:[a,b,d,c],z:cz,K:K});
        }
        faces.sort(function(a,b){return a.z-b.z;});

        for(var fi=0;fi<faces.length;fi++){
            var f=faces[fi];
            var p0=project(tp[f.verts[0]],centerX,centerY,sc);
            var p1=project(tp[f.verts[1]],centerX,centerY,sc);
            var p2=project(tp[f.verts[2]],centerX,centerY,sc);
            var p3=project(tp[f.verts[3]],centerX,centerY,sc);

            ctx.fillStyle=curvatureColorAlpha(f.K,1.5,0.4);
            ctx.beginPath();
            ctx.moveTo(p0[0],p0[1]);ctx.lineTo(p1[0],p1[1]);
            ctx.lineTo(p2[0],p2[1]);ctx.lineTo(p3[0],p3[1]);
            ctx.closePath();ctx.fill();

            ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.lineWidth=0.5;
            ctx.stroke();
        }

        /* Analysis point */
        var pz=saddleZ(px,py)*0.5;
        var ap=rotatePoint([px,pz,py],angleX,angleY);
        var sp=project(ap,centerX,centerY,sc);

        /* Principal curvatures */
        var princ=computePrincipal(px,py);

        /* Draw principal direction arrows */
        var arrowLen=0.6;
        for(var di=0;di<2;di++){
            var dir=di===0?princ.dir1:princ.dir2;
            var col=di===0?'#818cf8':'#f87171';
            var kval=di===0?princ.k1:princ.k2;
            var dx=dir[0]*arrowLen;
            var dy=dir[1]*arrowLen;
            /* Tangent direction in 3D: (dx, fx*dx+fy*dy, dy) scaled */
            var fx=2*px, fy=-2*py;
            var tz=((fx*dx+fy*dy)*0.5);
            var ep=rotatePoint([px+dx, pz+tz, py+dy],angleX,angleY);
            var sep=project(ep,centerX,centerY,sc);
            var em=rotatePoint([px-dx, pz-tz, py-dy],angleX,angleY);
            var sem=project(em,centerX,centerY,sc);

            ctx.strokeStyle=col;ctx.lineWidth=2.5;ctx.lineCap='round';
            ctx.beginPath();ctx.moveTo(sem[0],sem[1]);ctx.lineTo(sep[0],sep[1]);ctx.stroke();

            /* Arrow head */
            var ang=Math.atan2(sep[1]-sp[1],sep[0]-sp[0]);
            ctx.fillStyle=col;ctx.beginPath();
            ctx.moveTo(sep[0],sep[1]);
            ctx.lineTo(sep[0]-8*Math.cos(ang-0.35),sep[1]-8*Math.sin(ang-0.35));
            ctx.lineTo(sep[0]-8*Math.cos(ang+0.35),sep[1]-8*Math.sin(ang+0.35));
            ctx.closePath();ctx.fill();

            /* Label */
            ctx.font='11px Courier New';ctx.fillStyle=col;
            ctx.textAlign='left';ctx.textBaseline='bottom';
            ctx.fillText((di===0?'\u03BA\u2081':'  \u03BA\u2082')+'='+kval.toFixed(3),sep[0]+6,sep[1]-4);
        }

        /* Point dot */
        ctx.fillStyle='#fff';
        ctx.beginPath();ctx.arc(sp[0],sp[1],5,0,Math.PI*2);ctx.fill();
        ctx.fillStyle='#818cf8';
        ctx.beginPath();ctx.arc(sp[0],sp[1],3,0,Math.PI*2);ctx.fill();

        /* Normal curvature polar plot (right side) */
        var plotCX=W-110, plotCY=H/2;
        var plotR=80;

        ctx.strokeStyle='rgba(255,255,255,0.08)';ctx.lineWidth=1;
        ctx.beginPath();ctx.arc(plotCX,plotCY,plotR,0,Math.PI*2);ctx.stroke();
        ctx.beginPath();ctx.moveTo(plotCX-plotR-10,plotCY);ctx.lineTo(plotCX+plotR+10,plotCY);ctx.stroke();
        ctx.beginPath();ctx.moveTo(plotCX,plotCY-plotR-10);ctx.lineTo(plotCX,plotCY+plotR+10);ctx.stroke();

        ctx.font='10px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';
        ctx.fillText('Normal curvature',plotCX,plotCY-plotR-16);
        ctx.fillText('polar plot',plotCX,plotCY-plotR-4);

        /* Draw curvature in all directions */
        var maxKappa=Math.max(Math.abs(princ.k1),Math.abs(princ.k2),0.01);
        ctx.beginPath();
        for(var ai=0;ai<=360;ai++){
            var theta=ai*Math.PI/180;
            var kn=princ.k1*Math.cos(theta)*Math.cos(theta)+princ.k2*Math.sin(theta)*Math.sin(theta);
            var rr=Math.abs(kn)/maxKappa*plotR*0.8;
            var col2=kn>=0?'#818cf8':'#f87171';
            var sx2=plotCX+rr*Math.cos(theta);
            var sy2=plotCY-rr*Math.sin(theta);
            if(ai===0) ctx.moveTo(sx2,sy2);
            else ctx.lineTo(sx2,sy2);
        }
        ctx.closePath();
        ctx.strokeStyle='rgba(129,140,248,0.6)';ctx.lineWidth=1.5;ctx.stroke();
        ctx.fillStyle='rgba(129,140,248,0.08)';ctx.fill();

        /* Classification */
        var classification;
        if(princ.K>0.001) classification='Elliptic point (dome \u2014 both curvatures same sign)';
        else if(princ.K<-0.001) classification='Hyperbolic point (saddle \u2014 opposite signs)';
        else classification='Parabolic point (ridge \u2014 one curvature zero)';

        /* Info panel */
        var info=document.getElementById('princInfo');
        info.innerHTML=
            '<span style="color:#818cf8">\u03BA\u2081 = '+princ.k1.toFixed(4)+'</span> &ensp; '+
            '<span style="color:#f87171">\u03BA\u2082 = '+princ.k2.toFixed(4)+'</span><br>'+
            'K = \u03BA\u2081 \u00B7 \u03BA\u2082 = <strong style="color:#e0e0e0">'+princ.K.toFixed(4)+'</strong> &ensp; '+
            'H = (\u03BA\u2081 + \u03BA\u2082)/2 = '+princ.H.toFixed(4)+'<br>'+
            '<span style="color:#808098">'+classification+'</span>';

        /* Labels */
        ctx.font='12px Georgia';ctx.fillStyle='#818cf8';
        ctx.textAlign='left';ctx.textBaseline='top';
        ctx.fillText('Surface: z = x\u00B2 \u2212 y\u00B2',12,12);
        ctx.font='11px Georgia';ctx.fillStyle='#808098';
        ctx.fillText('Drag to rotate | Sliders to move analysis point',12,28);
    }

    /* Mouse drag */
    cvs.addEventListener('mousedown',function(e){
        dragging=true;lastMx=e.clientX;lastMy=e.clientY;
    });
    window.addEventListener('mousemove',function(e){
        if(!dragging) return;
        var dx=e.clientX-lastMx, dy=e.clientY-lastMy;
        angleY+=dx*0.008;angleX+=dy*0.008;
        lastMx=e.clientX;lastMy=e.clientY;render();
    });
    window.addEventListener('mouseup',function(){dragging=false;});

    cvs.addEventListener('touchstart',function(e){
        e.preventDefault();dragging=true;
        lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;
    },{passive:false});
    cvs.addEventListener('touchmove',function(e){
        e.preventDefault();if(!dragging) return;
        var dx=e.touches[0].clientX-lastMx, dy=e.touches[0].clientY-lastMy;
        angleY+=dx*0.008;angleX+=dy*0.008;
        lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;render();
    },{passive:false});
    cvs.addEventListener('touchend',function(){dragging=false;});

    sliderU.addEventListener('input',render);
    sliderV.addEventListener('input',render);
    render();
})();


/* ═══════════════════════════════════════════════════════════════════
   SECTION 3: THEOREMA EGREGIUM
   ═══════════════════════════════════════════════════════════════════ */
(function(){
    var cvs=document.getElementById('egreCanvas');
    var ctx=cvs.getContext('2d');
    var W=cvs.width, H=cvs.height;
    var slider=document.getElementById('bendSlider');
    var label=document.getElementById('bendLabel');
    var info=document.getElementById('egreInfo');

    var angleX=-0.35, angleY=0.6;
    var dragging=false, lastMx=0, lastMy=0;

    function render(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);

        var t=parseFloat(slider.value)/100; /* 0=flat, 1=full cylinder */
        if(t<0.05) label.textContent='Flat';
        else if(t>0.95) label.textContent='Cylinder';
        else label.textContent=(t*100).toFixed(0)+'%';

        var sc=100;
        var centerX=W/2, centerY=H/2;

        /* A flat sheet bending into a cylinder
           Parametric: for bend parameter t,
           the sheet width maps onto an arc of angle t*2pi*0.7
           x -> R*sin(theta), z -> R*(1-cos(theta)) where theta = u * bendAngle
        */
        var sheetW=2.0, sheetH=1.5;
        var nu=20, nv=12;
        var bendAngle=t*Math.PI*1.4; /* max bend: about 250 degrees */
        var R=bendAngle>0.01?sheetW/bendAngle:1000;

        var pts=[];
        for(var i=0;i<=nu;i++){
            var u=i/nu; /* 0 to 1 across width */
            for(var j=0;j<=nv;j++){
                var v=-sheetH/2+sheetH*j/nv; /* height along cylinder axis */
                var theta=u*bendAngle;
                var x,y,z;
                if(bendAngle>0.01){
                    x=R*Math.sin(theta)-R*Math.sin(bendAngle/2);
                    z=R*(1-Math.cos(theta))-R*(1-Math.cos(bendAngle/2));
                } else {
                    x=-sheetW/2+sheetW*u;
                    z=0;
                }
                y=v;
                pts.push([x,y,z]);
            }
        }

        /* Transform */
        var tp=[];
        for(var i=0;i<pts.length;i++){
            tp.push(rotatePoint(pts[i],angleX,angleY));
        }

        /* Faces */
        var faces=[];
        for(var i=0;i<nu;i++) for(var j=0;j<nv;j++){
            var a=i*(nv+1)+j, b=a+1, c=(i+1)*(nv+1)+j, d=c+1;
            var cz=(tp[a][2]+tp[b][2]+tp[c][2]+tp[d][2])/4;
            faces.push({verts:[a,b,d,c],z:cz});
        }
        faces.sort(function(a,b){return a.z-b.z;});

        for(var fi=0;fi<faces.length;fi++){
            var f=faces[fi];
            var p0=project(tp[f.verts[0]],centerX,centerY,sc);
            var p1=project(tp[f.verts[1]],centerX,centerY,sc);
            var p2=project(tp[f.verts[2]],centerX,centerY,sc);
            var p3=project(tp[f.verts[3]],centerX,centerY,sc);

            /* All faces K=0 regardless of bend! Color them white/light gray */
            ctx.fillStyle='rgba(200,200,220,0.35)';
            ctx.beginPath();
            ctx.moveTo(p0[0],p0[1]);ctx.lineTo(p1[0],p1[1]);
            ctx.lineTo(p2[0],p2[1]);ctx.lineTo(p3[0],p3[1]);
            ctx.closePath();ctx.fill();

            ctx.strokeStyle='rgba(255,255,255,0.2)';ctx.lineWidth=0.5;ctx.stroke();
        }

        /* K=0 label */
        ctx.font='18px Georgia';ctx.fillStyle='#818cf8';
        ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText('K = 0',centerX,H-36);
        ctx.font='12px Georgia';ctx.fillStyle='#808098';
        ctx.fillText('always, regardless of bending',centerX,H-18);

        /* Left/right labels */
        ctx.font='11px Georgia';ctx.fillStyle='#808098';ctx.textAlign='left';ctx.textBaseline='top';
        ctx.fillText('Drag to rotate',12,12);

        info.textContent='Bend: '+(t*100).toFixed(0)+'% \u2014 K remains 0. Bending without stretching preserves Gaussian curvature.';
    }

    cvs.addEventListener('mousedown',function(e){
        dragging=true;lastMx=e.clientX;lastMy=e.clientY;
    });
    window.addEventListener('mousemove',function(e){
        if(!dragging) return;
        var dx=e.clientX-lastMx, dy=e.clientY-lastMy;
        angleY+=dx*0.008;angleX+=dy*0.008;
        lastMx=e.clientX;lastMy=e.clientY;render();
    });
    window.addEventListener('mouseup',function(){dragging=false;});

    cvs.addEventListener('touchstart',function(e){
        e.preventDefault();dragging=true;
        lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;
    },{passive:false});
    cvs.addEventListener('touchmove',function(e){
        e.preventDefault();if(!dragging) return;
        var dx=e.touches[0].clientX-lastMx, dy=e.touches[0].clientY-lastMy;
        angleY+=dx*0.008;angleX+=dy*0.008;
        lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;render();
    },{passive:false});
    cvs.addEventListener('touchend',function(){dragging=false;});

    slider.addEventListener('input',render);
    render();
})();


/* ═══════════════════════════════════════════════════════════════════
   SECTION 4: GAUSS-BONNET THEOREM
   ═══════════════════════════════════════════════════════════════════ */
(function(){
    var cvs=document.getElementById('gbCanvas');
    var ctx=cvs.getContext('2d');
    var W=cvs.width, H=cvs.height;

    var currentGB='sphere';
    var angleX=-0.4, angleY=0.5;
    var dragging=false, lastMx=0, lastMy=0;
    var autoRotate=true;

    var gbSurfaces={
        sphere:{label:'Sphere',chi:2,total:'4\u03C0',desc:'\u222C K dA = 4\u03C0, \u03C7 = 2. Curvature is uniformly positive.'},
        torus:{label:'Torus',chi:0,total:'0',desc:'\u222C K dA = 0, \u03C7 = 0. Positive outer rim cancels negative inner rim exactly.'},
        ellipsoid:{label:'Ellipsoid',chi:2,total:'4\u03C0',desc:'\u222C K dA = 4\u03C0, \u03C7 = 2. Deformed sphere \u2014 same total curvature!'},
        potato:{label:'Potato',chi:2,total:'4\u03C0',desc:'\u222C K dA = 4\u03C0, \u03C7 = 2. No matter how you deform a sphere, the total is 4\u03C0.'}
    };
    var gbOrder=['sphere','torus','ellipsoid','potato'];

    function genGB(name){
        var pts=[],faces=[],Kvals=[];
        var nu,nv;
        if(name==='sphere'){
            nu=30;nv=30;
            for(var i=0;i<=nu;i++) for(var j=0;j<=nv;j++){
                var u=Math.PI*i/nu, v=2*Math.PI*j/nv;
                pts.push([Math.sin(u)*Math.cos(v), Math.sin(u)*Math.sin(v), Math.cos(u)]);
            }
            for(var i=0;i<nu;i++) for(var j=0;j<nv;j++){
                var a=i*(nv+1)+j,b=a+1,c=(i+1)*(nv+1)+j,d=c+1;
                faces.push([a,b,d,c]);Kvals.push(1.0);
            }
        } else if(name==='torus'){
            var R=1.0,r=0.4;nu=40;nv=20;
            for(var i=0;i<=nu;i++) for(var j=0;j<=nv;j++){
                var u=2*Math.PI*i/nu, v=2*Math.PI*j/nv;
                pts.push([(R+r*Math.cos(v))*Math.cos(u), r*Math.sin(v), (R+r*Math.cos(v))*Math.sin(u)]);
            }
            for(var i=0;i<nu;i++) for(var j=0;j<nv;j++){
                var a=i*(nv+1)+j,b=a+1,c=(i+1)*(nv+1)+j,d=c+1;
                faces.push([a,b,d,c]);
                var v=2*Math.PI*(j+0.5)/nv;
                Kvals.push(Math.cos(v)/(r*(R+r*Math.cos(v))));
            }
        } else if(name==='ellipsoid'){
            nu=30;nv=30;
            var ax=1.4, ay=0.7, az=1.0;
            for(var i=0;i<=nu;i++) for(var j=0;j<=nv;j++){
                var u=Math.PI*i/nu, v=2*Math.PI*j/nv;
                pts.push([ax*Math.sin(u)*Math.cos(v), az*Math.cos(u), ay*Math.sin(u)*Math.sin(v)]);
            }
            for(var i=0;i<nu;i++) for(var j=0;j<nv;j++){
                var a=i*(nv+1)+j,b=a+1,c=(i+1)*(nv+1)+j,d=c+1;
                faces.push([a,b,d,c]);
                /* K for ellipsoid: always positive but varies */
                var u=Math.PI*(i+0.5)/nu, v=2*Math.PI*(j+0.5)/nv;
                var su=Math.sin(u), cu=Math.cos(u), sv=Math.sin(v), cv=Math.cos(v);
                var h=ax*ax*ay*ay*cu*cu+az*az*(ay*ay*cv*cv+ax*ax*sv*sv)*su*su;
                var K2=(ax*ay*az)*(ax*ay*az)/(h*h);
                Kvals.push(K2);
            }
        } else { /* potato: sphere with bumps */
            nu=30;nv=30;
            for(var i=0;i<=nu;i++) for(var j=0;j<=nv;j++){
                var u=Math.PI*i/nu, v=2*Math.PI*j/nv;
                var rb=1+0.15*Math.sin(3*u)*Math.cos(2*v)+0.1*Math.cos(5*u)*Math.sin(3*v)+0.08*Math.sin(4*v);
                pts.push([rb*Math.sin(u)*Math.cos(v), rb*Math.cos(u), rb*Math.sin(u)*Math.sin(v)]);
            }
            for(var i=0;i<nu;i++) for(var j=0;j<nv;j++){
                var a=i*(nv+1)+j,b=a+1,c=(i+1)*(nv+1)+j,d=c+1;
                faces.push([a,b,d,c]);
                /* Approximate K numerically */
                var u=Math.PI*(i+0.5)/nu, v=2*Math.PI*(j+0.5)/nv;
                var eps=0.01;
                function potatoR(uu,vv){return 1+0.15*Math.sin(3*uu)*Math.cos(2*vv)+0.1*Math.cos(5*uu)*Math.sin(3*vv)+0.08*Math.sin(4*vv);}
                function potatoP(uu,vv){var rr=potatoR(uu,vv);return[rr*Math.sin(uu)*Math.cos(vv),rr*Math.cos(uu),rr*Math.sin(uu)*Math.sin(vv)];}
                /* Just use a reasonable K estimate based on curvature near sphere */
                var rHere=potatoR(u,v);
                Kvals.push(1/(rHere*rHere)*0.8+0.2*Math.sin(3*u)*Math.cos(2*v));
            }
        }
        return{pts:pts,faces:faces,Kvals:Kvals};
    }

    var gbMesh=genGB('sphere');

    function renderGB(){
        ctx.clearRect(0,0,W,H);ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);
        var m=gbMesh;
        var sc=100;
        if(currentGB==='torus') sc=110;

        var tp=[];
        for(var i=0;i<m.pts.length;i++) tp.push(rotatePoint(m.pts[i],angleX,angleY));

        var maxK=0.1;
        for(var i=0;i<m.Kvals.length;i++){var ak=Math.abs(m.Kvals[i]);if(ak>maxK) maxK=ak;}
        maxK=Math.min(maxK,3.0);

        var fl=[];
        for(var i=0;i<m.faces.length;i++){
            var f=m.faces[i];
            var cz=(tp[f[0]][2]+tp[f[1]][2]+tp[f[2]][2]+tp[f[3]][2])/4;
            fl.push({idx:i,z:cz});
        }
        fl.sort(function(a,b){return a.z-b.z;});

        for(var fi=0;fi<fl.length;fi++){
            var idx=fl[fi].idx;
            var f=m.faces[idx];
            var K=m.Kvals[idx];
            var p0=project(tp[f[0]],W/2,H/2,sc);
            var p1=project(tp[f[1]],W/2,H/2,sc);
            var p2=project(tp[f[2]],W/2,H/2,sc);
            var p3=project(tp[f[3]],W/2,H/2,sc);

            var nx=(p1[0]-p0[0])*(p2[1]-p0[1])-(p1[1]-p0[1])*(p2[0]-p0[0]);
            var shade=nx>0?0.65:1.0;
            ctx.fillStyle=curvatureColor(K,maxK);
            ctx.globalAlpha=0.5*shade;
            ctx.beginPath();
            ctx.moveTo(p0[0],p0[1]);ctx.lineTo(p1[0],p1[1]);
            ctx.lineTo(p2[0],p2[1]);ctx.lineTo(p3[0],p3[1]);
            ctx.closePath();ctx.fill();
            ctx.globalAlpha=0.2*shade;
            ctx.strokeStyle='rgba(255,255,255,0.4)';ctx.lineWidth=0.5;ctx.stroke();
        }
        ctx.globalAlpha=1;

        /* Label */
        var s=gbSurfaces[currentGB];
        ctx.font='14px Georgia';ctx.fillStyle='#818cf8';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText('\u222C K dA = '+s.total+'   |   \u03C7 = '+s.chi,W/2,H-10);

        document.getElementById('gbInfo').textContent=s.desc;
    }

    /* Buttons */
    function renderGBBtns(){
        var c=document.getElementById('gbBtns');
        c.innerHTML=gbOrder.map(function(s){
            return '<button class="btn'+(s===currentGB?' active':'')+'" data-s="'+s+'">'+gbSurfaces[s].label+'</button>';
        }).join('');
        c.querySelectorAll('.btn').forEach(function(b){
            b.addEventListener('click',function(){
                currentGB=b.dataset.s;gbMesh=genGB(currentGB);
                renderGBBtns();renderGB();
            });
        });
    }
    renderGBBtns();

    cvs.addEventListener('mousedown',function(e){dragging=true;autoRotate=false;lastMx=e.clientX;lastMy=e.clientY;});
    window.addEventListener('mousemove',function(e){
        if(!dragging) return;
        angleY+=(e.clientX-lastMx)*0.008;angleX+=(e.clientY-lastMy)*0.008;
        lastMx=e.clientX;lastMy=e.clientY;renderGB();
    });
    window.addEventListener('mouseup',function(){dragging=false;});

    cvs.addEventListener('touchstart',function(e){e.preventDefault();dragging=true;autoRotate=false;lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;},{passive:false});
    cvs.addEventListener('touchmove',function(e){e.preventDefault();if(!dragging) return;angleY+=(e.touches[0].clientX-lastMx)*0.008;angleX+=(e.touches[0].clientY-lastMy)*0.008;lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;renderGB();},{passive:false});
    cvs.addEventListener('touchend',function(){dragging=false;});

    function animGB(){
        if(autoRotate){angleY+=0.004;renderGB();}
        requestAnimationFrame(animGB);
    }
    renderGB();requestAnimationFrame(animGB);
})();


/* ═══════════════════════════════════════════════════════════════════
   SECTION 5: CURVATURE DEFORMATION SLIDER
   ═══════════════════════════════════════════════════════════════════ */
(function(){
    var cvs=document.getElementById('deformCanvas');
    var ctx=cvs.getContext('2d');
    var W=cvs.width, H=cvs.height;

    var bumpSlider=document.getElementById('bumpSlider');
    var saddleSlider=document.getElementById('saddleSlider');
    var bumpLabel=document.getElementById('bumpLabel');
    var saddleLabel=document.getElementById('saddleLabel');

    var angleX=-0.5, angleY=0.5;
    var dragging=false, lastMx=0, lastMy=0;

    function render(){
        ctx.clearRect(0,0,W,H);ctx.fillStyle='#0a0a1a';ctx.fillRect(0,0,W,H);

        var bumpH=parseFloat(bumpSlider.value)/100*2.0;
        var saddleD=parseFloat(saddleSlider.value)/100*1.5;
        bumpLabel.textContent=bumpH.toFixed(2);
        saddleLabel.textContent=saddleD.toFixed(2);

        var range=2.0;
        var N=28;
        var sc=75;
        var centerX=W/2, centerY=H/2;

        /* Surface: z = bumpH * exp(-(x^2+y^2)) + saddleD * (x^2 - y^2) */
        function surfZ(x,y){
            return bumpH*Math.exp(-(x*x+y*y))+saddleD*(x*x-y*y);
        }

        function computeKDeform(x,y){
            var eps=0.02;
            /* Numerical central differences */
            var f0=surfZ(x,y);
            var fxp=surfZ(x+eps,y), fxm=surfZ(x-eps,y);
            var fyp=surfZ(x,y+eps), fym=surfZ(x,y-eps);
            var fxpyp=surfZ(x+eps,y+eps), fxmym=surfZ(x-eps,y-eps);
            var fxpym=surfZ(x+eps,y-eps), fxmyp=surfZ(x-eps,y+eps);

            var fx=(fxp-fxm)/(2*eps);
            var fy=(fyp-fym)/(2*eps);
            var fxx=(fxp-2*f0+fxm)/(eps*eps);
            var fyy=(fyp-2*f0+fym)/(eps*eps);
            var fxy=(fxpyp-fxpym-fxmyp+fxmym)/(4*eps*eps);

            var d=(1+fx*fx+fy*fy);
            return (fxx*fyy-fxy*fxy)/(d*d);
        }

        /* Generate mesh */
        var pts=[];
        for(var i=0;i<=N;i++) for(var j=0;j<=N;j++){
            var x=-range+2*range*i/N;
            var y=-range+2*range*j/N;
            var z=surfZ(x,y)*0.5;
            pts.push([x,z,y]);
        }

        var tp=[];
        for(var i=0;i<pts.length;i++) tp.push(rotatePoint(pts[i],angleX,angleY));

        var faces=[];
        for(var i=0;i<N;i++) for(var j=0;j<N;j++){
            var a=i*(N+1)+j, b=a+1, c=(i+1)*(N+1)+j, d=c+1;
            var cz=(tp[a][2]+tp[b][2]+tp[c][2]+tp[d][2])/4;
            var cx2=-range+2*range*(i+0.5)/N;
            var cy2=-range+2*range*(j+0.5)/N;
            var K=computeKDeform(cx2,cy2);
            faces.push({verts:[a,b,d,c],z:cz,K:K});
        }
        faces.sort(function(a,b){return a.z-b.z;});

        /* Determine K scale */
        var maxK2=0.1;
        for(var fi=0;fi<faces.length;fi++){
            var ak=Math.abs(faces[fi].K);if(ak>maxK2) maxK2=ak;
        }
        maxK2=Math.min(maxK2,2.0);

        for(var fi=0;fi<faces.length;fi++){
            var f=faces[fi];
            var p0=project(tp[f.verts[0]],centerX,centerY,sc);
            var p1=project(tp[f.verts[1]],centerX,centerY,sc);
            var p2=project(tp[f.verts[2]],centerX,centerY,sc);
            var p3=project(tp[f.verts[3]],centerX,centerY,sc);

            var nx=(p1[0]-p0[0])*(p2[1]-p0[1])-(p1[1]-p0[1])*(p2[0]-p0[0]);
            var shade=nx>0?0.65:1.0;

            ctx.fillStyle=curvatureColor(f.K,maxK2);
            ctx.globalAlpha=0.5*shade;
            ctx.beginPath();
            ctx.moveTo(p0[0],p0[1]);ctx.lineTo(p1[0],p1[1]);
            ctx.lineTo(p2[0],p2[1]);ctx.lineTo(p3[0],p3[1]);
            ctx.closePath();ctx.fill();

            ctx.globalAlpha=0.2*shade;
            ctx.strokeStyle='rgba(255,255,255,0.4)';ctx.lineWidth=0.5;ctx.stroke();
        }
        ctx.globalAlpha=1;

        /* K at center */
        var Kcenter=computeKDeform(0,0);
        ctx.font='13px Courier New';ctx.fillStyle='#818cf8';ctx.textAlign='left';ctx.textBaseline='top';
        ctx.fillText('K(0,0) = '+Kcenter.toFixed(4),14,14);
        ctx.font='11px Georgia';ctx.fillStyle='#808098';
        ctx.fillText('Drag to rotate',14,32);

        var info=document.getElementById('deformInfo');
        var kc=Kcenter;
        var ktype=kc>0.001?'<span class="indigo">positive (dome-like)</span>':kc<-0.001?'<span class="red">negative (saddle-like)</span>':'<span class="white">zero (flat)</span>';
        info.innerHTML='K at center = <strong>'+kc.toFixed(4)+'</strong> \u2014 '+ktype;
    }

    cvs.addEventListener('mousedown',function(e){dragging=true;lastMx=e.clientX;lastMy=e.clientY;});
    window.addEventListener('mousemove',function(e){
        if(!dragging) return;
        angleY+=(e.clientX-lastMx)*0.008;angleX+=(e.clientY-lastMy)*0.008;
        lastMx=e.clientX;lastMy=e.clientY;render();
    });
    window.addEventListener('mouseup',function(){dragging=false;});

    cvs.addEventListener('touchstart',function(e){e.preventDefault();dragging=true;lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;},{passive:false});
    cvs.addEventListener('touchmove',function(e){e.preventDefault();if(!dragging) return;angleY+=(e.touches[0].clientX-lastMx)*0.008;angleX+=(e.touches[0].clientY-lastMy)*0.008;lastMx=e.touches[0].clientX;lastMy=e.touches[0].clientY;render();},{passive:false});
    cvs.addEventListener('touchend',function(){dragging=false;});

    bumpSlider.addEventListener('input',render);
    saddleSlider.addEventListener('input',render);
    render();
})();

</script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Coded by <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
