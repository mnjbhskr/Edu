<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combinatorics</title>
    <meta name="description" content="Count permutations and combinations interactively. Visual exploration of factorials, arrangements, and the multiplication principle.">
    <link rel="canonical" href="https://mathsedu.org/combinatorics.html">
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "LearningResource",
      "name": "Combinatorics",
      "url": "https://mathsedu.org/combinatorics.html",
      "description": "Count permutations and combinations interactively. Visual exploration of factorials, arrangements, and the multiplication principle.",
      "educationalLevel": "Beginner",
      "teaches": "Combinatorics and counting",
      "learningResourceType": "Interactive visualisation",
      "interactivityType": "active",
      "inLanguage": "en",
      "isAccessibleForFree": true,
      "creator": {
        "@type": "Person",
        "name": "Manoj Bhaskar"
      },
      "license": "https://creativecommons.org/licenses/by-nc-sa/4.0/",
      "isPartOf": {
        "@type": "Course",
        "name": "Probability & Statistics",
        "url": "https://mathsedu.org/"
      }
    }
    </script>
    <meta property="og:title" content="Combinatorics">
    <meta property="og:description" content="Count permutations and combinations interactively. Visual exploration of factorials, arrangements, and the multiplication principle.">
    <meta property="og:url" content="https://mathsedu.org/combinatorics.html">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="A Visual Discovery of Mathematics">
    <meta property="og:locale" content="en_GB">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Combinatorics">
    <meta name="twitter:description" content="Count permutations and combinations interactively. Visual exploration of factorials, arrangements, and the multiplication principle.">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a1a;color:#e0e0e0;font-family:Georgia,'Times New Roman',serif;line-height:1.6}
        .container{max-width:960px;margin:0 auto;padding:24px 28px 48px}
        .back{color:#606078;text-decoration:none;font-size:0.85em}
        .back:hover{color:#f472b6}
        h1{font-size:1.8em;font-weight:400;color:#fff;margin:16px 0 4px}
        .subtitle{color:#808098;font-style:italic;margin-bottom:28px}
        h2{font-size:1.15em;font-weight:400;color:#fff;margin:28px 0 12px}
        canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:crosshair}
        .panel{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:18px 22px;margin-bottom:20px}
        .panel h3{font-weight:400;font-size:0.8em;color:#808098;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
        .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
        .btn{background:rgba(255,255,255,0.035);border:1px solid rgba(255,255,255,0.07);color:#b0b0c4;padding:5px 13px;border-radius:6px;cursor:pointer;font-family:Georgia,serif;font-size:0.92em;transition:all 0.2s}
        .btn:hover{background:rgba(255,255,255,0.07);color:#e0e0ef}
        .btn.active{background:rgba(244,114,182,0.13);border-color:rgba(244,114,182,0.4);color:#f472b6}
        .math-line{font-family:'Courier New',monospace;font-size:0.92em;color:#c0c0d8;margin:4px 0;line-height:1.8}
        .math-line .pink{color:#f472b6}.math-line .gold{color:#fbbf24}.math-line .green{color:#2ecc71}.math-line .cyan{color:#22d3ee}
        .math-line .muted{color:#808098}
        .slider-row{display:flex;align-items:center;gap:14px;margin:10px 0}
        .slider-row input[type=range]{flex:1;max-width:260px;accent-color:#f472b6}
        .slider-label{color:#f472b6;font-family:'Courier New',monospace;font-size:1.05em;min-width:50px}
        .explain{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:20px 24px;margin-top:20px}
        .explain-name{color:#f472b6;font-size:1.1em;margin-bottom:6px}
        .explain-text{color:#a0a0b8;font-size:0.9em;line-height:1.75}
        .flex-row{display:flex;gap:20px;flex-wrap:wrap}
        .flex-row>.flex-half{flex:1 1 300px;min-width:280px}
        .scroll-grid{max-height:280px;overflow-y:auto;border:1px solid rgba(255,255,255,0.04);border-radius:6px;padding:8px;margin-top:10px;background:rgba(0,0,0,0.2)}
        .scroll-grid::-webkit-scrollbar{width:6px}
        .scroll-grid::-webkit-scrollbar-track{background:transparent}
        .scroll-grid::-webkit-scrollbar-thumb{background:rgba(244,114,182,0.3);border-radius:3px}
        .perm-row{display:flex;gap:3px;align-items:center;padding:3px 4px;border-radius:4px}
        .perm-row:hover{background:rgba(255,255,255,0.03)}
        .mini-circle{width:16px;height:16px;border-radius:50%;display:inline-block;flex-shrink:0}
        .perm-label{font-family:'Courier New',monospace;font-size:0.75em;color:#808098;margin-left:6px;white-space:nowrap}
        .warn{color:#fbbf24;font-size:0.85em;font-style:italic;margin:8px 0}
        .comparison-side{flex:1;min-width:260px}
        .comparison-side h4{font-weight:400;font-size:0.95em;color:#f472b6;margin-bottom:8px}
        .pascal-cell{cursor:pointer;transition:all 0.15s}
        .ie-circle{transition:all 0.2s}
        hr.divider{border:none;border-top:1px solid rgba(255,255,255,0.06);margin:8px 0}
        @media(max-width:600px){canvas{width:100%!important;height:auto!important}}
    </style>
</head>
<body>
<div class="container">
    <a class="back" href="index.html">&larr; Back to Index</a>
    <h1>Combinatorics</h1>
    <p class="subtitle">Count without counting &mdash; permutations, combinations, Pascal's connections</p>

    <!-- ═══════ Section 1: Permutations ═══════ -->
    <h2>Permutations Visualizer</h2>
    <div class="panel">
        <h3>Arrange n distinct objects</h3>
        <div class="slider-row">
            <span class="math-line muted">n =</span>
            <input type="range" id="permN" min="2" max="8" value="4">
            <span class="slider-label" id="permNLabel">4</span>
        </div>
        <canvas id="permCanvas" width="600" height="300" style="cursor:default"></canvas>
        <div class="math-line" id="permFormula" style="margin-top:10px"></div>
        <div class="btn-row" style="margin-top:10px">
            <button class="btn" id="permShuffle">Shuffle</button>
            <button class="btn" id="permShowAll">Show All</button>
        </div>
        <div id="permGrid"></div>
    </div>

    <!-- ═══════ Section 2: Combinations ═══════ -->
    <h2>Combinations Visualizer</h2>
    <div class="panel">
        <h3>Choose k from n objects</h3>
        <div class="slider-row">
            <span class="math-line muted">n =</span>
            <input type="range" id="combN" min="2" max="10" value="5">
            <span class="slider-label" id="combNLabel">5</span>
        </div>
        <div class="slider-row">
            <span class="math-line muted">k =</span>
            <input type="range" id="combK" min="0" max="5" value="2">
            <span class="slider-label" id="combKLabel">2</span>
        </div>
        <canvas id="combCanvas" width="600" height="350" style="cursor:pointer"></canvas>
        <div class="math-line" id="combFormula" style="margin-top:10px"></div>
        <div class="math-line" id="combSymmetry" style="margin-top:2px"></div>
        <div class="btn-row" style="margin-top:10px">
            <button class="btn" id="combShowAll">Show All Combinations</button>
            <button class="btn" id="combShowSymmetry">Show Symmetry</button>
        </div>
        <div id="combGrid"></div>
    </div>

    <!-- ═══════ Section 3: Permutations vs Combinations ═══════ -->
    <h2>Permutations vs Combinations</h2>
    <div class="panel">
        <h3>Order matters vs order doesn't matter</h3>
        <div class="slider-row">
            <span class="math-line muted">n =</span>
            <input type="range" id="compN" min="3" max="7" value="4">
            <span class="slider-label" id="compNLabel">4</span>
        </div>
        <div class="slider-row">
            <span class="math-line muted">k =</span>
            <input type="range" id="compK" min="1" max="4" value="2">
            <span class="slider-label" id="compKLabel">2</span>
        </div>
        <div class="math-line" id="compFormula" style="margin-bottom:10px"></div>
        <div class="flex-row" id="compDisplay"></div>
        <canvas id="compCanvas" width="600" height="200" style="margin-top:14px;cursor:default"></canvas>
        <div class="math-line" id="compAnim" style="margin-top:8px"></div>
    </div>

    <!-- ═══════ Section 4: Pascal's Triangle ═══════ -->
    <h2>Pascal's Triangle</h2>
    <div class="panel">
        <h3>C(n,k) = C(n-1,k-1) + C(n-1,k)</h3>
        <canvas id="pascalCanvas" width="650" height="400" style="cursor:pointer"></canvas>
        <div class="math-line" id="pascalInfo" style="margin-top:10px"></div>
        <div class="btn-row" style="margin-top:10px">
            <button class="btn" id="pascalRowSum">Row Sums = 2^n</button>
            <button class="btn" id="pascalFib">Fibonacci Diagonals</button>
            <button class="btn" id="pascalHockey">Hockey Stick</button>
            <button class="btn" id="pascalClear">Clear Highlights</button>
        </div>
    </div>

    <!-- ═══════ Section 5: Counting Principles ═══════ -->
    <h2>Counting Principles</h2>

    <div class="panel">
        <h3>Multiplication Principle</h3>
        <p class="math-line muted">If task A has m ways and task B has n ways, together there are m &times; n ways.</p>
        <div class="slider-row">
            <span class="math-line muted">m (shirts) =</span>
            <input type="range" id="mulM" min="2" max="6" value="3">
            <span class="slider-label" id="mulMLabel">3</span>
        </div>
        <div class="slider-row">
            <span class="math-line muted">n (pants) =</span>
            <input type="range" id="mulN" min="2" max="6" value="4">
            <span class="slider-label" id="mulNLabel">4</span>
        </div>
        <canvas id="mulCanvas" width="600" height="280" style="cursor:default"></canvas>
        <div class="math-line" id="mulFormula" style="margin-top:8px"></div>
    </div>

    <div class="panel">
        <h3>Addition Principle</h3>
        <p class="math-line muted">Disjoint choices: m + n total options.</p>
        <canvas id="addCanvas" width="600" height="180" style="cursor:default"></canvas>
        <div class="math-line" id="addFormula" style="margin-top:8px"></div>
    </div>

    <div class="panel">
        <h3>Inclusion-Exclusion Principle</h3>
        <p class="math-line muted">|A &cup; B| = |A| + |B| - |A &cap; B|</p>
        <div class="slider-row">
            <span class="math-line muted">|A| =</span>
            <input type="range" id="ieA" min="2" max="12" value="7">
            <span class="slider-label" id="ieALabel">7</span>
        </div>
        <div class="slider-row">
            <span class="math-line muted">|B| =</span>
            <input type="range" id="ieB" min="2" max="12" value="5">
            <span class="slider-label" id="ieBLabel">5</span>
        </div>
        <div class="slider-row">
            <span class="math-line muted">|A &cap; B| =</span>
            <input type="range" id="ieAB" min="0" max="5" value="2">
            <span class="slider-label" id="ieABLabel">2</span>
        </div>
        <canvas id="ieCanvas" width="600" height="280" style="cursor:default"></canvas>
        <div class="math-line" id="ieFormula" style="margin-top:8px"></div>
    </div>

    <!-- ═══════ Section 6: Explanation ═══════ -->
    <div class="explain">
        <div class="explain-name">What have we learnt?</div>
        <div class="explain-text">
            Combinatorics is about counting systematically. Two core ideas recur throughout:
            <strong>permutations</strong> count arrangements where order matters, and
            <strong>combinations</strong> count selections where it does not. The relationship
            P(n,k) = C(n,k) &times; k! captures the precise difference &mdash; each unordered selection
            generates k! ordered arrangements.<br><br>
            Pascal's triangle encodes C(n,k) values with the elegant recurrence
            C(n,k) = C(n-1,k-1) + C(n-1,k), and reveals surprising connections: row sums
            are powers of 2, diagonal sums are Fibonacci numbers, and the hockey stick identity
            lets you sum along a diagonal.<br><br>
            The multiplication and addition principles are the foundational tools for all counting
            arguments, while inclusion-exclusion handles overlapping cases. These ideas appear
            throughout probability (sample spaces), cryptography (key spaces), algorithm design
            (complexity analysis), and discrete mathematics.
        </div>
    </div>
</div>

<script>
/* ══════════════════════════════════════════════
   COMBINATORICS — Interactive Visualizations
   ══════════════════════════════════════════════ */

const PALETTE = ['#f472b6','#22d3ee','#fbbf24','#2ecc71','#f87171','#818cf8','#fb923c','#a78bfa','#34d399','#e879f9'];
const BG = '#0a0a1a';

/* ── utility ── */
function factorial(n){ let r=1; for(let i=2;i<=n;i++) r*=i; return r; }
function choose(n,k){ if(k<0||k>n) return 0; if(k===0||k===n) return 1; let r=1; for(let i=0;i<k;i++) r=r*(n-i)/(i+1); return Math.round(r); }
function perm(n,k){ let r=1; for(let i=0;i<k;i++) r*=(n-i); return r; }

function getAllPerms(arr){
    if(arr.length<=1) return [arr.slice()];
    const res=[];
    for(let i=0;i<arr.length;i++){
        const rest=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getAllPerms(rest)) res.push([arr[i],...p]);
    }
    return res;
}

function getAllCombs(arr,k){
    if(k===0) return [[]];
    if(k>arr.length) return [];
    const res=[];
    function bt(start,cur){
        if(cur.length===k){res.push(cur.slice());return;}
        for(let i=start;i<arr.length;i++){cur.push(arr[i]);bt(i+1,cur);cur.pop();}
    }
    bt(0,[]);
    return res;
}

function drawCircle(ctx,x,y,r,color,filled){
    ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);
    if(filled){ctx.fillStyle=color;ctx.fill();}
    else{ctx.strokeStyle=color;ctx.lineWidth=2;ctx.stroke();}
}

function getCanvasXY(canvas,e){
    const r=canvas.getBoundingClientRect();
    const clientX=e.touches?e.touches[0].clientX:e.clientX;
    const clientY=e.touches?e.touches[0].clientY:e.clientY;
    return{x:(clientX-r.left)*(canvas.width/r.width), y:(clientY-r.top)*(canvas.height/r.height)};
}

/* ══════════════════════════════════════════════
   SECTION 1: Permutations Visualizer
   ══════════════════════════════════════════════ */
(function(){
    const slider=document.getElementById('permN');
    const label=document.getElementById('permNLabel');
    const cvs=document.getElementById('permCanvas');
    const ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;

    let n=4;
    let original=[];
    let current=[];
    let target=[];
    let animProgress=1; // 1=done
    let animStart=0;
    const ANIM_DUR=500;

    function initObjects(){
        n=parseInt(slider.value);
        label.textContent=n;
        original=[];current=[];
        for(let i=0;i<n;i++){original.push(i);current.push(i);}
        target=current.slice();
        animProgress=1;
        updateFormula();
        draw();
        document.getElementById('permGrid').innerHTML='';
    }

    function updateFormula(){
        const f=factorial(n);
        document.getElementById('permFormula').innerHTML=
            '<span class="pink">'+n+'!</span> = <span class="pink">'+f+'</span> permutations';
    }

    function getPositions(count){
        const spacing=Math.min(60, (W-80)/count);
        const startX=(W-(count-1)*spacing)/2;
        const pos=[];
        for(let i=0;i<count;i++) pos.push({x:startX+i*spacing, y:100});
        return pos;
    }

    function draw(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle=BG;ctx.fillRect(0,0,W,H);

        const pos=getPositions(n);
        const radius=Math.min(22, 180/n);

        // labels
        ctx.font='12px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText('Original order',W/2,30);

        // original row (top, dimmed)
        for(let i=0;i<n;i++){
            drawCircle(ctx, pos[i].x, 55, radius*0.6, PALETTE[i%10], true);
            ctx.globalAlpha=0.4;
            ctx.font='10px Courier New';ctx.fillStyle='#e0e0e0';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText(i+1, pos[i].x, 55);
            ctx.globalAlpha=1;
        }

        // current permutation row (animated)
        ctx.font='12px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText('Current permutation',W/2,130);

        for(let i=0;i<n;i++){
            // find where object current[i] should be drawn
            let drawX, drawY;
            if(animProgress<1){
                const fromIdx=current.indexOf(current[i]);
                const toIdx=target.indexOf(current[i]);
                const fromPos=pos[fromIdx];
                const toPos=pos[toIdx];
                const t=easeInOut(animProgress);
                // during animation, draw based on target position mapping
                // we need to draw each object at its interpolated position
            }
            drawX=pos[i].x;
            drawY=155;

            const objIdx=current[i];
            drawCircle(ctx, drawX, drawY, radius, PALETTE[objIdx%10], true);
            ctx.font=(radius>15?'14':'10')+'px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText(objIdx+1, drawX, drawY);
        }

        // arrows from original to permuted
        ctx.strokeStyle='rgba(244,114,182,0.2)';ctx.lineWidth=1;
        for(let i=0;i<n;i++){
            const fromX=pos[i].x;
            const fromY=55+radius*0.6+4;
            const toI=current.indexOf(i);
            const toX=pos[toI].x;
            const toY=155-radius-4;

            ctx.beginPath();
            ctx.moveTo(fromX,fromY);
            const cpY=(fromY+toY)/2;
            ctx.quadraticCurveTo((fromX+toX)/2, cpY, toX, toY);
            ctx.stroke();

            // arrowhead
            const angle=Math.atan2(toY-cpY, toX-(fromX+toX)/2);
            ctx.fillStyle='rgba(244,114,182,0.3)';
            ctx.beginPath();
            ctx.moveTo(toX,toY);
            ctx.lineTo(toX-6*Math.cos(angle-0.4),toY-6*Math.sin(angle-0.4));
            ctx.lineTo(toX-6*Math.cos(angle+0.4),toY-6*Math.sin(angle+0.4));
            ctx.closePath();ctx.fill();
        }

        // permutation notation
        ctx.font='13px Courier New';ctx.fillStyle='#f472b6';ctx.textAlign='center';ctx.textBaseline='top';
        const notation='('+current.map(i=>i+1).join(' ')+')';
        ctx.fillText(notation, W/2, 155+radius+15);

        // cycle notation
        const cycles=getCycles(current);
        ctx.font='11px Courier New';ctx.fillStyle='#808098';ctx.textAlign='center';
        ctx.fillText('Cycle notation: '+cycles, W/2, 155+radius+35);
    }

    function getCycles(perm){
        const visited=new Array(perm.length).fill(false);
        const cycles=[];
        for(let i=0;i<perm.length;i++){
            if(visited[i]) continue;
            const cycle=[i+1];
            visited[i]=true;
            let j=perm[i];
            while(j!==i){cycle.push(j+1);visited[j]=true;j=perm[j];}
            if(cycle.length>1) cycles.push('('+cycle.join(' ')+')');
        }
        return cycles.length?cycles.join(''):'(identity)';
    }

    function easeInOut(t){return t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;}

    function shuffleAnim(){
        target=current.slice();
        // Fisher-Yates
        for(let i=target.length-1;i>0;i--){
            const j=Math.floor(Math.random()*(i+1));
            [target[i],target[j]]=[target[j],target[i]];
        }

        // Animate positions
        const startPositions=[];
        const endPositions=[];
        const pos=getPositions(n);
        const radius=Math.min(22,180/n);

        for(let objIdx=0;objIdx<n;objIdx++){
            const fromI=current.indexOf(objIdx);
            const toI=target.indexOf(objIdx);
            startPositions.push({x:pos[fromI].x, y:155});
            endPositions.push({x:pos[toI].x, y:155});
        }

        const t0=performance.now();
        function animStep(now){
            let frac=(now-t0)/ANIM_DUR;
            if(frac>=1){
                frac=1;
                current=target.slice();
                draw();
                return;
            }
            const t=easeInOut(frac);

            ctx.clearRect(0,0,W,H);
            ctx.fillStyle=BG;ctx.fillRect(0,0,W,H);

            // original row
            ctx.font='12px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='bottom';
            ctx.fillText('Original order',W/2,30);
            for(let i=0;i<n;i++){
                drawCircle(ctx, pos[i].x, 55, radius*0.6, PALETTE[i%10], true);
                ctx.globalAlpha=0.4;
                ctx.font='10px Courier New';ctx.fillStyle='#e0e0e0';ctx.textAlign='center';ctx.textBaseline='middle';
                ctx.fillText(i+1, pos[i].x, 55);
                ctx.globalAlpha=1;
            }

            ctx.font='12px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='bottom';
            ctx.fillText('Current permutation',W/2,130);

            // animated objects
            for(let objIdx=0;objIdx<n;objIdx++){
                const sx=startPositions[objIdx].x;
                const ex=endPositions[objIdx].x;
                const dx=sx+(ex-sx)*t;
                // arc path: go up then down
                const dy=155-40*Math.sin(Math.PI*t)*(Math.abs(ex-sx)>1?1:0);

                drawCircle(ctx, dx, dy, radius, PALETTE[objIdx%10], true);
                ctx.font=(radius>15?'14':'10')+'px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
                ctx.fillText(objIdx+1, dx, dy);
            }

            requestAnimationFrame(animStep);
        }
        requestAnimationFrame(animStep);
    }

    function showAllPerms(){
        const grid=document.getElementById('permGrid');
        const f=factorial(n);
        if(f>5040){
            grid.innerHTML='<div class="warn">'+n+'! = '+f+' permutations &mdash; too many to display. Showing first 100.</div>';
        }
        const arr=[];for(let i=0;i<n;i++) arr.push(i);
        const perms=getAllPerms(arr);
        const limit=Math.min(perms.length,100);
        let html='<div class="scroll-grid"><div style="display:flex;flex-wrap:wrap;gap:4px">';
        for(let p=0;p<limit;p++){
            html+='<div class="perm-row">';
            for(let j=0;j<n;j++){
                html+='<span class="mini-circle" style="background:'+PALETTE[perms[p][j]%10]+'"></span>';
            }
            html+='<span class="perm-label">('+perms[p].map(i=>i+1).join('')+')</span></div>';
        }
        if(limit<perms.length) html+='<div class="perm-label" style="padding:4px">... and '+(perms.length-limit)+' more</div>';
        html+='</div></div>';
        if(f<=5040) grid.innerHTML='<div style="margin-top:6px;font-size:0.85em;color:#808098">All '+f+' permutations:</div>'+html;
        else grid.innerHTML+= html;
    }

    slider.addEventListener('input',initObjects);
    document.getElementById('permShuffle').addEventListener('click',shuffleAnim);
    document.getElementById('permShowAll').addEventListener('click',showAllPerms);
    initObjects();
})();


/* ══════════════════════════════════════════════
   SECTION 2: Combinations Visualizer
   ══════════════════════════════════════════════ */
(function(){
    const nSlider=document.getElementById('combN');
    const kSlider=document.getElementById('combK');
    const nLabel=document.getElementById('combNLabel');
    const kLabel=document.getElementById('combKLabel');
    const cvs=document.getElementById('combCanvas');
    const ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;

    let n=5, k=2;
    let selected=new Set();

    function init(){
        n=parseInt(nSlider.value);
        kSlider.max=n;
        k=Math.min(parseInt(kSlider.value),n);
        kSlider.value=k;
        nLabel.textContent=n;
        kLabel.textContent=k;
        selected=new Set();
        updateFormula();
        draw();
        document.getElementById('combGrid').innerHTML='';
    }

    function updateFormula(){
        const c=choose(n,k);
        document.getElementById('combFormula').innerHTML=
            '<span class="pink">C('+n+','+k+')</span> = '+n+'! / ('+k+'! &times; '+(n-k)+'!) = <span class="pink">'+c+'</span>';
        document.getElementById('combSymmetry').innerHTML=
            '<span class="muted">C('+n+','+k+') = C('+n+','+(n-k)+') = '+c+'</span>';
    }

    function getCirclePositions(){
        const spacing=Math.min(50,(W-100)/n);
        const startX=(W-(n-1)*spacing)/2;
        const pos=[];
        for(let i=0;i<n;i++) pos.push({x:startX+i*spacing, y:120});
        return pos;
    }

    function draw(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle=BG;ctx.fillRect(0,0,W,H);

        const pos=getCirclePositions();
        const radius=Math.min(20, 150/n);

        ctx.font='12px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText('Click circles to select '+k+' objects ('+selected.size+' selected)',W/2,50);

        for(let i=0;i<n;i++){
            const sel=selected.has(i);
            const color=sel?'#f472b6':'#404058';
            drawCircle(ctx, pos[i].x, pos[i].y, radius, color, true);
            if(sel){
                ctx.strokeStyle='rgba(244,114,182,0.5)';ctx.lineWidth=2;
                ctx.beginPath();ctx.arc(pos[i].x,pos[i].y,radius+4,0,Math.PI*2);ctx.stroke();
            }
            ctx.font=(radius>15?'14':'10')+'px Courier New';
            ctx.fillStyle=sel?'#fff':'#a0a0b8';
            ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText(i+1, pos[i].x, pos[i].y);
        }

        // label below
        ctx.font='11px Courier New';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='top';
        for(let i=0;i<n;i++){
            ctx.fillText(i+1, pos[i].x, pos[i].y+radius+8);
        }

        // selection summary
        if(selected.size>0){
            const selArr=[...selected].sort((a,b)=>a-b);
            ctx.font='13px Courier New';ctx.fillStyle='#f472b6';ctx.textAlign='center';ctx.textBaseline='top';
            ctx.fillText('Selected: {'+selArr.map(i=>i+1).join(', ')+'}', W/2, 200);
        }

        // symmetry visual (bottom half)
        ctx.font='11px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText('Symmetry: choosing k is the same as choosing which n-k to leave out', W/2, 250);

        // show complement
        if(selected.size===k && k>0 && k<n){
            const comp=[];
            for(let i=0;i<n;i++) if(!selected.has(i)) comp.push(i);
            const leftX=W/2-120;
            const rightX=W/2+120;

            ctx.font='10px Georgia';ctx.fillStyle='#f472b6';ctx.textAlign='center';
            ctx.fillText('C('+n+','+k+') chosen', leftX, 275);
            ctx.fillStyle='#22d3ee';
            ctx.fillText('C('+n+','+(n-k)+') left out', rightX, 275);

            const selArr=[...selected].sort((a,b)=>a-b);
            const miniR=7;
            const miniSpacing=20;

            // draw chosen
            let sx=leftX-(selArr.length-1)*miniSpacing/2;
            for(let i=0;i<selArr.length;i++){
                drawCircle(ctx, sx+i*miniSpacing, 300, miniR, '#f472b6', true);
                ctx.font='8px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
                ctx.fillText(selArr[i]+1, sx+i*miniSpacing, 300);
            }

            // draw complement
            sx=rightX-(comp.length-1)*miniSpacing/2;
            for(let i=0;i<comp.length;i++){
                drawCircle(ctx, sx+i*miniSpacing, 300, miniR, '#22d3ee', true);
                ctx.font='8px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
                ctx.fillText(comp[i]+1, sx+i*miniSpacing, 300);
            }

            // equals sign
            ctx.font='14px Courier New';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText('=', W/2, 300);
        }
    }

    function handleClick(e){
        e.preventDefault();
        const pos=getCirclePositions();
        const radius=Math.min(20,150/n);
        const p=getCanvasXY(cvs,e);

        for(let i=0;i<n;i++){
            const dx=p.x-pos[i].x, dy=p.y-pos[i].y;
            if(dx*dx+dy*dy<(radius+8)*(radius+8)){
                if(selected.has(i)){
                    selected.delete(i);
                } else if(selected.size<k){
                    selected.add(i);
                } else {
                    // replace: deselect oldest, select new
                    const first=[...selected][0];
                    selected.delete(first);
                    selected.add(i);
                }
                draw();
                return;
            }
        }
    }

    cvs.addEventListener('click',handleClick);
    cvs.addEventListener('touchend',function(e){e.preventDefault();handleClick(e);},{passive:false});

    function showAllCombs(){
        const grid=document.getElementById('combGrid');
        const c=choose(n,k);
        const arr=[];for(let i=0;i<n;i++) arr.push(i);
        const combs=getAllCombs(arr,k);
        const limit=Math.min(combs.length,100);

        let html='<div style="margin-top:6px;font-size:0.85em;color:#808098">All '+c+' combinations:</div>';
        html+='<div class="scroll-grid"><div style="display:flex;flex-wrap:wrap;gap:4px">';
        for(let ci=0;ci<limit;ci++){
            html+='<div class="perm-row">';
            const comb=new Set(combs[ci]);
            for(let j=0;j<n;j++){
                const color=comb.has(j)?PALETTE[j%10]:'#2a2a3a';
                html+='<span class="mini-circle" style="background:'+color+';'+(comb.has(j)?'':'opacity:0.3')+'"></span>';
            }
            html+='<span class="perm-label">{'+combs[ci].map(i=>i+1).join(',')+'}</span></div>';
        }
        if(limit<combs.length) html+='<div class="perm-label" style="padding:4px">... and '+(combs.length-limit)+' more</div>';
        html+='</div></div>';
        grid.innerHTML=html;
    }

    function showSymmetry(){
        const grid=document.getElementById('combGrid');
        const arr=[];for(let i=0;i<n;i++) arr.push(i);
        const combsK=getAllCombs(arr,k);
        const combsNK=getAllCombs(arr,n-k);
        const limit=Math.min(combsK.length,50);

        let html='<div style="margin-top:6px;font-size:0.85em;color:#808098">C('+n+','+k+') = C('+n+','+(n-k)+') &mdash; each selection of '+k+' maps to leaving out '+(n-k)+':</div>';
        html+='<div class="scroll-grid">';
        for(let ci=0;ci<limit;ci++){
            html+='<div class="perm-row" style="gap:6px">';
            const comb=new Set(combsK[ci]);
            // chosen
            for(let j=0;j<n;j++){
                const color=comb.has(j)?'#f472b6':'#2a2a3a';
                html+='<span class="mini-circle" style="background:'+color+';'+(comb.has(j)?'':'opacity:0.2')+'"></span>';
            }
            html+='<span class="perm-label" style="color:#808098;margin:0 10px">&harr;</span>';
            // complement
            for(let j=0;j<n;j++){
                const color=!comb.has(j)?'#22d3ee':'#2a2a3a';
                html+='<span class="mini-circle" style="background:'+color+';'+(!comb.has(j)?'':'opacity:0.2')+'"></span>';
            }
            html+='</div>';
        }
        html+='</div>';
        grid.innerHTML=html;
    }

    nSlider.addEventListener('input',init);
    kSlider.addEventListener('input',function(){
        k=parseInt(kSlider.value);
        kLabel.textContent=k;
        selected=new Set();
        updateFormula();
        draw();
        document.getElementById('combGrid').innerHTML='';
    });
    document.getElementById('combShowAll').addEventListener('click',showAllCombs);
    document.getElementById('combShowSymmetry').addEventListener('click',showSymmetry);
    init();
})();


/* ══════════════════════════════════════════════
   SECTION 3: Permutations vs Combinations
   ══════════════════════════════════════════════ */
(function(){
    const nSlider=document.getElementById('compN');
    const kSlider=document.getElementById('compK');
    const nLabel=document.getElementById('compNLabel');
    const kLabel=document.getElementById('compKLabel');
    const cvs=document.getElementById('compCanvas');
    const ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;

    let n=4, k=2;
    let animCombIdx=0;
    let animPermIdx=0;
    let animRunning=false;
    let animInterval=null;

    function init(){
        n=parseInt(nSlider.value);
        kSlider.max=n;
        k=Math.min(parseInt(kSlider.value),n);
        kSlider.value=k;
        nLabel.textContent=n;
        kLabel.textContent=k;
        updateFormula();
        updateDisplay();
        animCombIdx=0;animPermIdx=0;
        drawAnimCanvas();
        if(animInterval){clearInterval(animInterval);animInterval=null;animRunning=false;}
    }

    function updateFormula(){
        const p=perm(n,k), c=choose(n,k), kf=factorial(k);
        document.getElementById('compFormula').innerHTML=
            '<span class="pink">P('+n+','+k+')</span> = '+p+
            ' &nbsp;&nbsp; <span class="cyan">C('+n+','+k+')</span> = '+c+
            ' &nbsp;&nbsp; P('+n+','+k+') = C('+n+','+k+') &times; '+k+'! = '+c+' &times; '+kf+' = '+p;
    }

    function updateDisplay(){
        const display=document.getElementById('compDisplay');
        const arr=[];for(let i=0;i<n;i++) arr.push(i);
        const combs=getAllCombs(arr,k);
        const permsK=[];
        for(const c of combs){
            const ps=getAllPerms(c);
            for(const p of ps) permsK.push(p);
        }

        const combLimit=Math.min(combs.length,30);
        const permLimit=Math.min(permsK.length,60);

        let leftHtml='<div class="comparison-side"><h4>Permutations P('+n+','+k+') = '+perm(n,k)+'</h4>';
        leftHtml+='<div style="font-size:0.82em;color:#808098;margin-bottom:6px">Order matters</div>';
        leftHtml+='<div class="scroll-grid" style="max-height:200px">';
        for(let i=0;i<permLimit;i++){
            leftHtml+='<div class="perm-row">';
            for(let j=0;j<k;j++){
                leftHtml+='<span class="mini-circle" style="background:'+PALETTE[permsK[i][j]%10]+'"></span>';
            }
            leftHtml+='<span class="perm-label">('+permsK[i].map(x=>x+1).join(' ')+')</span></div>';
        }
        if(permLimit<permsK.length) leftHtml+='<div class="perm-label" style="padding:4px">... +'+(permsK.length-permLimit)+' more</div>';
        leftHtml+='</div></div>';

        let rightHtml='<div class="comparison-side"><h4>Combinations C('+n+','+k+') = '+choose(n,k)+'</h4>';
        rightHtml+='<div style="font-size:0.82em;color:#808098;margin-bottom:6px">Order does not matter</div>';
        rightHtml+='<div class="scroll-grid" style="max-height:200px">';
        for(let i=0;i<combLimit;i++){
            rightHtml+='<div class="perm-row">';
            for(let j=0;j<k;j++){
                rightHtml+='<span class="mini-circle" style="background:'+PALETTE[combs[i][j]%10]+'"></span>';
            }
            rightHtml+='<span class="perm-label">{'+combs[i].map(x=>x+1).join(',')+'}</span></div>';
        }
        if(combLimit<combs.length) rightHtml+='<div class="perm-label" style="padding:4px">... +'+(combs.length-combLimit)+' more</div>';
        rightHtml+='</div></div>';

        display.innerHTML=leftHtml+rightHtml;
    }

    function drawAnimCanvas(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle=BG;ctx.fillRect(0,0,W,H);

        const arr=[];for(let i=0;i<n;i++) arr.push(i);
        const combs=getAllCombs(arr,k);
        if(combs.length===0) return;

        const ci=animCombIdx%combs.length;
        const comb=combs[ci];
        const permsOfComb=getAllPerms(comb);
        const pi=animPermIdx%permsOfComb.length;
        const currentPerm=permsOfComb[pi];

        const radius=16;

        // Title
        ctx.font='12px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText('Combination '+(ci+1)+' of '+combs.length+': {'+comb.map(x=>x+1).join(',')+'}', W/2, 10);
        ctx.fillText('generates '+permsOfComb.length+' = '+k+'! orderings. Showing ordering '+(pi+1)+':', W/2, 28);

        // draw the combination
        const combStartX=W/2-(k-1)*40/2;
        ctx.font='11px Georgia';ctx.fillStyle='#22d3ee';ctx.textAlign='center';
        ctx.fillText('Combination (unordered)', W/4, 65);
        for(let j=0;j<k;j++){
            drawCircle(ctx, W/4-(k-1)*20/2+j*40, 95, radius, PALETTE[comb[j]%10], true);
            ctx.font='12px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText(comb[j]+1, W/4-(k-1)*20/2+j*40, 95);
        }

        // draw the current permutation of that combination
        ctx.font='11px Georgia';ctx.fillStyle='#f472b6';ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText('Permutation (ordered)', 3*W/4, 65);
        for(let j=0;j<k;j++){
            drawCircle(ctx, 3*W/4-(k-1)*20/2+j*40, 95, radius, PALETTE[currentPerm[j]%10], true);
            ctx.font='12px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText(currentPerm[j]+1, 3*W/4-(k-1)*20/2+j*40, 95);
        }

        // arrow between them
        ctx.strokeStyle='rgba(244,114,182,0.3)';ctx.lineWidth=1.5;
        ctx.setLineDash([4,3]);
        ctx.beginPath();ctx.moveTo(W/4+(k-1)*20/2+radius+10, 95);
        ctx.lineTo(3*W/4-(k-1)*20/2-radius-10, 95);ctx.stroke();
        ctx.setLineDash([]);
        // arrowhead
        const ax=3*W/4-(k-1)*20/2-radius-10;
        ctx.fillStyle='rgba(244,114,182,0.4)';
        ctx.beginPath();ctx.moveTo(ax,95);ctx.lineTo(ax-8,90);ctx.lineTo(ax-8,100);ctx.closePath();ctx.fill();

        // all perms of this comb as mini display
        ctx.font='10px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText('All '+k+'! = '+permsOfComb.length+' orderings of this selection:', W/2, 135);
        const miniR=6;
        const groupW=k*16+20;
        const perRow=Math.floor((W-40)/groupW);
        for(let p=0;p<permsOfComb.length;p++){
            const row=Math.floor(p/perRow);
            const col=p%perRow;
            const gx=30+col*groupW;
            const gy=155+row*22;
            const isActive=p===pi;
            if(isActive){
                ctx.fillStyle='rgba(244,114,182,0.1)';
                ctx.fillRect(gx-4, gy-4, k*16+8, 18);
                ctx.strokeStyle='rgba(244,114,182,0.3)';ctx.lineWidth=1;
                ctx.strokeRect(gx-4, gy-4, k*16+8, 18);
            }
            for(let j=0;j<k;j++){
                drawCircle(ctx, gx+j*16+6, gy+5, miniR, PALETTE[permsOfComb[p][j]%10], true);
            }
        }

        // formula
        ctx.font='12px Courier New';ctx.fillStyle='#f472b6';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText('P('+n+','+k+') = C('+n+','+k+') x '+k+'! = '+choose(n,k)+' x '+factorial(k)+' = '+perm(n,k), W/2, H-8);
    }

    function startAnim(){
        if(animRunning){clearInterval(animInterval);animInterval=null;animRunning=false;return;}
        animRunning=true;
        const arr=[];for(let i=0;i<n;i++) arr.push(i);
        const combs=getAllCombs(arr,k);
        if(combs.length===0) return;

        animInterval=setInterval(function(){
            const comb=combs[animCombIdx%combs.length];
            const permsOfComb=getAllPerms(comb);
            animPermIdx++;
            if(animPermIdx>=permsOfComb.length){
                animPermIdx=0;
                animCombIdx++;
                if(animCombIdx>=combs.length) animCombIdx=0;
            }
            drawAnimCanvas();
        }, 800);
    }

    // Auto-cycle on click of canvas
    cvs.addEventListener('click',startAnim);
    cvs.addEventListener('touchend',function(e){e.preventDefault();startAnim();});

    document.getElementById('compAnim').innerHTML='<span class="muted">Click the canvas to cycle through combinations and their orderings.</span>';

    nSlider.addEventListener('input',init);
    kSlider.addEventListener('input',function(){
        k=parseInt(kSlider.value);
        kLabel.textContent=k;
        updateFormula();
        updateDisplay();
        animCombIdx=0;animPermIdx=0;
        drawAnimCanvas();
    });
    init();
})();


/* ══════════════════════════════════════════════
   SECTION 4: Pascal's Triangle
   ══════════════════════════════════════════════ */
(function(){
    const cvs=document.getElementById('pascalCanvas');
    const ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;
    const ROWS=11; // rows 0-10

    // Precompute Pascal's values and positions
    const pascal=[];
    const positions=[];
    const cellR=17;

    for(let n=0;n<ROWS;n++){
        pascal[n]=[];
        positions[n]=[];
        for(let k=0;k<=n;k++){
            pascal[n][k]=choose(n,k);
            const x=W/2 + (k - n/2) * (cellR*2.4);
            const y=20 + n * (cellR*2.2+6);
            positions[n][k]={x,y};
        }
    }

    let highlights=new Set(); // "n,k" strings
    let selectedCell=null;
    let highlightMode=null; // 'rowsum','fib','hockey',null
    let hockeyDiag=null; // {startN, startK, len}

    function cellKey(n,k){return n+','+k;}

    function draw(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle=BG;ctx.fillRect(0,0,W,H);

        for(let n=0;n<ROWS;n++){
            for(let k=0;k<=n;k++){
                const pos=positions[n][k];
                const key=cellKey(n,k);
                const isHighlighted=highlights.has(key);
                const isSelected=selectedCell&&selectedCell.n===n&&selectedCell.k===k;

                // cell circle
                let fillColor='rgba(255,255,255,0.04)';
                let strokeColor='rgba(255,255,255,0.08)';
                let textColor='#a0a0b8';

                if(isSelected){
                    fillColor='rgba(244,114,182,0.25)';
                    strokeColor='#f472b6';
                    textColor='#f472b6';
                } else if(isHighlighted){
                    fillColor='rgba(244,114,182,0.15)';
                    strokeColor='rgba(244,114,182,0.4)';
                    textColor='#f472b6';
                }

                ctx.fillStyle=fillColor;
                ctx.beginPath();ctx.arc(pos.x,pos.y,cellR,0,Math.PI*2);ctx.fill();
                ctx.strokeStyle=strokeColor;ctx.lineWidth=1;
                ctx.beginPath();ctx.arc(pos.x,pos.y,cellR,0,Math.PI*2);ctx.stroke();

                // value
                const val=pascal[n][k];
                const fontSize=val>999?8:val>99?9:val>9?10:12;
                ctx.font=fontSize+'px Courier New';ctx.fillStyle=textColor;
                ctx.textAlign='center';ctx.textBaseline='middle';
                ctx.fillText(val,pos.x,pos.y);
            }
        }

        // draw lines connecting selected to parents
        if(selectedCell && selectedCell.n>0){
            const {n:sn,k:sk}=selectedCell;
            const childPos=positions[sn][sk];

            // left parent C(n-1,k-1)
            if(sk>0 && sk-1<=sn-1){
                const parentPos=positions[sn-1][sk-1];
                ctx.strokeStyle='rgba(244,114,182,0.4)';ctx.lineWidth=1.5;
                ctx.beginPath();ctx.moveTo(parentPos.x,parentPos.y+cellR+2);ctx.lineTo(childPos.x,childPos.y-cellR-2);ctx.stroke();
            }
            // right parent C(n-1,k)
            if(sk<=sn-1){
                const parentPos=positions[sn-1][sk];
                ctx.strokeStyle='rgba(244,114,182,0.4)';ctx.lineWidth=1.5;
                ctx.beginPath();ctx.moveTo(parentPos.x,parentPos.y+cellR+2);ctx.lineTo(childPos.x,childPos.y-cellR-2);ctx.stroke();
            }
        }

        // Row sums annotation
        if(highlightMode==='rowsum'){
            for(let n=0;n<ROWS;n++){
                const lastPos=positions[n][n];
                const sum=Math.pow(2,n);
                ctx.font='10px Courier New';ctx.fillStyle='#f472b6';ctx.textAlign='left';ctx.textBaseline='middle';
                ctx.fillText('= '+sum, lastPos.x+cellR+6, lastPos.y);
            }
        }

        // Fibonacci annotation
        if(highlightMode==='fib'){
            ctx.font='10px Courier New';ctx.fillStyle='#f472b6';ctx.textAlign='right';ctx.textBaseline='middle';
            const fibs=[1,1,2,3,5,8,13,21,34,55,89];
            for(let d=0;d<ROWS;d++){
                const firstPos=positions[d][0];
                ctx.fillText('F'+(d+1)+'='+fibs[d], firstPos.x-cellR-8, firstPos.y);
            }
        }
    }

    function handleClick(e){
        e.preventDefault();
        const p=getCanvasXY(cvs,e);

        for(let n=0;n<ROWS;n++){
            for(let k=0;k<=n;k++){
                const pos=positions[n][k];
                const dx=p.x-pos.x, dy=p.y-pos.y;
                if(dx*dx+dy*dy<cellR*cellR){
                    if(highlightMode==='hockey'){
                        handleHockeyClick(n,k);
                        return;
                    }
                    selectedCell={n,k};
                    highlights=new Set();
                    highlightMode=null;
                    // highlight parents
                    if(n>0){
                        if(k>0) highlights.add(cellKey(n-1,k-1));
                        if(k<=n-1) highlights.add(cellKey(n-1,k));
                    }
                    highlights.add(cellKey(n,k));

                    // update info
                    let info='<span class="pink">C('+n+','+k+') = '+pascal[n][k]+'</span>';
                    if(n>0){
                        const left=k>0?pascal[n-1][k-1]:0;
                        const right=k<=n-1?pascal[n-1][k]:0;
                        info+=' &nbsp;=&nbsp; C('+(n-1)+','+(k-1)+') + C('+(n-1)+','+k+') = '+left+' + '+right;
                    }
                    document.getElementById('pascalInfo').innerHTML=info;

                    // update combinations visualizer
                    if(n<=10){
                        const nS=document.getElementById('combN');
                        const kS=document.getElementById('combK');
                        nS.value=n; nS.dispatchEvent(new Event('input'));
                        kS.value=k; kS.dispatchEvent(new Event('input'));
                    }

                    draw();
                    return;
                }
            }
        }
    }

    function highlightRowSums(){
        highlights=new Set();
        highlightMode='rowsum';
        selectedCell=null;
        // highlight one row at a time — highlight all
        for(let n=0;n<ROWS;n++){
            for(let k=0;k<=n;k++){
                highlights.add(cellKey(n,k));
            }
        }
        let info='Row sums: ';
        for(let n=0;n<Math.min(ROWS,8);n++){
            info+='Row '+n+': '+Math.pow(2,n);
            if(n<7) info+=' &nbsp;|&nbsp; ';
        }
        info+=' ...';
        document.getElementById('pascalInfo').innerHTML='<span class="pink">'+info+'</span>';
        draw();
    }

    function highlightFibonacci(){
        highlights=new Set();
        highlightMode='fib';
        selectedCell=null;
        // Fibonacci diagonals: sum along shallow diagonals
        // diagonal d: cells (d,0), (d-1,1), (d-2,2), ... where row>=col
        const fibs=[];
        for(let d=0;d<ROWS;d++){
            let sum=0;
            for(let j=0;j<=Math.floor(d/2);j++){
                const r=d-j, c=j;
                if(r<ROWS){
                    highlights.add(cellKey(r,c));
                    sum+=pascal[r][c];
                }
            }
            fibs.push(sum);
        }
        document.getElementById('pascalInfo').innerHTML=
            '<span class="pink">Fibonacci diagonal sums: '+fibs.join(', ')+'</span>';
        draw();
    }

    function handleHockeyClick(n,k){
        // Start a hockey stick from this cell going down-right
        highlights=new Set();
        selectedCell=null;
        let sum=0;
        // go down the left-leaning diagonal from (n,k) downward
        // hockey stick: C(n,k) + C(n+1,k) + ... + C(n+m,k) = C(n+m+1,k+1)
        // pick cells going down same k column
        for(let r=n;r<ROWS-1;r++){
            if(k<=r){
                highlights.add(cellKey(r,k));
                sum+=pascal[r][k];
            }
        }
        // the handle: bottom cell one row further, k+1
        const handleR=ROWS-1;
        const handleK=k+1;
        if(handleK<=handleR){
            highlights.add(cellKey(handleR,handleK));
        }

        document.getElementById('pascalInfo').innerHTML=
            '<span class="pink">Hockey stick: sum along column k='+k+' from row '+n+' to '+(ROWS-2)+
            ' = '+sum+' = C('+(ROWS-1)+','+(k+1)+') = '+choose(ROWS-1,k+1)+'</span>';
        draw();
    }

    function activateHockeyMode(){
        highlightMode='hockey';
        highlights=new Set();
        selectedCell=null;
        document.getElementById('pascalInfo').innerHTML=
            '<span class="muted">Click any cell to see a hockey stick identity starting from that position.</span>';
        draw();
    }

    function clearHighlights(){
        highlights=new Set();
        highlightMode=null;
        selectedCell=null;
        document.getElementById('pascalInfo').innerHTML='<span class="muted">Click any cell to see C(n,k) = C(n-1,k-1) + C(n-1,k)</span>';
        draw();
    }

    cvs.addEventListener('click',handleClick);
    cvs.addEventListener('touchend',function(e){e.preventDefault();handleClick(e);},{passive:false});

    document.getElementById('pascalRowSum').addEventListener('click',highlightRowSums);
    document.getElementById('pascalFib').addEventListener('click',highlightFibonacci);
    document.getElementById('pascalHockey').addEventListener('click',activateHockeyMode);
    document.getElementById('pascalClear').addEventListener('click',clearHighlights);

    document.getElementById('pascalInfo').innerHTML='<span class="muted">Click any cell to see C(n,k) = C(n-1,k-1) + C(n-1,k)</span>';
    draw();
})();


/* ══════════════════════════════════════════════
   SECTION 5a: Multiplication Principle
   ══════════════════════════════════════════════ */
(function(){
    const mSlider=document.getElementById('mulM');
    const nSlider=document.getElementById('mulN');
    const mLabel=document.getElementById('mulMLabel');
    const nLabel=document.getElementById('mulNLabel');
    const cvs=document.getElementById('mulCanvas');
    const ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;

    const shirtColors=['#f472b6','#22d3ee','#fbbf24','#2ecc71','#818cf8','#fb923c'];
    const pantColors=['#a78bfa','#34d399','#f87171','#e879f9','#60a5fa','#fbbf24'];

    function draw(){
        const m=parseInt(mSlider.value);
        const n=parseInt(nSlider.value);
        mLabel.textContent=m;
        nLabel.textContent=n;

        ctx.clearRect(0,0,W,H);
        ctx.fillStyle=BG;ctx.fillRect(0,0,W,H);

        // draw shirts
        const shirtY=40;
        const shirtSpacing=Math.min(50,(W*0.3)/(m));
        const shirtStartX=40;

        ctx.font='11px Georgia';ctx.fillStyle='#808098';ctx.textAlign='left';ctx.textBaseline='bottom';
        ctx.fillText('Shirts (m='+m+')', shirtStartX, shirtY-8);

        for(let i=0;i<m;i++){
            const x=shirtStartX+i*shirtSpacing+15;
            // draw shirt shape (simplified rectangle with collar)
            ctx.fillStyle=shirtColors[i];
            ctx.fillRect(x-10, shirtY, 20, 24);
            ctx.fillRect(x-6, shirtY-4, 12, 6);
            ctx.font='8px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText('S'+(i+1), x, shirtY+12);
        }

        // draw pants
        const pantY=90;
        ctx.font='11px Georgia';ctx.fillStyle='#808098';ctx.textAlign='left';ctx.textBaseline='bottom';
        ctx.fillText('Pants (n='+n+')', shirtStartX, pantY-8);

        const pantSpacing=Math.min(50,(W*0.3)/(n));
        for(let i=0;i<n;i++){
            const x=shirtStartX+i*pantSpacing+15;
            ctx.fillStyle=pantColors[i];
            ctx.fillRect(x-10, pantY, 20, 28);
            // leg split
            ctx.fillStyle=BG;
            ctx.fillRect(x-1, pantY+14, 2, 14);
            ctx.font='8px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText('P'+(i+1), x, pantY+10);
        }

        // draw all pairs in a grid
        const gridStartX=220;
        const gridStartY=25;
        const cellW=Math.min(40, (W-gridStartX-20)/(n+0.5));
        const cellH=Math.min(35, (H-gridStartY-30)/(m+0.5));

        ctx.font='10px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText('All m x n = '+m+' x '+n+' = '+(m*n)+' outfits', (gridStartX+gridStartX+n*cellW)/2, gridStartY-4);

        // column headers (pants)
        for(let j=0;j<n;j++){
            const x=gridStartX+j*cellW+cellW/2;
            ctx.fillStyle=pantColors[j];
            ctx.fillRect(x-6, gridStartY, 12, 14);
            ctx.fillStyle=BG;
            ctx.fillRect(x-0.5, gridStartY+7, 1, 7);
        }

        // row headers (shirts) and cells
        for(let i=0;i<m;i++){
            const y=gridStartY+20+i*cellH;
            // shirt icon
            ctx.fillStyle=shirtColors[i];
            ctx.fillRect(gridStartX-22, y+cellH/2-10, 16, 16);
            ctx.fillRect(gridStartX-19, y+cellH/2-12, 10, 4);

            for(let j=0;j<n;j++){
                const x=gridStartX+j*cellW;
                // outfit cell: shirt on top, pants below
                ctx.fillStyle='rgba(255,255,255,0.03)';
                ctx.fillRect(x+2, y+2, cellW-4, cellH-4);
                ctx.strokeStyle='rgba(255,255,255,0.05)';ctx.lineWidth=0.5;
                ctx.strokeRect(x+2, y+2, cellW-4, cellH-4);

                // mini shirt
                const cx_=x+cellW/2;
                const cy_=y+cellH/2;
                ctx.fillStyle=shirtColors[i];
                ctx.fillRect(cx_-5, cy_-7, 10, 8);
                ctx.fillStyle=pantColors[j];
                ctx.fillRect(cx_-5, cy_+2, 10, 8);
                ctx.fillStyle=BG;
                ctx.fillRect(cx_-0.5, cy_+6, 1, 4);
            }
        }

        document.getElementById('mulFormula').innerHTML=
            '<span class="pink">m &times; n = '+m+' &times; '+n+' = '+(m*n)+' total outfits</span>';
    }

    mSlider.addEventListener('input',draw);
    nSlider.addEventListener('input',draw);
    draw();
})();


/* ══════════════════════════════════════════════
   SECTION 5b: Addition Principle
   ══════════════════════════════════════════════ */
(function(){
    const cvs=document.getElementById('addCanvas');
    const ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;
    const m=4, n=3; // fixed example

    function draw(){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle=BG;ctx.fillRect(0,0,W,H);

        const groupColors=['#f472b6','#22d3ee'];

        // Group A
        ctx.font='12px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText('Route A: '+m+' bus lines', W/4, 35);

        for(let i=0;i<m;i++){
            const x=W/4-(m-1)*25/2+i*50;
            drawCircle(ctx, x, 70, 16, groupColors[0], true);
            ctx.font='11px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText('B'+(i+1), x, 70);
        }

        // Separator
        ctx.strokeStyle='rgba(255,255,255,0.1)';ctx.lineWidth=1;
        ctx.setLineDash([4,4]);
        ctx.beginPath();ctx.moveTo(W/2, 25);ctx.lineTo(W/2, H-25);ctx.stroke();
        ctx.setLineDash([]);
        ctx.font='14px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='middle';
        ctx.fillText('OR', W/2, 90);

        // Group B
        ctx.font='12px Georgia';ctx.fillStyle='#808098';ctx.textAlign='center';ctx.textBaseline='bottom';
        ctx.fillText('Route B: '+n+' train lines', 3*W/4, 35);

        for(let i=0;i<n;i++){
            const x=3*W/4-(n-1)*25/2+i*50;
            drawCircle(ctx, x, 70, 16, groupColors[1], true);
            ctx.font='11px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';
            ctx.fillText('T'+(i+1), x, 70);
        }

        // Total
        ctx.font='13px Courier New';ctx.fillStyle='#f472b6';ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText('Total ways = '+m+' + '+n+' = '+(m+n), W/2, 120);
        ctx.font='10px Georgia';ctx.fillStyle='#808098';
        ctx.fillText('(disjoint choices: you take either a bus or a train, not both)', W/2, 145);
    }

    document.getElementById('addFormula').innerHTML=
        '<span class="pink">m + n = '+m+' + '+n+' = '+(m+n)+'</span> <span class="muted">(disjoint union)</span>';
    draw();
})();


/* ══════════════════════════════════════════════
   SECTION 5c: Inclusion-Exclusion
   ══════════════════════════════════════════════ */
(function(){
    const aSlider=document.getElementById('ieA');
    const bSlider=document.getElementById('ieB');
    const abSlider=document.getElementById('ieAB');
    const aLabel=document.getElementById('ieALabel');
    const bLabel=document.getElementById('ieBLabel');
    const abLabel=document.getElementById('ieABLabel');
    const cvs=document.getElementById('ieCanvas');
    const ctx=cvs.getContext('2d');
    const W=cvs.width, H=cvs.height;

    function draw(){
        let a=parseInt(aSlider.value);
        let b=parseInt(bSlider.value);
        let ab=parseInt(abSlider.value);

        // clamp intersection
        const maxAB=Math.min(a,b);
        abSlider.max=maxAB;
        if(ab>maxAB){ab=maxAB;abSlider.value=ab;}

        aLabel.textContent=a;
        bLabel.textContent=b;
        abLabel.textContent=ab;

        const union=a+b-ab;

        ctx.clearRect(0,0,W,H);
        ctx.fillStyle=BG;ctx.fillRect(0,0,W,H);

        // Venn diagram
        const cxA=W/2-55, cxB=W/2+55;
        const cy=130;
        const rA=Math.min(90, 30+a*5);
        const rB=Math.min(90, 30+b*5);

        // A circle fill
        ctx.globalAlpha=0.12;
        ctx.fillStyle='#f472b6';
        ctx.beginPath();ctx.arc(cxA,cy,rA,0,Math.PI*2);ctx.fill();

        // B circle fill
        ctx.fillStyle='#22d3ee';
        ctx.beginPath();ctx.arc(cxB,cy,rB,0,Math.PI*2);ctx.fill();

        // Intersection highlight
        if(ab>0){
            ctx.globalAlpha=0.2;
            ctx.fillStyle='#fbbf24';
            ctx.beginPath();
            ctx.arc(cxA,cy,rA,0,Math.PI*2);
            ctx.clip();
            ctx.beginPath();
            ctx.arc(cxB,cy,rB,0,Math.PI*2);
            ctx.fill();
            ctx.restore&&ctx.restore();
            // reset clip
            ctx.save();
            ctx.setTransform(1,0,0,1,0,0);
            ctx.restore();
        }
        ctx.globalAlpha=1;

        // re-draw without clip issues — use canvas save/restore properly
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle=BG;ctx.fillRect(0,0,W,H);

        // Draw A only region
        ctx.save();
        ctx.beginPath();ctx.arc(cxA,cy,rA,0,Math.PI*2);ctx.clip();
        ctx.fillStyle='rgba(244,114,182,0.12)';
        ctx.fillRect(0,0,W,H);
        ctx.restore();

        // Draw B only region
        ctx.save();
        ctx.beginPath();ctx.arc(cxB,cy,rB,0,Math.PI*2);ctx.clip();
        ctx.fillStyle='rgba(34,211,238,0.12)';
        ctx.fillRect(0,0,W,H);
        ctx.restore();

        // Draw intersection
        if(ab>0){
            ctx.save();
            ctx.beginPath();ctx.arc(cxA,cy,rA,0,Math.PI*2);ctx.clip();
            ctx.beginPath();ctx.arc(cxB,cy,rB,0,Math.PI*2);ctx.clip();
            ctx.fillStyle='rgba(251,191,36,0.2)';
            ctx.fillRect(0,0,W,H);
            ctx.restore();
        }

        // circle outlines
        ctx.strokeStyle='rgba(244,114,182,0.5)';ctx.lineWidth=2;
        ctx.beginPath();ctx.arc(cxA,cy,rA,0,Math.PI*2);ctx.stroke();

        ctx.strokeStyle='rgba(34,211,238,0.5)';ctx.lineWidth=2;
        ctx.beginPath();ctx.arc(cxB,cy,rB,0,Math.PI*2);ctx.stroke();

        // Labels
        ctx.font='14px Georgia';ctx.textAlign='center';ctx.textBaseline='middle';
        ctx.fillStyle='#f472b6';
        ctx.fillText('A', cxA-rA/2-10, cy-10);
        ctx.fillText(a, cxA-rA/2-10, cy+12);

        ctx.fillStyle='#22d3ee';
        ctx.fillText('B', cxB+rB/2+10, cy-10);
        ctx.fillText(b, cxB+rB/2+10, cy+12);

        if(ab>0){
            ctx.fillStyle='#fbbf24';
            ctx.fillText(ab, (cxA+cxB)/2, cy);
            ctx.font='9px Georgia';
            ctx.fillText('A\u2229B', (cxA+cxB)/2, cy-16);
        }

        // formula display
        ctx.font='13px Courier New';ctx.fillStyle='#f472b6';ctx.textAlign='center';ctx.textBaseline='top';
        ctx.fillText('|A \u222A B| = |A| + |B| - |A \u2229 B| = '+a+' + '+b+' - '+ab+' = '+union, W/2, cy+rA+20);

        // draw dots to represent elements
        const dotR=3;
        const onlyA=a-ab;
        const onlyB=b-ab;

        // dots in A only
        drawDots(ctx, cxA-rA/2-5, cy, onlyA, dotR, '#f472b6', rA*0.6);

        // dots in B only
        drawDots(ctx, cxB+rB/2+5, cy, onlyB, dotR, '#22d3ee', rB*0.6);

        // dots in intersection
        if(ab>0){
            drawDots(ctx, (cxA+cxB)/2, cy+20, ab, dotR, '#fbbf24', 25);
        }

        document.getElementById('ieFormula').innerHTML=
            '<span class="pink">|A &cup; B| = '+a+' + '+b+' - '+ab+' = '+union+'</span>';
    }

    function drawDots(ctx, cx, cy, count, r, color, spread){
        if(count<=0) return;
        // arrange dots in a pattern
        const cols=Math.ceil(Math.sqrt(count));
        const rows=Math.ceil(count/cols);
        const spacing=Math.min(r*3, spread*2/Math.max(cols,1));
        const startX=cx-(cols-1)*spacing/2;
        const startY=cy-(rows-1)*spacing/2;

        ctx.fillStyle=color;
        for(let i=0;i<count;i++){
            const col=i%cols;
            const row=Math.floor(i/cols);
            ctx.globalAlpha=0.6;
            ctx.beginPath();ctx.arc(startX+col*spacing, startY+row*spacing, r, 0, Math.PI*2);ctx.fill();
        }
        ctx.globalAlpha=1;
    }

    aSlider.addEventListener('input',draw);
    bSlider.addEventListener('input',draw);
    abSlider.addEventListener('input',draw);
    draw();
})();

</script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Coded by <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
