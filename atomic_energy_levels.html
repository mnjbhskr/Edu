<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Atom — Energy Levels, Excitation & Photon Emission</title>
    <meta name="description" content="Visualise atomic energy levels, electron transitions, and photon emission. Interactive quantum mechanics of the hydrogen atom.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', Arial, sans-serif;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 { font-size: 24px; margin-bottom: 2px; color: #f0f0f0; }
        .subtitle { font-size: 14px; color: #aaa; margin-bottom: 6px; }
        .analogy {
            max-width: 960px;
            text-align: center;
            font-size: 14px;
            color: #f0c040;
            margin: 6px 0 14px 0;
        }
        .main-row {
            display: flex;
            gap: 18px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        .canvas-col {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        canvas {
            background: #0d0d24;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 270px;
            max-width: 290px;
        }
        .card {
            background: #16213e;
            border-radius: 10px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
            padding: 14px 16px;
        }
        .card-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #7da2e0;
            margin-bottom: 8px;
        }
        button {
            background: #0f3460;
            color: #e0e0e0;
            border: 1px solid #1a5276;
            padding: 7px 14px;
            border-radius: 7px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        button:hover { background: #1a5276; }
        button:active { transform: scale(0.96); }
        button.active { background: #e94560; border-color: #e94560; }
        button.photon-btn { background: #7b2d8b; border-color: #9b59b6; }
        button.photon-btn:hover { background: #9b59b6; }
        .btn-row { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 6px; }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 4px 0;
        }
        .slider-row label { font-size: 12px; min-width: 50px; color: #aaa; }
        .slider-row input[type=range] { flex: 1; }
        .slider-row .val { font-size: 12px; min-width: 36px; text-align: right; font-family: monospace; }
        .level-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            font-size: 12px;
            cursor: pointer;
            transition: background 0.15s;
            border-radius: 4px;
            padding: 4px 6px;
        }
        .level-row:hover { background: rgba(255,255,255,0.05); }
        .level-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .level-name { flex: 1; }
        .level-energy { font-family: monospace; color: #aaa; }
        .photon-log {
            max-height: 130px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.5;
        }
        .photon-log::-webkit-scrollbar { width: 4px; }
        .photon-log::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }
        .photon-entry { padding: 2px 0; border-bottom: 1px solid rgba(255,255,255,0.03); }
        .insight-box {
            background: rgba(240,192,64,0.08);
            border: 1px solid rgba(240,192,64,0.15);
            border-radius: 8px;
            padding: 12px;
            font-size: 12px;
            line-height: 1.5;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            margin: 2px 0;
        }
        .legend-swatch {
            width: 14px;
            height: 4px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        .trans-table {
            width: 100%;
            font-size: 10px;
            border-collapse: collapse;
        }
        .trans-table th {
            text-align: left;
            color: #7da2e0;
            font-weight: normal;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
            padding: 3px 4px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .trans-table td {
            padding: 2px 4px;
            border-bottom: 1px solid rgba(255,255,255,0.03);
        }
        .trans-table tr:hover { background: rgba(255,255,255,0.04); }
    </style>
</head>
<body>
    <h1>The Atom — Energy Levels & Photon Emission</h1>
    <div class="subtitle">How electrons jump between orbits and create light</div>
    <div class="analogy">
        Imagine a staircase where each step is an energy level. Electrons can only stand on steps, never between them.
        To go up, they must absorb exactly the right amount of energy. When they jump back down, they release that energy as a flash of light — a photon.
    </div>

    <div class="main-row">
        <div class="canvas-col">
            <canvas id="atomCanvas" width="600" height="600"></canvas>
            <canvas id="specCanvas" width="600" height="80"></canvas>
            <div style="font-size:10px; color:#444; text-align:center; margin-top:2px;">Emission spectrum — each line is a photon colour from a specific transition</div>
        </div>
        <div class="side-panel">
            <div class="card">
                <div class="card-title">Controls</div>
                <div class="btn-row">
                    <button id="btnAbsorb" class="photon-btn" onclick="firePhoton()">Absorb Photon</button>
                    <button id="btnReset" onclick="resetAtom()">Reset</button>
                    <button id="btnAuto" onclick="toggleAuto()">Auto Mode</button>
                    <button id="btnAllTrans" onclick="toggleAllTransitions()">All Transitions</button>
                </div>
                <div style="font-size:11px; color:#888; margin-bottom:6px;">Click an energy level below to move the electron there:</div>
                <div id="levelRows"></div>
            </div>
            <div class="card">
                <div class="card-title">Energy Diagram</div>
                <canvas id="diagCanvas" width="258" height="200"></canvas>
            </div>
            <div class="card" id="transTableCard" style="display:none;">
                <div class="card-title">All 15 Transitions — Hydrogen Atom</div>
                <div style="max-height:300px; overflow-y:auto;" id="transTableWrap"></div>
            </div>
            <div class="card">
                <div class="card-title">Photon Log</div>
                <div id="photonLog" class="photon-log"><span style="color:#555;">No transitions yet...</span></div>
            </div>
            <div class="card">
                <div class="card-title">Spectrum Legend</div>
                <div id="legend"></div>
            </div>
            <div class="card">
                <div class="card-title">Insight</div>
                <div id="insightBox" class="insight-box">
                    <b>The Bohr Model:</b> Electrons orbit the nucleus only at specific allowed radii.
                    Each orbit has a fixed energy. The innermost orbit (n=1) is the <b>ground state</b> — the lowest energy an electron can have.
                    Higher orbits (n=2, 3, ...) are <b>excited states</b>.
                    <br><br>
                    Click <b>"Absorb Photon"</b> to send in energy, or click an energy level directly.
                </div>
            </div>
        </div>
    </div>

    <script>
        // ---- Constants ----
        const atomC = document.getElementById('atomCanvas');
        const actx = atomC.getContext('2d');
        const AW = atomC.width, AH = atomC.height;
        const cx = AW / 2, cy = AH / 2;

        const specC = document.getElementById('specCanvas');
        const sctx = specC.getContext('2d');

        const diagC = document.getElementById('diagCanvas');
        const dctx = diagC.getContext('2d');

        // Hydrogen-like energy levels (eV) — E_n = -13.6 / n^2
        const levels = [];
        const nMax = 6;
        for (let n = 1; n <= nMax; n++) {
            levels.push({
                n: n,
                energy: -13.6 / (n * n),
                radius: 40 + (n * n) * 8.5,  // visual radius scaled for beauty
                color: ['#e94560','#ff6b35','#f0c040','#2ecc71','#3b82f6','#a78bfa'][n - 1],
                label: 'n=' + n,
            });
        }

        // ---- State ----
        let currentLevel = 0;  // index into levels (0 = ground state n=1)
        let targetLevel = 0;
        let transitioning = false;
        let transProgress = 0;
        let transDir = 0;  // +1 = absorb (up), -1 = emit (down)
        let electronAngle = 0;
        let electronSpeed = 0.02;
        let autoMode = false;
        let autoTimer = 0;
        let photons = [];       // flying photon particles
        let emittedPhotons = []; // log of emitted wavelengths for spectrum
        let nucleusPulse = 0;
        let showAllTransitions = false;

        // ---- Photon wavelength from energy difference ----
        function energyToWavelength(dE) {
            // dE in eV, returns wavelength in nm
            // E = hc/lambda => lambda = hc/E
            // hc = 1240 eV·nm
            return 1240 / Math.abs(dE);
        }

        function wavelengthToColor(wl) {
            // Attempt visible spectrum mapping (380-780nm)
            // Below 380: UV (show as violet)
            // Above 780: IR (show as dark red)
            let r = 0, g = 0, b = 0;
            if (wl < 380) { r = 0.6; g = 0; b = 1; }
            else if (wl < 440) { r = -(wl - 440) / 60; g = 0; b = 1; }
            else if (wl < 490) { r = 0; g = (wl - 440) / 50; b = 1; }
            else if (wl < 510) { r = 0; g = 1; b = -(wl - 510) / 20; }
            else if (wl < 580) { r = (wl - 510) / 70; g = 1; b = 0; }
            else if (wl < 645) { r = 1; g = -(wl - 645) / 65; b = 0; }
            else if (wl < 780) { r = 1; g = 0; b = 0; }
            else { r = 0.5; g = 0; b = 0; }

            // Intensity falloff at edges
            let factor = 1;
            if (wl < 380) factor = 0.5;
            else if (wl < 420) factor = 0.3 + 0.7 * (wl - 380) / 40;
            else if (wl > 700) factor = 0.3 + 0.7 * (780 - wl) / 80;
            if (wl > 780) factor = 0.3;

            r = Math.pow(r * factor, 0.8);
            g = Math.pow(g * factor, 0.8);
            b = Math.pow(b * factor, 0.8);
            return 'rgb(' + Math.round(r * 255) + ',' + Math.round(g * 255) + ',' + Math.round(b * 255) + ')';
        }

        function wavelengthToHexColor(wl) {
            const c = wavelengthToColor(wl);
            return c; // already rgb string
        }

        // ---- All possible transitions (precomputed) ----
        const seriesNames = ['Lyman','Balmer','Paschen','Brackett','Pfund'];
        const seriesColors = ['#a78bfa','#3b82f6','#2ecc71','#f0c040','#ff6b35'];
        const allTransitions = [];
        for (let hi = 1; hi < nMax; hi++) {
            for (let lo = 0; lo < hi; lo++) {
                const dE = levels[lo].energy - levels[hi].energy;
                const wl = energyToWavelength(dE);
                allTransitions.push({
                    from: hi, to: lo,
                    nFrom: levels[hi].n, nTo: levels[lo].n,
                    dE: dE, wl: wl,
                    color: wavelengthToColor(wl),
                    series: seriesNames[lo],
                    seriesColor: seriesColors[lo],
                    band: wl < 380 ? 'UV' : (wl > 780 ? 'IR' : 'Visible'),
                });
            }
        }

        function toggleAllTransitions() {
            showAllTransitions = !showAllTransitions;
            document.getElementById('btnAllTrans').classList.toggle('active', showAllTransitions);
            document.getElementById('transTableCard').style.display = showAllTransitions ? '' : 'none';
            if (showAllTransitions) {
                buildTransTable();
                fillAllSpectrum();
                updateInsightText(
                    '<b>All 15 emission transitions</b> for hydrogen (n=1 to n=6). '
                    + 'Each coloured arrow shows an electron dropping from a higher orbit to a lower one, releasing a photon whose colour matches the arrow. '
                    + '<br><br><b>Series:</b> '
                    + '<span style="color:#a78bfa;">Lyman</span> (to n=1, UV) | '
                    + '<span style="color:#3b82f6;">Balmer</span> (to n=2, visible) | '
                    + '<span style="color:#2ecc71;">Paschen</span> (to n=3, IR) | '
                    + '<span style="color:#f0c040;">Brackett</span> (to n=4, IR) | '
                    + '<span style="color:#ff6b35;">Pfund</span> (to n=5, far IR)'
                    + '<br><br>The Balmer series produces the characteristic <b>red (H\u03B1 656nm)</b>, <b>blue-green (H\u03B2 486nm)</b>, and <b>violet (H\u03B3/H\u03B4)</b> lines visible in hydrogen discharge tubes.'
                );
            } else {
                updateSpectrum();
            }
        }

        function buildTransTable() {
            const wrap = document.getElementById('transTableWrap');
            let html = '<table class="trans-table"><tr><th></th><th>Jump</th><th>Series</th><th>\u0394E (eV)</th><th>\u03BB (nm)</th><th>Band</th></tr>';
            allTransitions.forEach(t => {
                html += '<tr>'
                    + '<td><span style="color:' + t.color + ';">\u25CF</span></td>'
                    + '<td style="font-family:monospace;">n=' + t.nFrom + ' \u2192 n=' + t.nTo + '</td>'
                    + '<td style="color:' + t.seriesColor + ';">' + t.series + '</td>'
                    + '<td style="font-family:monospace;">' + t.dE.toFixed(2) + '</td>'
                    + '<td style="font-family:monospace;">' + Math.round(t.wl) + '</td>'
                    + '<td style="color:' + (t.band === 'UV' ? '#a78bfa' : (t.band === 'Visible' ? '#2ecc71' : '#ff6b35')) + ';">' + t.band + '</td>'
                    + '</tr>';
            });
            html += '</table>';
            wrap.innerHTML = html;
        }

        function fillAllSpectrum() {
            sctx.clearRect(0, 0, specC.width, specC.height);
            sctx.fillStyle = '#050510';
            sctx.fillRect(0, 0, specC.width, specC.height);
            const wlMin = 80, wlMax = 2000;
            function wlToX(wl) { return (Math.log(wl) - Math.log(wlMin)) / (Math.log(wlMax) - Math.log(wlMin)) * specC.width; }
            const vl = wlToX(380), vr = wlToX(780);
            const grad = sctx.createLinearGradient(vl, 0, vr, 0);
            grad.addColorStop(0, 'rgba(100,0,200,0.08)');
            grad.addColorStop(0.2, 'rgba(0,0,255,0.08)');
            grad.addColorStop(0.4, 'rgba(0,200,0,0.08)');
            grad.addColorStop(0.6, 'rgba(255,255,0,0.08)');
            grad.addColorStop(0.8, 'rgba(255,100,0,0.08)');
            grad.addColorStop(1, 'rgba(255,0,0,0.08)');
            sctx.fillStyle = grad;
            sctx.fillRect(vl, 0, vr - vl, specC.height);
            sctx.font = '9px monospace';
            sctx.fillStyle = '#444';
            sctx.textAlign = 'center';
            [100, 200, 400, 600, 800, 1000, 1500].forEach(wl => {
                sctx.fillText(wl + 'nm', wlToX(wl), specC.height - 3);
            });
            sctx.fillStyle = '#333';
            sctx.fillText('UV', wlToX(200), 10);
            sctx.fillText('Visible', wlToX(550), 10);
            sctx.fillText('IR', wlToX(1200), 10);
            allTransitions.forEach(t => {
                const x = wlToX(t.wl);
                sctx.save();
                sctx.strokeStyle = t.color;
                sctx.lineWidth = 2;
                sctx.shadowBlur = 8;
                sctx.shadowColor = t.color;
                sctx.beginPath();
                sctx.moveTo(x, 15);
                sctx.lineTo(x, specC.height - 12);
                sctx.stroke();
                sctx.shadowBlur = 0;
                sctx.font = '7px monospace';
                sctx.fillStyle = t.color;
                sctx.textAlign = 'center';
                sctx.fillText(t.nFrom + '\u2192' + t.nTo, x, 22);
                sctx.restore();
            });
        }

        // ---- Transition logic ----
        function startTransition(from, to) {
            if (transitioning) return;
            if (from === to) return;
            targetLevel = to;
            transDir = to > from ? 1 : -1;
            transitioning = true;
            transProgress = 0;

            const dE = levels[to].energy - levels[from].energy;
            const wl = energyToWavelength(dE);
            const photonColor = wavelengthToColor(wl);

            if (transDir === -1) {
                // Emission — electron drops, photon flies outward
                emittedPhotons.push({ from: from, to: to, wl: wl, color: photonColor });
                logPhoton(from, to, dE, wl, photonColor);
                updateSpectrum();
            } else {
                // Absorption
                logAbsorb(from, to, dE, wl, photonColor);
            }

            updateInsight(from, to, transDir);
        }

        function firePhoton() {
            if (transitioning) return;
            if (currentLevel >= nMax - 1) {
                // Already at highest level — can't absorb more
                updateInsightText('<b>Maximum energy!</b> The electron is already at the highest level (n=' + nMax + '). It can\'t absorb more energy in this model. Click a lower level or Reset to bring it back down.');
                return;
            }
            // Absorb: go up one level (simplification — in reality, photon must match exactly)
            const target = Math.min(currentLevel + 1 + Math.floor(Math.random() * 2), nMax - 1);
            spawnIncomingPhoton(target);
            startTransition(currentLevel, target);
        }

        function spawnIncomingPhoton(targetLvl) {
            const dE = levels[targetLvl].energy - levels[currentLevel].energy;
            const wl = energyToWavelength(dE);
            const angle = Math.random() * Math.PI * 2;
            const dist = 320;
            photons.push({
                x: cx + Math.cos(angle) * dist,
                y: cy + Math.sin(angle) * dist,
                tx: cx, ty: cy,
                speed: 6,
                color: wavelengthToColor(wl),
                wl: wl,
                type: 'absorb',
                alive: true,
                trail: [],
            });
        }

        function spawnEmittedPhoton(fromLevel) {
            const angle = Math.random() * Math.PI * 2;
            const r = levels[fromLevel].radius;
            const ex = cx + Math.cos(electronAngle) * r;
            const ey = cy + Math.sin(electronAngle) * r;
            const dE = levels[currentLevel].energy - levels[targetLevel].energy;
            const wl = energyToWavelength(dE);
            photons.push({
                x: ex, y: ey,
                tx: ex + Math.cos(angle) * 400,
                ty: ey + Math.sin(angle) * 400,
                speed: 4,
                color: wavelengthToColor(wl),
                wl: wl,
                type: 'emit',
                alive: true,
                trail: [],
            });
        }

        function resetAtom() {
            if (currentLevel === 0 && !transitioning) return;
            if (transitioning) return;
            // Cascade down to ground state
            if (currentLevel > 0) {
                startTransition(currentLevel, 0);
            }
        }

        let autoRunning = false;
        function toggleAuto() {
            autoRunning = !autoRunning;
            document.getElementById('btnAuto').classList.toggle('active', autoRunning);
            if (autoRunning) {
                updateInsightText('<b>Auto Mode ON:</b> The atom will continuously absorb and emit photons, cycling through energy levels. Watch the spectrum build up below — each coloured line corresponds to a specific transition.');
            }
        }

        // ---- Logging ----
        function logPhoton(from, to, dE, wl, color) {
            const log = document.getElementById('photonLog');
            const isUV = wl < 380;
            const isIR = wl > 780;
            const band = isUV ? ' (UV)' : (isIR ? ' (IR)' : ' (visible)');
            const entry = document.createElement('div');
            entry.className = 'photon-entry';
            entry.innerHTML = '<span style="color:' + color + ';">\u25CF</span> '
                + 'n=' + levels[from].n + ' \u2192 n=' + levels[to].n
                + ' | \u0394E = ' + Math.abs(dE).toFixed(2) + ' eV'
                + ' | \u03BB = ' + Math.round(wl) + 'nm' + band;
            if (log.querySelector('span')) log.innerHTML = '';
            log.prepend(entry);
        }

        function logAbsorb(from, to, dE, wl, color) {
            const log = document.getElementById('photonLog');
            const entry = document.createElement('div');
            entry.className = 'photon-entry';
            entry.innerHTML = '<span style="color:' + color + ';">\u25CB</span> '
                + '<span style="color:#f0c040;">ABSORB</span> n=' + levels[from].n + ' \u2192 n=' + levels[to].n
                + ' | +' + Math.abs(dE).toFixed(2) + ' eV'
                + ' | \u03BB = ' + Math.round(wl) + 'nm';
            if (log.querySelector('span')) log.innerHTML = '';
            log.prepend(entry);
        }

        // ---- Insight ----
        function updateInsight(from, to, dir) {
            const box = document.getElementById('insightBox');
            const dE = Math.abs(levels[to].energy - levels[from].energy);
            const wl = energyToWavelength(dE);
            if (dir === 1) {
                box.innerHTML = '<b>Absorption (excitation):</b> The electron absorbed a photon with energy '
                    + dE.toFixed(2) + ' eV (\u03BB = ' + Math.round(wl) + ' nm) and jumped from '
                    + '<b>n=' + levels[from].n + '</b> to <b>n=' + levels[to].n + '</b>.'
                    + '<br><br>The electron is now in an <b>excited state</b> — unstable and eager to fall back down. '
                    + 'Excited states typically last only ~10\u207B\u2078 seconds before the electron drops back.';
            } else {
                const isUV = wl < 380, isIR = wl > 780;
                const band = isUV ? 'ultraviolet (invisible to our eyes)' : (isIR ? 'infrared (invisible heat radiation)' : 'visible light');
                box.innerHTML = '<b>Emission:</b> The electron dropped from <b>n=' + levels[from].n + '</b> to <b>n=' + levels[to].n + '</b>, '
                    + 'releasing a photon with energy ' + dE.toFixed(2) + ' eV (\u03BB = ' + Math.round(wl) + ' nm).'
                    + '<br><br>This photon is ' + band + '. '
                    + (to === 0 ? 'Transitions to n=1 produce the <b>Lyman series</b> (UV). ' : '')
                    + (to === 1 ? 'Transitions to n=2 produce the <b>Balmer series</b> (visible). ' : '')
                    + (to === 2 ? 'Transitions to n=3 produce the <b>Paschen series</b> (IR). ' : '')
                    + 'This is how atoms create <b>line spectra</b> — discrete colours, not a continuous rainbow.';
            }
        }

        function updateInsightText(html) {
            document.getElementById('insightBox').innerHTML = html;
        }

        // ---- Build energy level rows ----
        const levelRowsDiv = document.getElementById('levelRows');
        levels.forEach((lv, i) => {
            const row = document.createElement('div');
            row.className = 'level-row';
            row.innerHTML = '<div class="level-dot" style="background:' + lv.color + ';"></div>'
                + '<span class="level-name">' + lv.label + (i === 0 ? ' (ground)' : '') + '</span>'
                + '<span class="level-energy">' + lv.energy.toFixed(2) + ' eV</span>';
            row.onclick = () => {
                if (transitioning) return;
                if (i !== currentLevel) startTransition(currentLevel, i);
            };
            levelRowsDiv.appendChild(row);
        });

        // ---- Spectrum ----
        function updateSpectrum() {
            if (showAllTransitions) { fillAllSpectrum(); return; }
            sctx.clearRect(0, 0, specC.width, specC.height);
            // Dark background
            sctx.fillStyle = '#050510';
            sctx.fillRect(0, 0, specC.width, specC.height);

            // Wavelength range: 80nm to 2000nm mapped across canvas
            const wlMin = 80, wlMax = 2000;
            function wlToX(wl) { return (Math.log(wl) - Math.log(wlMin)) / (Math.log(wlMax) - Math.log(wlMin)) * specC.width; }

            // Draw faint visible range background
            const vl = wlToX(380), vr = wlToX(780);
            const grad = sctx.createLinearGradient(vl, 0, vr, 0);
            grad.addColorStop(0, 'rgba(100,0,200,0.08)');
            grad.addColorStop(0.2, 'rgba(0,0,255,0.08)');
            grad.addColorStop(0.4, 'rgba(0,200,0,0.08)');
            grad.addColorStop(0.6, 'rgba(255,255,0,0.08)');
            grad.addColorStop(0.8, 'rgba(255,100,0,0.08)');
            grad.addColorStop(1, 'rgba(255,0,0,0.08)');
            sctx.fillStyle = grad;
            sctx.fillRect(vl, 0, vr - vl, specC.height);

            // Labels
            sctx.font = '9px monospace';
            sctx.fillStyle = '#444';
            sctx.textAlign = 'center';
            [100, 200, 400, 600, 800, 1000, 1500].forEach(wl => {
                const x = wlToX(wl);
                sctx.fillText(wl + 'nm', x, specC.height - 3);
            });
            sctx.fillStyle = '#333';
            sctx.fillText('UV', wlToX(200), 10);
            sctx.fillText('Visible', wlToX(550), 10);
            sctx.fillText('IR', wlToX(1200), 10);

            // Draw emission lines
            emittedPhotons.forEach(p => {
                const x = wlToX(p.wl);
                sctx.strokeStyle = p.color;
                sctx.lineWidth = 2;
                sctx.shadowBlur = 8;
                sctx.shadowColor = p.color;
                sctx.beginPath();
                sctx.moveTo(x, 15);
                sctx.lineTo(x, specC.height - 12);
                sctx.stroke();
                sctx.shadowBlur = 0;
            });
        }

        // ---- Energy level diagram (side panel) ----
        function drawDiagram() {
            const dw = diagC.width, dh = diagC.height;
            dctx.clearRect(0, 0, dw, dh);

            const pad = 20;
            const eMin = levels[0].energy;  // -13.6
            const eMax = 0;
            function eToY(e) { return pad + (1 - (e - eMin) / (eMax - eMin)) * (dh - 2 * pad); }

            // Draw levels
            levels.forEach((lv, i) => {
                const y = eToY(lv.energy);
                dctx.strokeStyle = i === currentLevel ? lv.color : 'rgba(255,255,255,0.15)';
                dctx.lineWidth = i === currentLevel ? 3 : 1;
                dctx.beginPath();
                dctx.moveTo(60, y);
                dctx.lineTo(dw - 20, y);
                dctx.stroke();

                // Label
                dctx.fillStyle = i === currentLevel ? lv.color : '#555';
                dctx.font = (i === currentLevel ? 'bold ' : '') + '11px monospace';
                dctx.textAlign = 'right';
                dctx.fillText(lv.label, 55, y + 4);
                dctx.textAlign = 'left';
                dctx.fillText(lv.energy.toFixed(2) + ' eV', dw - 18, y + 4);
            });

            // All transitions Grotrian overlay
            if (showAllTransitions) {
                const seriesBaseX = { 'Lyman': 75, 'Balmer': 105, 'Paschen': 135, 'Brackett': 160, 'Pfund': 180 };
                // Group transitions by series to offset within each group
                const groups = {};
                allTransitions.forEach(t => {
                    if (!groups[t.series]) groups[t.series] = [];
                    groups[t.series].push(t);
                });
                Object.entries(groups).forEach(([series, trans]) => {
                    const baseX = seriesBaseX[series];
                    const n = trans.length;
                    trans.forEach((t, i) => {
                        const xOff = (i - (n - 1) / 2) * 5;
                        const x = baseX + xOff;
                        const y1 = eToY(levels[t.from].energy);
                        const y2 = eToY(levels[t.to].energy);
                        dctx.save();
                        dctx.strokeStyle = t.color;
                        dctx.lineWidth = 1.5;
                        dctx.globalAlpha = 0.8;
                        dctx.beginPath();
                        dctx.moveTo(x, y1 - 2);
                        dctx.lineTo(x, y2 + 2);
                        dctx.stroke();
                        // Arrowhead pointing down (to lower level)
                        dctx.beginPath();
                        dctx.moveTo(x, y2 + 2);
                        dctx.lineTo(x - 3, y2 - 4);
                        dctx.lineTo(x + 3, y2 - 4);
                        dctx.fillStyle = t.color;
                        dctx.globalAlpha = 0.9;
                        dctx.fill();
                        dctx.restore();
                    });
                });
                // Series labels at top
                Object.entries(seriesBaseX).forEach(([name, x]) => {
                    const idx = seriesNames.indexOf(name);
                    dctx.font = 'bold 8px monospace';
                    dctx.fillStyle = seriesColors[idx];
                    dctx.textAlign = 'center';
                    dctx.fillText(name.substring(0, 2), x, 12);
                });
            }

            // Ionisation level (E=0)
            dctx.strokeStyle = 'rgba(255,255,255,0.08)';
            dctx.setLineDash([4, 4]);
            dctx.beginPath();
            dctx.moveTo(60, eToY(0));
            dctx.lineTo(dw - 20, eToY(0));
            dctx.stroke();
            dctx.setLineDash([]);
            dctx.fillStyle = '#444';
            dctx.font = '9px monospace';
            dctx.textAlign = 'right';
            dctx.fillText('ionise', 55, eToY(0) + 4);

            // Electron indicator
            const ey = eToY(levels[currentLevel].energy);
            dctx.beginPath();
            dctx.arc(dw / 2 + 20, ey, 5, 0, Math.PI * 2);
            dctx.fillStyle = levels[currentLevel].color;
            dctx.fill();
            dctx.strokeStyle = '#fff';
            dctx.lineWidth = 1.5;
            dctx.stroke();

            // If transitioning, draw arrow
            if (transitioning) {
                const fromY = eToY(levels[currentLevel].energy);
                const toY = eToY(levels[targetLevel].energy);
                const arrowX = dw / 2 + 20;
                dctx.save();
                dctx.strokeStyle = transDir === 1 ? '#f0c040' : levels[currentLevel].color;
                dctx.lineWidth = 2;
                dctx.setLineDash([3, 3]);
                dctx.beginPath();
                dctx.moveTo(arrowX, fromY);
                dctx.lineTo(arrowX, toY);
                dctx.stroke();
                dctx.setLineDash([]);
                // Arrowhead
                const dy = toY > fromY ? 6 : -6;
                dctx.beginPath();
                dctx.moveTo(arrowX, toY);
                dctx.lineTo(arrowX - 4, toY - dy);
                dctx.lineTo(arrowX + 4, toY - dy);
                dctx.fillStyle = transDir === 1 ? '#f0c040' : levels[currentLevel].color;
                dctx.fill();
                dctx.restore();
            }
        }

        // ---- Build legend ----
        function buildLegend() {
            const div = document.getElementById('legend');
            const series = [
                { name: 'Lyman (to n=1)', color: '#a78bfa', note: 'UV' },
                { name: 'Balmer (to n=2)', color: '#3b82f6', note: 'Visible' },
                { name: 'Paschen (to n=3)', color: '#2ecc71', note: 'IR' },
            ];
            series.forEach(s => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = '<div class="legend-swatch" style="background:' + s.color + ';"></div>'
                    + '<span>' + s.name + ' <span style="color:#666;">(' + s.note + ')</span></span>';
                div.appendChild(item);
            });
        }
        buildLegend();

        // ---- Main atom drawing ----
        function drawAtom() {
            actx.clearRect(0, 0, AW, AH);

            // Starfield background
            if (!drawAtom._stars) {
                drawAtom._stars = [];
                for (let i = 0; i < 60; i++) {
                    drawAtom._stars.push({
                        x: Math.random() * AW,
                        y: Math.random() * AH,
                        r: Math.random() * 1.2,
                        a: Math.random() * 0.3 + 0.05,
                    });
                }
            }
            drawAtom._stars.forEach(s => {
                actx.beginPath();
                actx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                actx.fillStyle = 'rgba(255,255,255,' + s.a + ')';
                actx.fill();
            });

            // Draw orbit rings
            levels.forEach((lv, i) => {
                actx.beginPath();
                actx.arc(cx, cy, lv.radius, 0, Math.PI * 2);
                if (i === currentLevel || i === targetLevel) {
                    actx.strokeStyle = lv.color + '40';
                    actx.lineWidth = 2;
                } else {
                    actx.strokeStyle = 'rgba(255,255,255,0.06)';
                    actx.lineWidth = 1;
                }
                actx.stroke();

                // Orbit label
                actx.fillStyle = i === currentLevel ? lv.color : 'rgba(255,255,255,0.15)';
                actx.font = '10px monospace';
                actx.textAlign = 'left';
                actx.fillText(lv.label, cx + lv.radius + 4, cy - 4);
            });

            // All transitions overlay on atom
            if (showAllTransitions) {
                allTransitions.forEach((t, i) => {
                    const angle = (i / allTransitions.length) * Math.PI * 2 - Math.PI / 2;
                    const r1 = levels[t.from].radius;
                    const r2 = levels[t.to].radius;
                    const x1 = cx + Math.cos(angle) * r1;
                    const y1 = cy + Math.sin(angle) * r1;
                    const x2 = cx + Math.cos(angle) * r2;
                    const y2 = cy + Math.sin(angle) * r2;

                    actx.save();
                    actx.strokeStyle = t.color;
                    actx.lineWidth = 2;
                    actx.globalAlpha = 0.55;

                    // Glow
                    actx.shadowBlur = 6;
                    actx.shadowColor = t.color;

                    actx.beginPath();
                    actx.moveTo(x1, y1);
                    actx.lineTo(x2, y2);
                    actx.stroke();
                    actx.shadowBlur = 0;

                    // Arrowhead at inner end
                    const dx = x2 - x1, dy = y2 - y1;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 0) {
                        const ux = dx / len, uy = dy / len;
                        const ax = x2 - ux * 8, ay = y2 - uy * 8;
                        actx.beginPath();
                        actx.moveTo(x2, y2);
                        actx.lineTo(ax - uy * 4, ay + ux * 4);
                        actx.lineTo(ax + uy * 4, ay - ux * 4);
                        actx.closePath();
                        actx.fillStyle = t.color;
                        actx.globalAlpha = 0.8;
                        actx.fill();
                    }

                    // Wavelength label at midpoint (only for Balmer series — visible and most important)
                    if (t.series === 'Balmer') {
                        const mx = (x1 + x2) / 2;
                        const my = (y1 + y2) / 2;
                        const perpX = -(y2 - y1) / len;
                        const perpY = (x2 - x1) / len;
                        actx.font = 'bold 9px monospace';
                        actx.fillStyle = t.color;
                        actx.globalAlpha = 0.9;
                        actx.textAlign = 'center';
                        actx.fillText(Math.round(t.wl) + 'nm', mx + perpX * 14, my + perpY * 14);
                    }

                    actx.restore();
                });

                // Small dot at each arrow's outer end
                allTransitions.forEach((t, i) => {
                    const angle = (i / allTransitions.length) * Math.PI * 2 - Math.PI / 2;
                    const x = cx + Math.cos(angle) * levels[t.from].radius;
                    const y = cy + Math.sin(angle) * levels[t.from].radius;
                    actx.beginPath();
                    actx.arc(x, y, 2.5, 0, Math.PI * 2);
                    actx.fillStyle = t.color;
                    actx.globalAlpha = 0.6;
                    actx.fill();
                    actx.globalAlpha = 1;
                });
            }

            // Nucleus
            nucleusPulse += 0.03;
            const nr = 14 + Math.sin(nucleusPulse) * 1.5;
            // Glow
            const ng = actx.createRadialGradient(cx, cy, 0, cx, cy, nr * 3);
            ng.addColorStop(0, 'rgba(233,69,96,0.3)');
            ng.addColorStop(1, 'rgba(233,69,96,0)');
            actx.fillStyle = ng;
            actx.beginPath(); actx.arc(cx, cy, nr * 3, 0, Math.PI * 2); actx.fill();
            // Core
            const ncg = actx.createRadialGradient(cx - 3, cy - 3, 0, cx, cy, nr);
            ncg.addColorStop(0, '#ff8a8a');
            ncg.addColorStop(0.5, '#e94560');
            ncg.addColorStop(1, '#8b1a2b');
            actx.fillStyle = ncg;
            actx.beginPath(); actx.arc(cx, cy, nr, 0, Math.PI * 2); actx.fill();
            // Proton label
            actx.fillStyle = '#fff';
            actx.font = 'bold 10px sans-serif';
            actx.textAlign = 'center';
            actx.fillText('+', cx, cy + 4);

            // Electron
            let eRadius, eAlpha = 1;
            if (transitioning) {
                const r0 = levels[currentLevel].radius;
                const r1 = levels[targetLevel].radius;
                eRadius = r0 + (r1 - r0) * easeInOutCubic(transProgress);
                eAlpha = 0.6 + 0.4 * Math.cos(transProgress * Math.PI * 4);
            } else {
                eRadius = levels[currentLevel].radius;
            }
            const ex = cx + Math.cos(electronAngle) * eRadius;
            const ey = cy + Math.sin(electronAngle) * eRadius;

            // Electron glow
            const eg = actx.createRadialGradient(ex, ey, 0, ex, ey, 18);
            const eColor = levels[transitioning ? targetLevel : currentLevel].color;
            eg.addColorStop(0, eColor + 'AA');
            eg.addColorStop(1, eColor + '00');
            actx.globalAlpha = eAlpha;
            actx.fillStyle = eg;
            actx.beginPath(); actx.arc(ex, ey, 18, 0, Math.PI * 2); actx.fill();
            // Electron dot
            actx.beginPath(); actx.arc(ex, ey, 5, 0, Math.PI * 2);
            actx.fillStyle = '#fff'; actx.fill();
            actx.beginPath(); actx.arc(ex, ey, 4, 0, Math.PI * 2);
            actx.fillStyle = eColor; actx.fill();
            actx.globalAlpha = 1;

            // Electron label
            actx.fillStyle = '#fff';
            actx.font = 'bold 9px sans-serif';
            actx.textAlign = 'center';
            actx.fillText('e\u207B', ex, ey - 10);

            // Draw photons
            photons.forEach(p => {
                if (!p.alive) return;
                // Trail
                actx.save();
                for (let i = 0; i < p.trail.length; i++) {
                    const t = p.trail[i];
                    const a = (i / p.trail.length) * 0.4;
                    actx.beginPath();
                    actx.arc(t.x, t.y, 3, 0, Math.PI * 2);
                    actx.fillStyle = p.color.replace('rgb', 'rgba').replace(')', ',' + a + ')');
                    actx.fill();
                }
                actx.restore();

                // Photon wave packet
                actx.save();
                actx.shadowBlur = 12;
                actx.shadowColor = p.color;
                actx.beginPath();
                actx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                actx.fillStyle = p.color;
                actx.fill();
                // Wavy symbol ~
                actx.font = 'bold 14px serif';
                actx.fillStyle = p.color;
                actx.textAlign = 'center';
                actx.fillText('\u223C', p.x, p.y - 8);
                actx.shadowBlur = 0;
                actx.restore();
            });

            // Current state label
            actx.fillStyle = levels[currentLevel].color;
            actx.font = 'bold 14px "Courier New", monospace';
            actx.textAlign = 'left';
            actx.fillText('Electron: n=' + levels[currentLevel].n + '  E=' + levels[currentLevel].energy.toFixed(2) + ' eV', 14, 24);
            if (transitioning) {
                actx.fillStyle = transDir === 1 ? '#f0c040' : '#2ecc71';
                actx.fillText(transDir === 1 ? 'ABSORBING...' : 'EMITTING PHOTON...', 14, 42);
            } else if (currentLevel > 0) {
                actx.fillStyle = '#ff9f43';
                actx.font = '12px sans-serif';
                actx.fillText('Excited state — will decay', 14, 42);
            } else {
                actx.fillStyle = '#2ecc71';
                actx.font = '12px sans-serif';
                actx.fillText('Ground state — stable', 14, 42);
            }
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // ---- Animation loop ----
        function animate() {
            // Electron orbit
            electronSpeed = 0.003 + (nMax - currentLevel) * 0.004;
            electronAngle += electronSpeed;

            // Transition animation
            if (transitioning) {
                transProgress += 0.012;
                if (transProgress >= 1) {
                    transProgress = 1;
                    transitioning = false;
                    // If emission, spawn photon outward
                    if (transDir === -1) {
                        const fromLvl = currentLevel;
                        currentLevel = targetLevel;
                        spawnEmittedPhoton(fromLvl);
                    } else {
                        currentLevel = targetLevel;
                    }
                    highlightCurrentLevel();
                }
            }

            // Update photons
            photons.forEach(p => {
                if (!p.alive) return;
                const dx = p.tx - p.x, dy = p.ty - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < p.speed * 2) {
                    p.alive = false;
                    return;
                }
                p.trail.push({ x: p.x, y: p.y });
                if (p.trail.length > 12) p.trail.shift();
                p.x += (dx / dist) * p.speed;
                p.y += (dy / dist) * p.speed;
            });
            photons = photons.filter(p => p.alive || p.trail.length > 0);
            // Fade dead photon trails
            photons.forEach(p => {
                if (!p.alive) p.trail.shift();
            });
            photons = photons.filter(p => p.alive || p.trail.length > 0);

            // Auto mode
            if (autoRunning && !transitioning) {
                autoTimer++;
                if (autoTimer > 80) {
                    autoTimer = 0;
                    if (currentLevel === 0) {
                        // Absorb to random level
                        const target = 1 + Math.floor(Math.random() * (nMax - 1));
                        spawnIncomingPhoton(target);
                        startTransition(currentLevel, target);
                    } else {
                        // Emit to random lower level
                        const target = Math.floor(Math.random() * currentLevel);
                        startTransition(currentLevel, target);
                    }
                }
            }

            // Spontaneous decay (excited states are unstable)
            if (!autoRunning && !transitioning && currentLevel > 0) {
                // Small random chance of spontaneous emission
                if (Math.random() < 0.003) {
                    const target = Math.floor(Math.random() * currentLevel);
                    startTransition(currentLevel, target);
                }
            }

            drawAtom();
            drawDiagram();
            requestAnimationFrame(animate);
        }

        function highlightCurrentLevel() {
            const rows = levelRowsDiv.querySelectorAll('.level-row');
            rows.forEach((r, i) => {
                r.style.background = i === currentLevel ? 'rgba(255,255,255,0.06)' : '';
                r.style.fontWeight = i === currentLevel ? 'bold' : '';
            });
        }

        // ---- Initialise ----
        highlightCurrentLevel();
        updateSpectrum();
        animate();
    </script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Coded by <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
