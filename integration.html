<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integration — A Visual Introduction</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #e0e0e0;
            font-family: 'Segoe UI', Arial, sans-serif;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 { font-size: 24px; margin-bottom: 2px; color: #f0f0f0; }
        .subtitle { font-size: 14px; color: #aaa; margin-bottom: 6px; }
        .analogy {
            max-width: 920px;
            text-align: center;
            font-size: 14px;
            color: #f0c040;
            margin: 6px 0 14px 0;
        }
        .main-row {
            display: flex;
            gap: 18px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        .canvas-col {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        canvas {
            background: #16213e;
            border-radius: 10px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
        }
        .section-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 260px;
            max-width: 280px;
        }
        .card {
            background: #16213e;
            border-radius: 10px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
            padding: 14px 16px;
        }
        .card-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #7da2e0;
            margin-bottom: 8px;
        }
        .func-btns { display: flex; flex-wrap: wrap; gap: 6px; }
        button {
            background: #0f3460;
            color: #e0e0e0;
            border: 1px solid #1a5276;
            padding: 6px 12px;
            border-radius: 7px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background: #1a5276; }
        button.active { background: #e94560; border-color: #e94560; }
        .eq-box {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.8;
        }
        .eq-label { font-size: 11px; color: #888; margin-bottom: 2px; }
        .eq-f { color: #4ecdc4; }
        .eq-int { color: #a78bfa; }
        .eq-area { color: #ff9f43; }
        .readout {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.8;
        }
        .slider-section { margin-top: 4px; }
        .slider-section label {
            font-size: 12px;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .slider-section input[type="range"] {
            flex: 1;
            accent-color: #e94560;
        }
        .slider-section .val {
            min-width: 42px;
            text-align: right;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #ccc;
        }
        .insight {
            max-width: 920px;
            width: 100%;
            margin: 12px 0;
            padding: 12px 20px;
            background: rgba(15, 52, 96, 0.4);
            border-radius: 10px;
            border-left: 3px solid #7da2e0;
            font-size: 13px;
            color: #bbb;
            line-height: 1.6;
            text-align: center;
        }
        .insight b { color: #e0e0e0; }
        .legend {
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 6px 0;
            font-size: 12px;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-line { width: 20px; height: 3px; border-radius: 2px; }
        .legend-rect { width: 14px; height: 10px; border-radius: 2px; opacity: 0.6; }
        .n-btns { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 4px; }
        .n-btns button { padding: 4px 10px; font-size: 11px; }
        .accuracy-bar {
            margin-top: 8px;
            font-size: 12px;
            color: #aaa;
            line-height: 1.6;
        }
        .accuracy-bar b { color: #e0e0e0; }
        .link-box {
            margin-top: 6px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.06);
            font-size: 12px;
            color: #aaa;
            line-height: 1.6;
        }
        .link-box b { color: #e0e0e0; }
    </style>
</head>
<body>
    <h1>Integration — A Visual Introduction</h1>
    <p class="subtitle">Integration measures the total area under a curve</p>
    <p class="analogy">
        If the <b style="color:#4ecdc4">curve</b> represents your speed over time,
        then the <b style="color:#ff9f43">area under it</b> is the total distance you've travelled.
        Integration adds up infinitely many tiny slices to find that total.
    </p>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-line" style="background:#4ecdc4;"></div>
            <span><b style="color:#4ecdc4">f(x)</b> — the function</span>
        </div>
        <div class="legend-item">
            <div class="legend-rect" style="background:#ff9f43;"></div>
            <span><b style="color:#ff9f43">Rectangles</b> — approximate area</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background:#a78bfa;"></div>
            <span><b style="color:#a78bfa">F(x)</b> — the antiderivative (running total)</span>
        </div>
    </div>

    <div class="main-row">
        <div class="canvas-col">
            <div class="section-label">f(x) — The Function and the Area Under It</div>
            <canvas id="cTop" width="600" height="280"></canvas>
            <div class="section-label">F(x) — The Antiderivative (Accumulated Area)</div>
            <canvas id="cBot" width="600" height="200"></canvas>
        </div>
        <div class="side-panel">
            <!-- Function selector -->
            <div class="card">
                <div class="card-title">Choose a Function</div>
                <div class="func-btns" id="funcBtns"></div>
            </div>

            <!-- Equations -->
            <div class="card">
                <div class="card-title">The Equations</div>
                <div class="eq-box" id="eqBox"></div>
            </div>

            <!-- Bounds -->
            <div class="card">
                <div class="card-title">Integration Bounds</div>
                <div class="slider-section">
                    <label>
                        <span>a =</span>
                        <input type="range" id="sliderA" min="-300" max="250" value="-100">
                        <span class="val" id="valA">-1.00</span>
                    </label>
                </div>
                <div class="slider-section" style="margin-top:6px;">
                    <label>
                        <span>b =</span>
                        <input type="range" id="sliderB" min="-250" max="300" value="200">
                        <span class="val" id="valB">2.00</span>
                    </label>
                </div>
                <div class="readout" id="readout" style="margin-top:8px;"></div>
            </div>

            <!-- Rectangle count -->
            <div class="card">
                <div class="card-title">Number of Rectangles (n)</div>
                <div style="font-size:12px; color:#aaa; margin-bottom:6px; line-height:1.5;">
                    More rectangles = better approximation.
                    As n &rarr; &infin;, the sum becomes the <b style="color:#e0e0e0">exact integral</b>.
                </div>
                <div class="slider-section">
                    <label>
                        <span>n =</span>
                        <input type="range" id="sliderN" min="1" max="200" value="6">
                        <span class="val" id="valN">6</span>
                    </label>
                </div>
                <div class="n-btns">
                    <button onclick="setN(1)">1</button>
                    <button onclick="setN(3)">3</button>
                    <button onclick="setN(6)" class="active" id="nBtn6">6</button>
                    <button onclick="setN(20)">20</button>
                    <button onclick="setN(100)">100</button>
                </div>
                <div class="accuracy-bar" id="accuracy"></div>
            </div>

            <!-- Riemann sum type -->
            <div class="card">
                <div class="card-title">Rectangle Height Rule</div>
                <div style="font-size:12px; color:#aaa; margin-bottom:6px; line-height:1.5;">
                    Where on each slice do we measure the height?
                </div>
                <div class="func-btns" id="ruleBtns">
                    <button onclick="setRule('left', this)">Left</button>
                    <button onclick="setRule('mid', this)" class="active">Midpoint</button>
                    <button onclick="setRule('right', this)">Right</button>
                </div>
            </div>

            <!-- FTC link -->
            <div class="card">
                <div class="card-title">The Big Connection</div>
                <div class="link-box" id="ftcBox">
                    <b style="color:#f0c040;">Fundamental Theorem of Calculus:</b><br>
                    Differentiation and integration are <b>inverses</b>.<br><br>
                    If you <b style="color:#ff6b6b;">differentiate</b> the antiderivative
                    <b style="color:#a78bfa;">F(x)</b>, you get back the
                    original function <b style="color:#4ecdc4;">f(x)</b>.<br><br>
                    <span style="font-family:'Courier New',monospace; color:#ccc;">
                    d/dx [F(x)] = f(x)</span>
                </div>
            </div>
        </div>
    </div>

    <div class="insight" id="insight"></div>

    <script>
        // ---- Canvases ----
        const cTop = document.getElementById('cTop');
        const cBot = document.getElementById('cBot');
        const ctxT = cTop.getContext('2d');
        const ctxB = cBot.getContext('2d');
        const WT = cTop.width, HT = cTop.height;
        const WB = cBot.width, HB = cBot.height;

        // Coordinate systems — shared X, independent Y
        const oxT = WT / 2, oyT = HT * 0.65;
        const oxB = WB / 2, oyB = HB * 0.55;
        const sx = 80;  // pixels per unit (shared)
        const syT = 60; // pixels per unit, top
        const syB = 30; // pixels per unit, bottom

        function toPxX(x)  { return oxT + x * sx; }  // same for both canvases
        function toPxYT(y) { return oyT - y * syT; }
        function toPxYB(y) { return oyB - y * syB; }
        function toMathX(px) { return (px - oxT) / sx; }

        // ---- Functions ----
        const functions = [
            {
                name: 'x\u00B2',
                f:    x => x * x,
                F:    x => x * x * x / 3,
                Fexact: (a, b) => (b**3 - a**3) / 3,
                eqF:    'f(x) = x\u00B2',
                eqInt:  '\u222Bf(x)dx = x\u00B3/3 + C',
                eqDef:  '\u222B\u2090\u1D47 x\u00B2 dx = [x\u00B3/3]\u2090\u1D47 = b\u00B3/3 - a\u00B3/3',
                insight: '<b>Parabola (x\u00B2):</b> The area under x\u00B2 grows as x\u00B3/3 — a <b>cubic</b>. '
                    + 'Notice in the lower graph how <b style="color:#a78bfa">F(x)</b> curves upward increasingly steeply, '
                    + 'because the function f(x) itself keeps growing. When f(x) is large, area accumulates fast; when f(x) is small (near 0), area accumulates slowly. '
                    + 'Try moving the bounds — when a < 0, the area below the x-axis counts as <b>negative</b> (shown in blue).',
            },
            {
                name: 'x\u00B3',
                f:    x => x * x * x,
                F:    x => x**4 / 4,
                Fexact: (a, b) => (b**4 - a**4) / 4,
                eqF:    'f(x) = x\u00B3',
                eqInt:  '\u222Bf(x)dx = x\u2074/4 + C',
                eqDef:  '\u222B\u2090\u1D47 x\u00B3 dx = [x\u2074/4]\u2090\u1D47',
                insight: '<b>Cubic (x\u00B3):</b> Since x\u00B3 is negative for x < 0 and positive for x > 0, '
                    + 'integrating from -a to a gives <b>zero</b> — the positive and negative areas cancel perfectly. '
                    + 'This is because x\u00B3 is an <b>odd function</b> (symmetric about the origin). '
                    + 'Try setting a = -2, b = 2 and watch the areas cancel out.',
            },
            {
                name: 'sin(x)',
                f:    x => Math.sin(x),
                F:    x => -Math.cos(x),
                Fexact: (a, b) => -Math.cos(b) + Math.cos(a),
                eqF:    'f(x) = sin(x)',
                eqInt:  '\u222Bsin(x)dx = -cos(x) + C',
                eqDef:  '\u222B\u2090\u1D47 sin(x)dx = -cos(b)+cos(a)',
                insight: '<b>Sine wave:</b> The integral of sin is -cos — another wave! The accumulated area oscillates '
                    + 'because the positive humps (above x-axis) and negative humps (below) keep alternating. '
                    + 'Integrating over a full period (0 to 2\u03C0 \u2248 6.28) gives exactly <b>zero</b> — '
                    + 'perfect cancellation. Try it: set a=0, b=3.14 (one hump) to get area = 2.',
            },
            {
                name: 'e\u02E3',
                f:    x => Math.exp(x),
                F:    x => Math.exp(x),
                Fexact: (a, b) => Math.exp(b) - Math.exp(a),
                eqF:    'f(x) = e\u02E3',
                eqInt:  '\u222Be\u02E3dx = e\u02E3 + C',
                eqDef:  '\u222B\u2090\u1D47 e\u02E3 dx = e\u1D47 - e\u1D43',
                insight: '<b>Exponential (e\u02E3):</b> Just like its derivative, the integral of e\u02E3 is itself — '
                    + 'e\u02E3 is its own antiderivative! The area grows exponentially because the function itself grows exponentially. '
                    + 'Notice in the lower graph that <b style="color:#a78bfa">F(x)</b> has the same shape as f(x) — they are the same function, just shifted vertically by the constant of integration.',
            },
            {
                name: '1+cos(x)',
                f:    x => 1 + Math.cos(x),
                F:    x => x + Math.sin(x),
                Fexact: (a, b) => (b + Math.sin(b)) - (a + Math.sin(a)),
                eqF:    'f(x) = 1 + cos(x)',
                eqInt:  '\u222B[1+cos(x)]dx = x+sin(x)+C',
                eqDef:  '\u222B\u2090\u1D47 [1+cos(x)]dx = (b+sin b)-(a+sin a)',
                insight: '<b>Shifted cosine (1+cos):</b> This function is always &ge; 0 (it just touches zero at x=\u03C0). '
                    + 'Because it never goes negative, the accumulated area <b style="color:#a78bfa">F(x)</b> only ever increases — '
                    + 'it is a <b>monotonically rising</b> curve. The waviness in F(x) comes from the cos component: '
                    + 'area accumulates faster when cos is near +1 (f is large) and slower when cos is near -1 (f is near zero).',
            },
            {
                name: '\u221Ax',
                f:    x => x >= 0 ? Math.sqrt(x) : NaN,
                F:    x => x >= 0 ? (2/3) * x * Math.sqrt(x) : NaN,
                Fexact: (a, b) => {
                    const fa = a >= 0 ? (2/3) * a * Math.sqrt(a) : 0;
                    const fb = b >= 0 ? (2/3) * b * Math.sqrt(b) : 0;
                    return fb - fa;
                },
                eqF:    'f(x) = \u221Ax',
                eqInt:  '\u222B\u221Ax dx = (2/3)x\u00B3\u02AF\u00B2 + C',
                eqDef:  '\u222B\u2090\u1D47 \u221Ax dx = (2/3)(b\u00B3\u02AF\u00B2 - a\u00B3\u02AF\u00B2)',
                insight: '<b>Square root (\u221Ax):</b> Only defined for x \u2265 0. The function rises steeply at first then flattens — '
                    + 'so area accumulates quickly at the start then slows down. The antiderivative (2/3)x\u00B3\u02AF\u00B2 is a <b>gentler</b> '
                    + 'power curve. Notice how increasing b adds less and less area — diminishing returns, just like the function itself.',
            },
        ];

        let curFunc = 0;
        let boundA = -1.0, boundB = 2.0;
        let numRect = 6;
        let rule = 'mid';  // left, mid, right

        // ---- UI builders ----
        const funcBtnsDiv = document.getElementById('funcBtns');
        functions.forEach((fn, i) => {
            const btn = document.createElement('button');
            btn.textContent = fn.name;
            btn.id = `funcBtn${i}`;
            btn.onclick = () => selectFunc(i);
            if (i === 0) btn.className = 'active';
            funcBtnsDiv.appendChild(btn);
        });

        function selectFunc(i) {
            curFunc = i;
            document.querySelectorAll('#funcBtns button').forEach(b => b.classList.remove('active'));
            document.getElementById(`funcBtn${i}`).classList.add('active');
            updateEquations();
            updateInsight();
        }

        // Sliders
        const sliderA = document.getElementById('sliderA');
        const sliderB = document.getElementById('sliderB');
        const sliderN = document.getElementById('sliderN');
        sliderA.addEventListener('input', () => {
            boundA = parseInt(sliderA.value) / 100;
            document.getElementById('valA').textContent = boundA.toFixed(2);
        });
        sliderB.addEventListener('input', () => {
            boundB = parseInt(sliderB.value) / 100;
            document.getElementById('valB').textContent = boundB.toFixed(2);
        });
        sliderN.addEventListener('input', () => {
            numRect = parseInt(sliderN.value);
            document.getElementById('valN').textContent = numRect;
            document.querySelectorAll('.n-btns button').forEach(b => b.classList.remove('active'));
        });

        function setN(n) {
            numRect = n;
            sliderN.value = n;
            document.getElementById('valN').textContent = n;
            document.querySelectorAll('.n-btns button').forEach(b => b.classList.remove('active'));
            if (event && event.target) event.target.classList.add('active');
        }

        function setRule(r, btn) {
            rule = r;
            document.querySelectorAll('#ruleBtns button').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
        }

        function updateEquations() {
            const fn = functions[curFunc];
            document.getElementById('eqBox').innerHTML =
                `<div class="eq-label">Function:</div>`
                + `<div class="eq-f">${fn.eqF}</div>`
                + `<div class="eq-label" style="margin-top:6px;">Indefinite integral (antiderivative):</div>`
                + `<div class="eq-int">${fn.eqInt}</div>`
                + `<div class="eq-label" style="margin-top:6px;">Definite integral (area):</div>`
                + `<div class="eq-area">${fn.eqDef}</div>`;
        }

        function updateInsight() {
            document.getElementById('insight').innerHTML = functions[curFunc].insight;
        }

        // ---- Riemann sum calculation ----
        function riemannSum(f, a, b, n, ruleType) {
            if (a >= b) return { sum: 0, rects: [] };
            const dx = (b - a) / n;
            let sum = 0;
            const rects = [];
            for (let i = 0; i < n; i++) {
                const xL = a + i * dx;
                let xSample;
                if (ruleType === 'left') xSample = xL;
                else if (ruleType === 'right') xSample = xL + dx;
                else xSample = xL + dx / 2;
                const h = f(xSample);
                if (isNaN(h) || !isFinite(h)) continue;
                sum += h * dx;
                rects.push({ x: xL, w: dx, h: h });
            }
            return { sum, rects };
        }

        // ---- Drawing helpers ----
        function drawGrid(ctx, w, h, ox, oy, scY, label) {
            const xMin = toMathX(0), xMax = toMathX(w);
            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.06)';
            ctx.lineWidth = 1;
            for (let gx = Math.ceil(xMin); gx <= Math.floor(xMax); gx++) {
                ctx.beginPath();
                ctx.moveTo(toPxX(gx), 0);
                ctx.lineTo(toPxX(gx), h);
                ctx.stroke();
            }
            const yMin = (oy - h) / scY * -1;
            const yMax = oy / scY;
            for (let gy = Math.ceil(-oy / scY); gy <= Math.floor(oy / scY); gy++) {
                const py = oy - gy * scY;
                if (py < 0 || py > h) continue;
                ctx.beginPath();
                ctx.moveTo(0, py);
                ctx.lineTo(w, py);
                ctx.stroke();
            }
            // Axes
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(w, oy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(ox, 0); ctx.lineTo(ox, h); ctx.stroke();
            // Axis numbers
            ctx.fillStyle = '#555';
            ctx.font = '10px Segoe UI, Arial';
            ctx.textAlign = 'center';
            for (let gx = Math.ceil(xMin); gx <= Math.floor(xMax); gx++) {
                if (gx === 0) continue;
                ctx.fillText(gx, toPxX(gx), oy + 13);
            }
            ctx.textAlign = 'right';
            for (let gy = Math.ceil(-oy / scY); gy <= Math.floor((h - oy) / scY * -1 + 6); gy++) {
                if (gy === 0) continue;
                const py = oy - gy * scY;
                if (py < 5 || py > h - 5) continue;
                ctx.fillText(gy, ox - 5, py + 4);
            }
            // Label
            if (label) {
                ctx.fillStyle = '#888';
                ctx.font = '11px Segoe UI, Arial';
                ctx.textAlign = 'left';
                ctx.fillText(label, w - 40, 16);
            }
        }

        function drawCurveOn(ctx, fn, ox, oy, scY, colour, lw, w, h, dashed) {
            ctx.strokeStyle = colour;
            ctx.lineWidth = lw || 2.5;
            if (dashed) ctx.setLineDash(dashed);
            else ctx.setLineDash([]);
            ctx.beginPath();
            let started = false;
            for (let px = 0; px < w; px++) {
                const x = toMathX(px);
                const y = fn(x);
                if (isNaN(y) || !isFinite(y) || Math.abs(y) > 100) {
                    started = false; continue;
                }
                const py = oy - y * scY;
                if (!started) { ctx.moveTo(px, py); started = true; }
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawRectangles(ctx, rects, oy, scY) {
            for (const r of rects) {
                const px = toPxX(r.x);
                const pw = r.w * sx;
                const ph = r.h * scY;
                const py = oy;
                const isNeg = r.h < 0;

                // Fill
                ctx.fillStyle = isNeg ? 'rgba(100, 160, 255, 0.2)' : 'rgba(255, 159, 67, 0.2)';
                ctx.fillRect(px, isNeg ? py : py - ph, pw, Math.abs(ph));

                // Border
                ctx.strokeStyle = isNeg ? 'rgba(100, 160, 255, 0.5)' : 'rgba(255, 159, 67, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(px, isNeg ? py : py - ph, pw, Math.abs(ph));

                // Height sample dot (if wide enough)
                if (pw > 6) {
                    let dotX;
                    if (rule === 'left') dotX = px;
                    else if (rule === 'right') dotX = px + pw;
                    else dotX = px + pw / 2;
                    ctx.fillStyle = isNeg ? '#64a0ff' : '#ff9f43';
                    ctx.beginPath();
                    ctx.arc(dotX, py - ph, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawBoundMarkers(ctx, a, b, oy, h) {
            // Bound lines
            for (const bnd of [a, b]) {
                const px = toPxX(bnd);
                ctx.strokeStyle = 'rgba(233, 69, 96, 0.5)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(px, 0);
                ctx.lineTo(px, h);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            // Labels
            ctx.fillStyle = '#e94560';
            ctx.font = 'bold 12px Courier New, monospace';
            ctx.textAlign = 'center';
            ctx.fillText('a', toPxX(a), oy + 26);
            ctx.fillText('b', toPxX(b), oy + 26);
        }

        function drawShadedArea(ctx, f, a, b, oy, scY) {
            // Smooth shaded area under the curve (the exact integral)
            if (a >= b) return;
            const pxA = Math.max(0, toPxX(a));
            const pxB = Math.min(WT, toPxX(b));

            // Positive area
            ctx.beginPath();
            ctx.moveTo(pxA, oy);
            for (let px = pxA; px <= pxB; px++) {
                const x = toMathX(px);
                const y = f(x);
                if (isNaN(y) || !isFinite(y)) continue;
                const clampedY = Math.max(y, 0);
                ctx.lineTo(px, oy - clampedY * scY);
            }
            ctx.lineTo(pxB, oy);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 159, 67, 0.08)';
            ctx.fill();

            // Negative area
            ctx.beginPath();
            ctx.moveTo(pxA, oy);
            for (let px = pxA; px <= pxB; px++) {
                const x = toMathX(px);
                const y = f(x);
                if (isNaN(y) || !isFinite(y)) continue;
                const clampedY = Math.min(y, 0);
                ctx.lineTo(px, oy - clampedY * scY);
            }
            ctx.lineTo(pxB, oy);
            ctx.closePath();
            ctx.fillStyle = 'rgba(100, 160, 255, 0.08)';
            ctx.fill();
        }

        function drawAccumulationHighlight(ctx, F, a, b, oy, scY) {
            // Shade the antiderivative between bounds
            if (a >= b) return;
            const pxA = Math.max(0, toPxX(a));
            const pxB = Math.min(WB, toPxX(b));
            ctx.beginPath();
            ctx.moveTo(pxA, oy);
            for (let px = pxA; px <= pxB; px++) {
                const x = toMathX(px);
                const y = F(x) - F(a);  // offset so it starts at 0
                if (isNaN(y) || !isFinite(y)) continue;
                ctx.lineTo(px, oy - y * scY);
            }
            ctx.lineTo(pxB, oy);
            ctx.closePath();
            ctx.fillStyle = 'rgba(167, 139, 250, 0.1)';
            ctx.fill();
        }

        // ---- Formula display on canvas ----
        function drawFormulaBox(ctx, w) {
            ctx.fillStyle = 'rgba(22, 33, 62, 0.85)';
            ctx.fillRect(8, 8, 280, 46);
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            ctx.strokeRect(8, 8, 280, 46);

            ctx.fillStyle = '#aaa';
            ctx.font = '11px Courier New, monospace';
            ctx.textAlign = 'left';
            ctx.fillText("Definition of the definite integral:", 16, 24);
            ctx.fillStyle = '#a78bfa';
            ctx.font = '13px Courier New, monospace';
            ctx.fillText("\u222B\u2090\u1D47f(x)dx = lim \u03A3 f(x\u1D62)\u00B7\u0394x", 16, 44);
            ctx.fillStyle = '#888';
            ctx.font = '9px Courier New, monospace';
            ctx.fillText("n\u2192\u221E", 133, 44);
        }

        // ---- Main draw loop ----
        function draw() {
            ctxT.clearRect(0, 0, WT, HT);
            ctxB.clearRect(0, 0, WB, HB);
            const fn = functions[curFunc];

            const a = Math.min(boundA, boundB);
            const b = Math.max(boundA, boundB);

            // ---- Top canvas: f(x) with rectangles ----
            drawGrid(ctxT, WT, HT, oxT, oyT, syT, 'f(x)');

            // Shaded exact area (light)
            drawShadedArea(ctxT, fn.f, a, b, oyT, syT);

            // Rectangles
            const { sum, rects } = riemannSum(fn.f, a, b, numRect, rule);
            drawRectangles(ctxT, rects, oyT, syT);

            // The curve
            drawCurveOn(ctxT, fn.f, oxT, oyT, syT, '#4ecdc4', 3, WT, HT);

            // Bound markers
            drawBoundMarkers(ctxT, a, b, oyT, HT);

            // Formula box
            drawFormulaBox(ctxT, WT);

            // ---- Bottom canvas: F(x) antiderivative ----
            drawGrid(ctxB, WB, HB, oxB, oyB, syB, 'F(x)');

            // Offset F so F(a)=0 for cleaner visual
            const Fa = fn.F(a);
            const Foffset = x => fn.F(x) - Fa;

            drawAccumulationHighlight(ctxB, fn.F, a, b, oyB, syB);
            drawCurveOn(ctxB, Foffset, oxB, oyB, syB, '#a78bfa', 2.5, WB, HB);

            // Mark the value at b
            const Fb = Foffset(b);
            if (isFinite(Fb)) {
                const pxB = toPxX(b);
                const pyB = oyB - Fb * syB;
                // Dot
                ctxB.fillStyle = '#a78bfa';
                ctxB.beginPath();
                ctxB.arc(pxB, pyB, 5, 0, Math.PI * 2);
                ctxB.fill();
                ctxB.strokeStyle = '#fff';
                ctxB.lineWidth = 1.5;
                ctxB.stroke();
                // Value label
                ctxB.fillStyle = '#a78bfa';
                ctxB.font = 'bold 12px Courier New, monospace';
                ctxB.textAlign = 'left';
                ctxB.fillText('Area = ' + Fb.toFixed(3), pxB + 10, pyB - 6);
                // Dashed line to axis
                ctxB.strokeStyle = 'rgba(167, 139, 250, 0.3)';
                ctxB.setLineDash([3, 3]);
                ctxB.beginPath();
                ctxB.moveTo(pxB, pyB);
                ctxB.lineTo(pxB, oyB);
                ctxB.stroke();
                ctxB.setLineDash([]);
            }

            // Bound markers on bottom
            drawBoundMarkers(ctxB, a, b, oyB, HB);

            // FTC label
            ctxB.fillStyle = 'rgba(22, 33, 62, 0.85)';
            ctxB.fillRect(8, 8, 240, 28);
            ctxB.strokeStyle = 'rgba(255,255,255,0.1)';
            ctxB.lineWidth = 1;
            ctxB.strokeRect(8, 8, 240, 28);
            ctxB.fillStyle = '#a78bfa';
            ctxB.font = '12px Courier New, monospace';
            ctxB.textAlign = 'left';
            ctxB.fillText('F(x) = \u222B\u2090\u02E3 f(t)dt  (running total)', 16, 27);

            // ---- Readout ----
            const exact = fn.Fexact(a, b);
            const err = Math.abs(sum - exact);
            const pctErr = exact !== 0 ? (err / Math.abs(exact) * 100) : 0;

            document.getElementById('readout').innerHTML =
                `<div style="display:flex; justify-content:space-between;">`
                + `<span style="color:#ff9f43">Rectangles \u2248</span>`
                + `<span style="color:#ff9f43; font-weight:bold;">${sum.toFixed(4)}</span></div>`
                + `<div style="display:flex; justify-content:space-between;">`
                + `<span style="color:#a78bfa">Exact integral =</span>`
                + `<span style="color:#a78bfa; font-weight:bold;">${exact.toFixed(4)}</span></div>`;

            // Accuracy
            document.getElementById('accuracy').innerHTML =
                `Approx: <b style="color:#ff9f43">${sum.toFixed(4)}</b><br>`
                + `Exact:&nbsp; <b style="color:#a78bfa">${exact.toFixed(4)}</b><br>`
                + `Error:&nbsp; <b style="color:${pctErr < 1 ? '#5cd85c' : pctErr < 5 ? '#f0c040' : '#e94560'}">`
                + `${err.toFixed(4)} (${pctErr.toFixed(1)}%)</b>`
                + (pctErr < 0.5 ? ' &larr; excellent!' : pctErr < 2 ? ' &larr; good' : '');

            requestAnimationFrame(draw);
        }

        // ---- Mouse drag on top canvas to adjust bounds ----
        let dragging = null;  // 'a' or 'b'
        cTop.addEventListener('mousedown', (e) => {
            const rect = cTop.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const distA = Math.abs(mx - toPxX(boundA));
            const distB = Math.abs(mx - toPxX(boundB));
            if (distA < 15 && distA < distB) dragging = 'a';
            else if (distB < 15) dragging = 'b';
        });
        cTop.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const rect = cTop.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const val = Math.max(-3, Math.min(3, toMathX(mx)));
            if (dragging === 'a') {
                boundA = val;
                sliderA.value = Math.round(val * 100);
                document.getElementById('valA').textContent = val.toFixed(2);
            } else {
                boundB = val;
                sliderB.value = Math.round(val * 100);
                document.getElementById('valB').textContent = val.toFixed(2);
            }
        });
        cTop.addEventListener('mouseup', () => { dragging = null; });
        cTop.addEventListener('mouseleave', () => { dragging = null; });

        // ---- Init ----
        updateEquations();
        updateInsight();
        draw();
    </script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Built in collaboration with <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude Code</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
