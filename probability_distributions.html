<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probability Distributions — A Visual Introduction</title>
    <meta name="description" content="Explore probability distributions interactively: binomial, normal, Poisson, and more. Adjust parameters and see the shape change.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #e0e0e0;
            font-family: 'Segoe UI', Arial, sans-serif;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 { font-size: 24px; margin-bottom: 2px; color: #f0f0f0; }
        .subtitle { font-size: 14px; color: #aaa; margin-bottom: 6px; }
        .analogy {
            max-width: 920px;
            text-align: center;
            font-size: 14px;
            color: #f0c040;
            margin: 6px 0 14px 0;
        }
        .main-row {
            display: flex;
            gap: 18px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
        }
        .canvas-col {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }
        canvas {
            background: #16213e;
            border-radius: 10px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
        }
        .section-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 260px;
            max-width: 280px;
        }
        .card {
            background: #16213e;
            border-radius: 10px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
            padding: 14px 16px;
        }
        .card-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #7da2e0;
            margin-bottom: 8px;
        }
        .func-btns { display: flex; flex-wrap: wrap; gap: 6px; }
        .dist-group-label {
            width: 100%;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            margin-top: 6px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .dist-group-label:first-child { margin-top: 0; }
        .dist-group-label.finance { color: #e94560; }
        button {
            background: #0f3460;
            color: #e0e0e0;
            border: 1px solid #1a5276;
            padding: 6px 12px;
            border-radius: 7px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background: #1a5276; }
        button.active { background: #e94560; border-color: #e94560; }
        button.green { background: #1b7a4a; border-color: #22a05e; }
        button.green:hover { background: #22a05e; }
        .slider-section { margin-top: 6px; }
        .slider-section label {
            font-size: 12px;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .slider-section input[type="range"] {
            flex: 1;
            accent-color: #e94560;
        }
        .slider-section .val {
            min-width: 42px;
            text-align: right;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #ccc;
        }
        .slider-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 2px;
        }
        .readout {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.8;
        }
        .readout-row { display: flex; justify-content: space-between; }
        .insight {
            max-width: 920px;
            width: 100%;
            margin: 12px 0;
            padding: 12px 20px;
            background: rgba(15, 52, 96, 0.4);
            border-radius: 10px;
            border-left: 3px solid #7da2e0;
            font-size: 13px;
            color: #bbb;
            line-height: 1.6;
            text-align: center;
        }
        .insight b { color: #e0e0e0; }
        .legend {
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 6px 0;
            font-size: 12px;
        }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-line { width: 20px; height: 3px; border-radius: 2px; }
        .legend-rect { width: 14px; height: 10px; border-radius: 2px; }
        .eq-box {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.7;
            color: #ccc;
        }
        .sample-controls {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 4px;
        }
        .sample-count {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #5cd85c;
            margin-top: 6px;
        }
    </style>
</head>
<body>
    <h1>Probability Distributions — A Visual Introduction</h1>
    <p class="subtitle">A probability distribution shows how likely each outcome is</p>
    <p class="analogy">
        Think of the curve as a <b>landscape of likelihood</b>: tall regions are outcomes that happen often,
        flat regions are rare. The total area under the curve is always exactly 1 (100%) — something <i>must</i> happen.
    </p>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-line" style="background:#4ecdc4;"></div>
            <span><b style="color:#4ecdc4">PDF</b> — probability density</span>
        </div>
        <div class="legend-item">
            <div class="legend-rect" style="background:#ff9f43; opacity:0.5;"></div>
            <span><b style="color:#ff9f43">Shaded area</b> — P(a &le; X &le; b)</span>
        </div>
        <div class="legend-item">
            <div class="legend-rect" style="background:#a78bfa; opacity:0.5;"></div>
            <span><b style="color:#a78bfa">Histogram</b> — random samples</span>
        </div>
    </div>

    <div class="main-row">
        <div class="canvas-col">
            <div class="section-label">Probability Density Function (PDF) — The Shape of Chance</div>
            <canvas id="cPDF" width="620" height="320"></canvas>
            <div class="section-label">Random Samples — Watch the Histogram Converge to the Curve</div>
            <canvas id="cHist" width="620" height="200"></canvas>
        </div>
        <div class="side-panel">
            <!-- Distribution selector -->
            <div class="card">
                <div class="card-title">Choose a Distribution</div>
                <div class="func-btns" id="distBtns"></div>
            </div>

            <!-- Parameters -->
            <div class="card" id="paramCard">
                <div class="card-title">Parameters</div>
                <div id="paramSliders"></div>
            </div>

            <!-- Equation -->
            <div class="card">
                <div class="card-title">The Equation (PDF)</div>
                <div class="eq-box" id="eqBox"></div>
            </div>

            <!-- Probability query -->
            <div class="card">
                <div class="card-title">Find a Probability</div>
                <div style="font-size:12px; color:#aaa; margin-bottom:6px; line-height:1.4;">
                    What is P(a &le; X &le; b)? Drag the orange bounds on the graph or use these sliders.
                </div>
                <div class="slider-section">
                    <label>
                        <span>a =</span>
                        <input type="range" id="sliderQA" min="-400" max="400" value="-100">
                        <span class="val" id="valQA">-1.00</span>
                    </label>
                </div>
                <div class="slider-section">
                    <label>
                        <span>b =</span>
                        <input type="range" id="sliderQB" min="-400" max="400" value="100">
                        <span class="val" id="valQB">1.00</span>
                    </label>
                </div>
                <div class="readout" id="probReadout" style="margin-top:8px;"></div>
            </div>

            <!-- Stats -->
            <div class="card">
                <div class="card-title">Key Statistics</div>
                <div class="readout" id="statsReadout"></div>
            </div>

            <!-- Sampling -->
            <div class="card">
                <div class="card-title">Random Sampling</div>
                <div style="font-size:12px; color:#aaa; margin-bottom:6px; line-height:1.4;">
                    Draw random samples and watch the histogram converge to the theoretical PDF.
                </div>
                <div class="sample-controls">
                    <button class="green" onclick="addSamples(1)">+1</button>
                    <button class="green" onclick="addSamples(10)">+10</button>
                    <button class="green" onclick="addSamples(100)">+100</button>
                    <button class="green" onclick="addSamples(1000)">+1000</button>
                    <button onclick="toggleRain();" id="btnRain">Rain</button>
                    <button onclick="clearSamples()">Clear</button>
                </div>
                <div class="sample-count" id="sampleCount">Samples: 0</div>
            </div>
        </div>
    </div>

    <div class="insight" id="insight"></div>

    <script>
        // ---- Canvas setup ----
        const cPDF  = document.getElementById('cPDF');
        const cHist = document.getElementById('cHist');
        const ctxP  = cPDF.getContext('2d');
        const ctxH  = cHist.getContext('2d');
        const WP = cPDF.width, HP = cPDF.height;
        const WH = cHist.width, HH = cHist.height;

        // Coordinate system
        const padL = 50, padR = 20, padT = 20, padB = 40;
        const plotW = WP - padL - padR;
        const plotHP = HP - padT - padB;
        const plotHH = HH - padT - padB;

        // ---- Distributions ----
        // Normal PDF
        function normalPDF(x, mu, sig) {
            const z = (x - mu) / sig;
            return Math.exp(-0.5 * z * z) / (sig * Math.sqrt(2 * Math.PI));
        }
        // Normal CDF (approximation via error function)
        function erf(x) {
            const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
            const p=0.3275911;
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x);
            const t = 1 / (1 + p * x);
            const y = 1 - (((((a5*t+a4)*t)+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
            return sign * y;
        }
        function normalCDF(x, mu, sig) {
            return 0.5 * (1 + erf((x - mu) / (sig * Math.sqrt(2))));
        }
        // Box-Muller for normal sampling
        function sampleNormal(mu, sig) {
            let u1 = Math.random(), u2 = Math.random();
            while (u1 === 0) u1 = Math.random();
            return mu + sig * Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        }

        // Uniform PDF
        function uniformPDF(x, a, b) {
            return (x >= a && x <= b) ? 1 / (b - a) : 0;
        }
        function sampleUniform(a, b) {
            return a + Math.random() * (b - a);
        }

        // Exponential PDF
        function expPDF(x, lam) {
            return x >= 0 ? lam * Math.exp(-lam * x) : 0;
        }
        function sampleExp(lam) {
            return -Math.log(1 - Math.random()) / lam;
        }

        // Gamma (shape=k, rate=1) for chi-squared-like
        function gammaPDF(x, k, theta) {
            if (x <= 0) return 0;
            // Using Stirling for gamma function
            const lnGamma = gammaLn(k);
            return Math.exp((k - 1) * Math.log(x) - x / theta - k * Math.log(theta) - lnGamma);
        }
        function gammaLn(z) {
            // Lanczos approximation
            const g = 7;
            const c = [0.99999999999980993,676.5203681218851,-1259.1392167224028,
                771.32342877765313,-176.61502916214059,12.507343278686905,
                -0.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7];
            let x = c[0];
            for (let i = 1; i < g + 2; i++) x += c[i] / (z + i);
            const t = z + g + 0.5;
            return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x) - Math.log(z);
        }
        function sampleGamma(k, theta) {
            // Marsaglia and Tsang's method
            if (k < 1) {
                return sampleGamma(k + 1, theta) * Math.pow(Math.random(), 1 / k);
            }
            const d = k - 1/3;
            const c = 1 / Math.sqrt(9 * d);
            while (true) {
                let x, v;
                do {
                    x = sampleNormal(0, 1);
                    v = 1 + c * x;
                } while (v <= 0);
                v = v * v * v;
                const u = Math.random();
                if (u < 1 - 0.0331 * x * x * x * x) return d * v * theta;
                if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) return d * v * theta;
            }
        }

        // Bimodal (mixture of two normals)
        function bimodalPDF(x, mu1, mu2, sig) {
            return 0.5 * normalPDF(x, mu1, sig) + 0.5 * normalPDF(x, mu2, sig);
        }
        function sampleBimodal(mu1, mu2, sig) {
            return Math.random() < 0.5 ? sampleNormal(mu1, sig) : sampleNormal(mu2, sig);
        }

        // Student's t distribution
        function studentTPDF(x, nu) {
            return Math.exp(gammaLn((nu+1)/2) - gammaLn(nu/2)) /
                   (Math.sqrt(nu * Math.PI)) *
                   Math.pow(1 + x*x/nu, -(nu+1)/2);
        }
        function sampleStudentT(nu) {
            // ratio: Z / sqrt(V/nu) where Z~N(0,1), V~chi2(nu)=Gamma(nu/2,2)
            const z = sampleNormal(0, 1);
            const v = sampleGamma(nu / 2, 2);
            return z / Math.sqrt(v / nu);
        }

        // Cauchy distribution (Student's t with df=1)
        function cauchyPDF(x, x0, gamma) {
            return 1 / (Math.PI * gamma * (1 + ((x - x0) / gamma) ** 2));
        }
        function sampleCauchy(x0, gamma) {
            return x0 + gamma * Math.tan(Math.PI * (Math.random() - 0.5));
        }

        // Log-Normal distribution
        function logNormalPDF(x, mu, sig) {
            if (x <= 0) return 0;
            const lnx = Math.log(x);
            return Math.exp(-0.5 * ((lnx - mu) / sig) ** 2) / (x * sig * Math.sqrt(2 * Math.PI));
        }
        function sampleLogNormal(mu, sig) {
            return Math.exp(sampleNormal(mu, sig));
        }

        // Pareto distribution
        function paretoPDF(x, xm, alpha) {
            if (x < xm) return 0;
            return alpha * Math.pow(xm, alpha) / Math.pow(x, alpha + 1);
        }
        function samplePareto(xm, alpha) {
            return xm / Math.pow(Math.random(), 1 / alpha);
        }

        // Weibull distribution
        function weibullPDF(x, k, lam) {
            if (x < 0) return 0;
            if (x === 0) return k < 1 ? Infinity : (k === 1 ? 1/lam : 0);
            return (k / lam) * Math.pow(x / lam, k - 1) * Math.exp(-Math.pow(x / lam, k));
        }
        function sampleWeibull(k, lam) {
            return lam * Math.pow(-Math.log(1 - Math.random()), 1 / k);
        }

        // ---- Distribution definitions ----
        const distributions = [
            {
                name: 'Normal',
                group: 'Standard',
                params: [
                    { name: '\u03BC (mean)', key: 'mu', min: -3, max: 3, step: 0.1, def: 0 },
                    { name: '\u03C3 (std dev)', key: 'sig', min: 0.3, max: 3, step: 0.1, def: 1 },
                ],
                xRange: () => [-5, 5],
                pdf: (x, p) => normalPDF(x, p.mu, p.sig),
                cdf: (x, p) => normalCDF(x, p.mu, p.sig),
                sample: p => sampleNormal(p.mu, p.sig),
                mean: p => p.mu,
                median: p => p.mu,
                stddev: p => p.sig,
                eq: p => `f(x) = (1/(\u03C3\u221A2\u03C0)) e^(-(x-\u03BC)\u00B2/2\u03C3\u00B2)\n\u03BC = ${p.mu.toFixed(1)}, \u03C3 = ${p.sig.toFixed(1)}`,
                insight: '<b>Normal (Gaussian) Distribution:</b> The famous "bell curve" — nature\'s favourite shape. '
                    + 'Heights, test scores, measurement errors, and countless natural phenomena follow this pattern. '
                    + '<b>The 68-95-99.7 rule:</b> 68% of data falls within 1\u03C3 of the mean, 95% within 2\u03C3, 99.7% within 3\u03C3. '
                    + 'Try adjusting \u03BC (shifts the centre) and \u03C3 (widens or narrows the bell). '
                    + 'A larger \u03C3 means more spread — more uncertainty about the outcome.',
            },
            {
                name: 'Uniform',
                group: 'Standard',
                params: [
                    { name: 'a (min)', key: 'a', min: -3, max: 1, step: 0.1, def: -1 },
                    { name: 'b (max)', key: 'b', min: 0, max: 4, step: 0.1, def: 2 },
                ],
                xRange: () => [-4, 5],
                pdf: (x, p) => uniformPDF(x, p.a, p.b),
                cdf: (x, p) => x < p.a ? 0 : x > p.b ? 1 : (x - p.a) / (p.b - p.a),
                sample: p => sampleUniform(p.a, p.b),
                mean: p => (p.a + p.b) / 2,
                median: p => (p.a + p.b) / 2,
                stddev: p => (p.b - p.a) / Math.sqrt(12),
                eq: p => `f(x) = 1/(b-a) for a \u2264 x \u2264 b\n       0 otherwise\na = ${p.a.toFixed(1)}, b = ${p.b.toFixed(1)}`,
                insight: '<b>Uniform Distribution:</b> Every outcome in the range is <b>equally likely</b> — a perfectly flat line. '
                    + 'Think of rolling a fair die or picking a random number between a and b. '
                    + 'The height is always 1/(b-a) so the total area = 1. '
                    + 'A wider range means a lower, flatter curve (each outcome is less likely individually, but there are more possibilities). '
                    + 'Try narrowing the range — the curve gets taller to keep the total area at 1.',
            },
            {
                name: 'Exponential',
                group: 'Standard',
                params: [
                    { name: '\u03BB (rate)', key: 'lam', min: 0.3, max: 3, step: 0.1, def: 1 },
                ],
                xRange: () => [-0.5, 6],
                pdf: (x, p) => expPDF(x, p.lam),
                cdf: (x, p) => x < 0 ? 0 : 1 - Math.exp(-p.lam * x),
                sample: p => sampleExp(p.lam),
                mean: p => 1 / p.lam,
                median: p => Math.log(2) / p.lam,
                stddev: p => 1 / p.lam,
                eq: p => `f(x) = \u03BBe^(-\u03BBx)  for x \u2265 0\n\u03BB = ${p.lam.toFixed(1)}`,
                insight: '<b>Exponential Distribution:</b> Models <b>waiting times</b> between random events — '
                    + 'how long until the next bus arrives, the next earthquake, or the next customer. '
                    + 'It is always <b>right-skewed</b>: most waits are short, but occasionally you wait a very long time. '
                    + 'The <b>memoryless property</b> makes it unique: if you\'ve already waited 5 minutes, the expected remaining wait is the same as if you just started. '
                    + 'Higher \u03BB = shorter average wait (events happen faster).',
            },
            {
                name: 'Gamma',
                group: 'Standard',
                params: [
                    { name: 'k (shape)', key: 'k', min: 1, max: 8, step: 0.5, def: 3 },
                    { name: '\u03B8 (scale)', key: 'theta', min: 0.3, max: 2, step: 0.1, def: 1 },
                ],
                xRange: p => [-0.5, Math.max(8, p.k * p.theta * 3)],
                pdf: (x, p) => gammaPDF(x, p.k, p.theta),
                cdf: null,  // numerical
                sample: p => sampleGamma(p.k, p.theta),
                mean: p => p.k * p.theta,
                median: p => p.k * p.theta * Math.pow(1 - 1/(9*p.k), 3),  // approx
                stddev: p => Math.sqrt(p.k) * p.theta,
                eq: p => `f(x) = x^(k-1) e^(-x/\u03B8) / (\u03B8^k \u0393(k))\nk = ${p.k.toFixed(1)}, \u03B8 = ${p.theta.toFixed(1)}`,
                insight: '<b>Gamma Distribution:</b> Generalises the exponential — if the exponential is "time until 1 event", '
                    + 'the gamma is "time until k events". When k=1 it <b>is</b> the exponential. '
                    + 'As k increases, the distribution becomes more <b>symmetric and bell-shaped</b> (by the Central Limit Theorem). '
                    + 'This models things like total rainfall over a season, insurance claim sizes, or hospital length of stay. '
                    + 'Try increasing k from 1 to 8 and watch the skewed shape transform toward a bell curve.',
            },
            {
                name: 'Bimodal',
                group: 'Standard',
                params: [
                    { name: '\u03BC\u2081 (peak 1)', key: 'mu1', min: -3, max: 0, step: 0.1, def: -1.5 },
                    { name: '\u03BC\u2082 (peak 2)', key: 'mu2', min: 0, max: 3, step: 0.1, def: 1.5 },
                    { name: '\u03C3 (spread)', key: 'sig', min: 0.3, max: 2, step: 0.1, def: 0.6 },
                ],
                xRange: () => [-5, 5],
                pdf: (x, p) => bimodalPDF(x, p.mu1, p.mu2, p.sig),
                cdf: (x, p) => 0.5 * normalCDF(x, p.mu1, p.sig) + 0.5 * normalCDF(x, p.mu2, p.sig),
                sample: p => sampleBimodal(p.mu1, p.mu2, p.sig),
                mean: p => (p.mu1 + p.mu2) / 2,
                median: p => (p.mu1 + p.mu2) / 2,
                stddev: p => Math.sqrt(0.5 * (p.sig**2 + p.mu1**2) + 0.5 * (p.sig**2 + p.mu2**2) - ((p.mu1+p.mu2)/2)**2),
                eq: p => `f(x) = 0.5\u00B7N(\u03BC\u2081,\u03C3) + 0.5\u00B7N(\u03BC\u2082,\u03C3)\n\u03BC\u2081=${p.mu1.toFixed(1)}, \u03BC\u2082=${p.mu2.toFixed(1)}, \u03C3=${p.sig.toFixed(1)}`,
                insight: '<b>Bimodal Distribution:</b> Two peaks — a mix of <b>two separate groups</b>. '
                    + 'Imagine measuring heights of both adults and children together, or exam scores where students either "got it" or didn\'t. '
                    + 'The <b>mean is in the valley</b> between the peaks — a place where almost no data actually falls! '
                    + 'This shows why the mean can be misleading: it doesn\'t always represent a "typical" value. '
                    + 'Try moving the peaks closer together (\u03BC\u2081 \u2192 \u03BC\u2082) and watch the two humps merge into one.',
            },
            // ============ FAT TAILS (FINANCE) ============
            {
                name: "Student's t",
                group: 'Fat Tails (Finance)',
                params: [
                    { name: '\u03BD (degrees of freedom)', key: 'nu', min: 1, max: 30, step: 1, def: 3 },
                ],
                xRange: () => [-6, 6],
                pdf: (x, p) => studentTPDF(x, p.nu),
                cdf: null,
                sample: p => sampleStudentT(p.nu),
                mean: p => p.nu > 1 ? 0 : NaN,
                median: p => 0,
                stddev: p => p.nu > 2 ? Math.sqrt(p.nu / (p.nu - 2)) : Infinity,
                eq: p => `f(x) = \u0393((\u03BD+1)/2) / (\u221A(\u03BD\u03C0) \u0393(\u03BD/2))\n       \u00D7 (1+x\u00B2/\u03BD)^(-(\u03BD+1)/2)\n\u03BD = ${p.nu.toFixed(0)}`,
                insight: '<b>Student\'s t Distribution:</b> The workhorse of financial risk. Looks like a normal but with <b>heavier tails</b> — '
                    + 'extreme events are much more likely than the normal predicts. '
                    + 'At \u03BD=1 it is the Cauchy (infinitely heavy tails). At \u03BD=3 it has finite mean but <b>infinite kurtosis</b>. '
                    + 'As \u03BD \u2192 \u221E it converges to the normal. '
                    + 'In finance, stock returns typically fit a t with \u03BD \u2248 3-5, meaning crashes are far more frequent than a normal predicts. '
                    + 'This is why VaR models that assume normality dramatically underestimate risk. '
                    + '<b>Try:</b> Set \u03BD=3 and compare the tail thickness to a normal — then increase to 30 and watch it become bell-shaped.',
            },
            {
                name: 'Cauchy',
                group: 'Fat Tails (Finance)',
                params: [
                    { name: 'x\u2080 (location)', key: 'x0', min: -3, max: 3, step: 0.1, def: 0 },
                    { name: '\u03B3 (scale)', key: 'gamma', min: 0.3, max: 3, step: 0.1, def: 1 },
                ],
                xRange: () => [-8, 8],
                pdf: (x, p) => cauchyPDF(x, p.x0, p.gamma),
                cdf: (x, p) => 0.5 + Math.atan((x - p.x0) / p.gamma) / Math.PI,
                sample: p => {
                    let s = sampleCauchy(p.x0, p.gamma);
                    return Math.max(-50, Math.min(50, s)); // prevent extreme outliers breaking display
                },
                mean: p => NaN,   // undefined!
                median: p => p.x0,
                stddev: p => Infinity,
                eq: p => `f(x) = 1 / (\u03C0\u03B3 [1 + ((x-x\u2080)/\u03B3)\u00B2])\nx\u2080 = ${p.x0.toFixed(1)}, \u03B3 = ${p.gamma.toFixed(1)}`,
                insight: '<b>Cauchy Distribution:</b> The most extreme fat-tailed distribution — it has <b>no mean and no variance</b>! '
                    + 'The average of Cauchy samples does NOT converge: even with millions of samples, the sample mean jumps around wildly. '
                    + 'This violates the Law of Large Numbers that works for all "well-behaved" distributions. '
                    + 'In finance, the Cauchy illustrates the danger of <b>undefined moments</b>: if returns were truly Cauchy, '
                    + 'concepts like "average return" and "volatility" would be meaningless. '
                    + '<b>Try:</b> Click Rain and watch — unlike the normal, the sample mean in the stats panel never stabilises. '
                    + 'The Cauchy is Student\'s t with \u03BD=1.',
            },
            {
                name: 'Log-Normal',
                group: 'Fat Tails (Finance)',
                params: [
                    { name: '\u03BC (log-mean)', key: 'mu', min: -1, max: 2, step: 0.1, def: 0 },
                    { name: '\u03C3 (log-std)', key: 'sig', min: 0.2, max: 1.5, step: 0.1, def: 0.5 },
                ],
                xRange: p => [-0.2, Math.max(5, Math.exp(p.mu + 2.5 * p.sig))],
                pdf: (x, p) => logNormalPDF(x, p.mu, p.sig),
                cdf: (x, p) => x <= 0 ? 0 : normalCDF(Math.log(x), p.mu, p.sig),
                sample: p => sampleLogNormal(p.mu, p.sig),
                mean: p => Math.exp(p.mu + p.sig**2 / 2),
                median: p => Math.exp(p.mu),
                stddev: p => Math.sqrt((Math.exp(p.sig**2) - 1) * Math.exp(2*p.mu + p.sig**2)),
                eq: p => `f(x) = (1/(x\u03C3\u221A2\u03C0)) e^(-(ln x-\u03BC)\u00B2/2\u03C3\u00B2)\n\u03BC = ${p.mu.toFixed(1)}, \u03C3 = ${p.sig.toFixed(1)}`,
                insight: '<b>Log-Normal Distribution:</b> If ln(X) is normal, then X is log-normal. This is the <b>Black-Scholes model</b> for stock prices — '
                    + 'the assumption that log-returns are normally distributed makes prices log-normal. '
                    + 'Always positive and right-skewed: most values cluster near the left, but occasional very large values occur. '
                    + 'The <b>mean > median</b> always — the long right tail pulls the mean up. '
                    + 'Models: stock prices, house prices, income distributions, insurance claims, market capitalisation. '
                    + '<b>Try:</b> Increase \u03C3 and watch the right tail extend — this represents increasing uncertainty about future prices.',
            },
            {
                name: 'Pareto',
                group: 'Fat Tails (Finance)',
                params: [
                    { name: 'x\u2098 (minimum)', key: 'xm', min: 0.5, max: 2, step: 0.1, def: 1 },
                    { name: '\u03B1 (tail index)', key: 'alpha', min: 1, max: 5, step: 0.1, def: 2 },
                ],
                xRange: p => [0, Math.max(8, p.xm * 10)],
                pdf: (x, p) => paretoPDF(x, p.xm, p.alpha),
                cdf: (x, p) => x < p.xm ? 0 : 1 - Math.pow(p.xm / x, p.alpha),
                sample: p => {
                    let s = samplePareto(p.xm, p.alpha);
                    return Math.min(s, 100);  // cap for display
                },
                mean: p => p.alpha > 1 ? p.alpha * p.xm / (p.alpha - 1) : Infinity,
                median: p => p.xm * Math.pow(2, 1 / p.alpha),
                stddev: p => p.alpha > 2 ?
                    p.xm * Math.sqrt(p.alpha / ((p.alpha-1)**2 * (p.alpha-2))) : Infinity,
                eq: p => `f(x) = \u03B1 x\u2098^\u03B1 / x^(\u03B1+1)  for x \u2265 x\u2098\nx\u2098 = ${p.xm.toFixed(1)}, \u03B1 = ${p.alpha.toFixed(1)}`,
                insight: '<b>Pareto Distribution:</b> The mathematical embodiment of the <b>"80-20 rule"</b> — '
                    + 'a power-law distribution where a small number of observations are enormously larger than the rest. '
                    + 'With \u03B1 \u2264 1 the mean is infinite. With \u03B1 \u2264 2 the variance is infinite. '
                    + 'Models: wealth distribution (few billionaires, many poor), insurance losses (many small claims, few catastrophic), '
                    + 'city sizes, file sizes, market crashes. '
                    + 'The <b>tail index \u03B1</b> controls how "unfair" the distribution is: lower \u03B1 = heavier tail = more extreme events. '
                    + '<b>Try:</b> Set \u03B1=1.5 and sample — notice how the occasional extreme outlier dominates the sample mean.',
            },
            {
                name: 'Weibull',
                group: 'Fat Tails (Finance)',
                params: [
                    { name: 'k (shape)', key: 'k', min: 0.5, max: 5, step: 0.1, def: 1.5 },
                    { name: '\u03BB (scale)', key: 'lam', min: 0.5, max: 3, step: 0.1, def: 1 },
                ],
                xRange: () => [-0.2, 6],
                pdf: (x, p) => weibullPDF(x, p.k, p.lam),
                cdf: (x, p) => x < 0 ? 0 : 1 - Math.exp(-Math.pow(x / p.lam, p.k)),
                sample: p => sampleWeibull(p.k, p.lam),
                mean: p => p.lam * Math.exp(gammaLn(1 + 1/p.k)),
                median: p => p.lam * Math.pow(Math.log(2), 1/p.k),
                stddev: p => {
                    const m1 = Math.exp(gammaLn(1 + 1/p.k));
                    const m2 = Math.exp(gammaLn(1 + 2/p.k));
                    return p.lam * Math.sqrt(m2 - m1*m1);
                },
                eq: p => `f(x) = (k/\u03BB)(x/\u03BB)^(k-1) e^(-(x/\u03BB)^k)\nk = ${p.k.toFixed(1)}, \u03BB = ${p.lam.toFixed(1)}`,
                insight: '<b>Weibull Distribution:</b> The Swiss Army knife of reliability and risk modelling. '
                    + 'The shape parameter k controls the <b>failure rate</b>: '
                    + 'k < 1: decreasing failure rate ("infant mortality" — if you survive the start, you\'re fine), '
                    + 'k = 1: constant failure rate (memoryless, equals exponential), '
                    + 'k > 1: increasing failure rate ("wear-out" — the longer you wait, the more likely failure). '
                    + 'In finance: models <b>operational risk</b> losses, time-to-default, and extreme loss severity. '
                    + '<b>Try:</b> Set k=0.5 (heavy left concentration), k=1 (exponential), then k=3.5 (almost bell-shaped).',
            },
        ];

        // ---- State ----
        let curDist = 0;
        let params = {};
        let queryA = -1, queryB = 1;
        let samples = [];
        let fallingDots = [];  // { x, y, vy } for animation
        let raining = false;
        let rainInterval = null;

        const NUM_HIST_BINS = 60;
        let histBins = new Array(NUM_HIST_BINS).fill(0);

        // ---- UI builders ----
        const distBtnsDiv = document.getElementById('distBtns');
        let lastGroup = '';
        distributions.forEach((d, i) => {
            if (d.group && d.group !== lastGroup) {
                lastGroup = d.group;
                const label = document.createElement('div');
                label.className = 'dist-group-label' + (d.group.includes('Finance') ? ' finance' : '');
                label.textContent = d.group;
                distBtnsDiv.appendChild(label);
            }
            const btn = document.createElement('button');
            btn.textContent = d.name;
            btn.id = `distBtn${i}`;
            btn.onclick = () => selectDist(i);
            if (i === 0) btn.className = 'active';
            distBtnsDiv.appendChild(btn);
        });

        function selectDist(i) {
            curDist = i;
            document.querySelectorAll('#distBtns button').forEach(b => b.classList.remove('active'));
            document.getElementById(`distBtn${i}`).classList.add('active');
            buildParamSliders();
            clearSamples();
            updateEquation();
            updateInsight();
        }

        function buildParamSliders() {
            const div = document.getElementById('paramSliders');
            div.innerHTML = '';
            params = {};
            const d = distributions[curDist];
            d.params.forEach(p => {
                params[p.key] = p.def;
                const section = document.createElement('div');
                section.className = 'slider-section';
                const label = document.createElement('label');
                const nameSpan = document.createElement('span');
                nameSpan.textContent = p.name;
                nameSpan.style.minWidth = '90px';
                nameSpan.style.fontSize = '12px';
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = Math.round(p.min / p.step);
                slider.max = Math.round(p.max / p.step);
                slider.value = Math.round(p.def / p.step);
                const valSpan = document.createElement('span');
                valSpan.className = 'val';
                valSpan.textContent = p.def.toFixed(1);
                slider.addEventListener('input', () => {
                    const v = parseInt(slider.value) * p.step;
                    params[p.key] = v;
                    valSpan.textContent = v.toFixed(1);
                    clearSamples();
                    updateEquation();
                });
                label.appendChild(nameSpan);
                label.appendChild(slider);
                label.appendChild(valSpan);
                section.appendChild(label);
                div.appendChild(section);
            });
        }

        // Query sliders
        document.getElementById('sliderQA').addEventListener('input', function() {
            queryA = parseInt(this.value) / 100;
            document.getElementById('valQA').textContent = queryA.toFixed(2);
        });
        document.getElementById('sliderQB').addEventListener('input', function() {
            queryB = parseInt(this.value) / 100;
            document.getElementById('valQB').textContent = queryB.toFixed(2);
        });

        function updateEquation() {
            const d = distributions[curDist];
            document.getElementById('eqBox').innerHTML =
                '<pre style="margin:0; white-space:pre-wrap; color:#4ecdc4;">'
                + d.eq(params) + '</pre>';
        }

        function updateInsight() {
            document.getElementById('insight').innerHTML = distributions[curDist].insight;
        }

        // ---- Sampling ----
        function addSamples(n) {
            const d = distributions[curDist];
            const xr = typeof d.xRange === 'function' ? d.xRange(params) : d.xRange;
            for (let i = 0; i < n; i++) {
                const x = d.sample(params);
                samples.push(x);
                // Add to histogram
                const bin = Math.floor((x - xr[0]) / (xr[1] - xr[0]) * NUM_HIST_BINS);
                if (bin >= 0 && bin < NUM_HIST_BINS) histBins[bin]++;
                // Add falling dot (only for small n for visual effect)
                if (n <= 100) {
                    const px = valToPixX(x, xr);
                    const pdfY = d.pdf(x, params);
                    fallingDots.push({
                        x: px,
                        y: padT,
                        vy: 2 + Math.random() * 2,
                        targetY: HH - padB,
                    });
                }
            }
            document.getElementById('sampleCount').textContent = `Samples: ${samples.length.toLocaleString()}`;
        }

        function clearSamples() {
            samples = [];
            histBins = new Array(NUM_HIST_BINS).fill(0);
            fallingDots = [];
            document.getElementById('sampleCount').textContent = 'Samples: 0';
        }

        function toggleRain() {
            raining = !raining;
            const btn = document.getElementById('btnRain');
            if (raining) {
                btn.classList.add('active');
                btn.textContent = 'Stop';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Rain';
            }
        }

        // ---- Coordinate helpers ----
        function valToPixX(x, xRange) {
            return padL + (x - xRange[0]) / (xRange[1] - xRange[0]) * plotW;
        }
        function pixToValX(px, xRange) {
            return xRange[0] + (px - padL) / plotW * (xRange[1] - xRange[0]);
        }

        // ---- Numerical integration (trapezoidal) ----
        function numericalIntegral(pdf, a, b, p, steps) {
            steps = steps || 200;
            if (a >= b) return 0;
            const dx = (b - a) / steps;
            let sum = 0.5 * (pdf(a, p) + pdf(b, p));
            for (let i = 1; i < steps; i++) {
                sum += pdf(a + i * dx, p);
            }
            return sum * dx;
        }

        // ---- Drawing ----

        function drawAxes(ctx, w, h, xRange, maxY, ylabel) {
            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.06)';
            ctx.lineWidth = 1;
            const xStep = (xRange[1] - xRange[0]) > 8 ? 2 : 1;
            for (let gx = Math.ceil(xRange[0]); gx <= Math.floor(xRange[1]); gx += xStep) {
                const px = valToPixX(gx, xRange);
                ctx.beginPath(); ctx.moveTo(px, padT); ctx.lineTo(px, h - padB); ctx.stroke();
            }

            // X axis
            const axisY = h - padB;
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(padL, axisY); ctx.lineTo(w - padR, axisY); ctx.stroke();

            // X labels
            ctx.fillStyle = '#555';
            ctx.font = '10px Segoe UI, Arial';
            ctx.textAlign = 'center';
            for (let gx = Math.ceil(xRange[0]); gx <= Math.floor(xRange[1]); gx += xStep) {
                ctx.fillText(gx, valToPixX(gx, xRange), axisY + 14);
            }

            // Y axis label
            if (ylabel) {
                ctx.fillStyle = '#888';
                ctx.font = '11px Segoe UI, Arial';
                ctx.textAlign = 'left';
                ctx.fillText(ylabel, padL + 4, padT + 14);
            }
        }

        function drawPDFCurve(xRange) {
            const d = distributions[curDist];
            ctxP.strokeStyle = '#4ecdc4';
            ctxP.lineWidth = 3;
            ctxP.beginPath();
            let started = false;
            let maxY = 0;
            for (let px = padL; px <= WP - padR; px++) {
                const x = pixToValX(px, xRange);
                const y = d.pdf(x, params);
                if (isNaN(y) || !isFinite(y)) { started = false; continue; }
                maxY = Math.max(maxY, y);
            }
            const scY = plotHP / (maxY * 1.15);
            const axisY = HP - padB;
            for (let px = padL; px <= WP - padR; px++) {
                const x = pixToValX(px, xRange);
                const y = d.pdf(x, params);
                if (isNaN(y) || !isFinite(y)) { started = false; continue; }
                const py = axisY - y * scY;
                if (!started) { ctxP.moveTo(px, py); started = true; }
                else ctxP.lineTo(px, py);
            }
            ctxP.stroke();
            return { maxY, scY };
        }

        function drawShadedRegion(xRange, scY) {
            const d = distributions[curDist];
            const a = Math.min(queryA, queryB);
            const b = Math.max(queryA, queryB);
            const axisY = HP - padB;

            ctxP.fillStyle = 'rgba(255, 159, 67, 0.25)';
            ctxP.beginPath();
            const pxA = Math.max(padL, valToPixX(a, xRange));
            const pxB = Math.min(WP - padR, valToPixX(b, xRange));
            ctxP.moveTo(pxA, axisY);
            for (let px = pxA; px <= pxB; px++) {
                const x = pixToValX(px, xRange);
                const y = d.pdf(x, params);
                if (isNaN(y) || !isFinite(y)) continue;
                ctxP.lineTo(px, axisY - y * scY);
            }
            ctxP.lineTo(pxB, axisY);
            ctxP.closePath();
            ctxP.fill();

            // Bound lines
            for (const bnd of [a, b]) {
                const px = valToPixX(bnd, xRange);
                if (px < padL || px > WP - padR) continue;
                ctxP.strokeStyle = 'rgba(255, 159, 67, 0.6)';
                ctxP.lineWidth = 1.5;
                ctxP.setLineDash([4, 4]);
                ctxP.beginPath();
                ctxP.moveTo(px, padT);
                ctxP.lineTo(px, HP - padB);
                ctxP.stroke();
                ctxP.setLineDash([]);
            }

            // Labels
            ctxP.fillStyle = '#ff9f43';
            ctxP.font = 'bold 11px Courier New, monospace';
            ctxP.textAlign = 'center';
            ctxP.fillText('a', valToPixX(a, xRange), axisY + 28);
            ctxP.fillText('b', valToPixX(b, xRange), axisY + 28);
        }

        function drawMeanStd(xRange, scY) {
            const d = distributions[curDist];
            const mu = d.mean(params);
            const sig = d.stddev(params);
            const axisY = HP - padB;

            // Mean line
            const pxMu = valToPixX(mu, xRange);
            if (pxMu > padL && pxMu < WP - padR) {
                ctxP.strokeStyle = '#e94560';
                ctxP.lineWidth = 2;
                ctxP.setLineDash([6, 3]);
                ctxP.beginPath();
                ctxP.moveTo(pxMu, padT + 10);
                ctxP.lineTo(pxMu, axisY);
                ctxP.stroke();
                ctxP.setLineDash([]);
                ctxP.fillStyle = '#e94560';
                ctxP.font = 'bold 11px Segoe UI, Arial';
                ctxP.textAlign = 'center';
                ctxP.fillText('\u03BC', pxMu, padT + 8);
            }

            // Standard deviation brackets
            const px1 = valToPixX(mu - sig, xRange);
            const px2 = valToPixX(mu + sig, xRange);
            const bracketY = axisY - 6;
            ctxP.strokeStyle = 'rgba(255, 107, 107, 0.3)';
            ctxP.lineWidth = 2;
            ctxP.beginPath();
            ctxP.moveTo(px1, bracketY);
            ctxP.lineTo(px2, bracketY);
            ctxP.stroke();
            // Ticks
            ctxP.beginPath();
            ctxP.moveTo(px1, bracketY - 4);
            ctxP.lineTo(px1, bracketY + 4);
            ctxP.moveTo(px2, bracketY - 4);
            ctxP.lineTo(px2, bracketY + 4);
            ctxP.stroke();
            // Label
            ctxP.fillStyle = 'rgba(255, 107, 107, 0.5)';
            ctxP.font = '9px Segoe UI, Arial';
            ctxP.textAlign = 'center';
            ctxP.fillText('\u03BC \u00B1 \u03C3', (px1 + px2) / 2, bracketY - 6);
        }

        function drawHistogram(xRange) {
            if (samples.length === 0) {
                ctxH.fillStyle = '#444';
                ctxH.font = '14px Segoe UI, Arial';
                ctxH.textAlign = 'center';
                ctxH.fillText('Click the green buttons to draw random samples', WH / 2, HH / 2);
                return;
            }

            const d = distributions[curDist];
            const axisY = HH - padB;
            const binW = plotW / NUM_HIST_BINS;

            // Find max bin for scaling
            const maxBin = Math.max(...histBins, 1);
            const scH = plotHH * 0.85 / maxBin;

            // Draw bars
            for (let i = 0; i < NUM_HIST_BINS; i++) {
                if (histBins[i] === 0) continue;
                const px = padL + i * binW;
                const h = histBins[i] * scH;
                ctxH.fillStyle = 'rgba(167, 139, 250, 0.35)';
                ctxH.fillRect(px, axisY - h, binW - 1, h);
                ctxH.strokeStyle = 'rgba(167, 139, 250, 0.5)';
                ctxH.lineWidth = 0.5;
                ctxH.strokeRect(px, axisY - h, binW - 1, h);
            }

            // Overlay theoretical PDF scaled to match histogram
            const totalArea = samples.length * (xRange[1] - xRange[0]) / NUM_HIST_BINS;
            ctxH.strokeStyle = '#4ecdc4';
            ctxH.lineWidth = 2;
            ctxH.beginPath();
            let started = false;
            for (let px = padL; px <= WH - padR; px++) {
                const x = pixToValX(px, xRange);
                const y = d.pdf(x, params);
                if (isNaN(y) || !isFinite(y)) { started = false; continue; }
                const py = axisY - y * totalArea * scH;
                if (!started) { ctxH.moveTo(px, py); started = true; }
                else ctxH.lineTo(px, py);
            }
            ctxH.stroke();

            // Sample count label
            ctxH.fillStyle = '#a78bfa';
            ctxH.font = 'bold 11px Segoe UI, Arial';
            ctxH.textAlign = 'right';
            ctxH.fillText(`n = ${samples.length.toLocaleString()}`, WH - padR - 4, padT + 14);
        }

        function drawFallingDots() {
            const axisY = HH - padB;
            for (let i = fallingDots.length - 1; i >= 0; i--) {
                const dot = fallingDots[i];
                dot.y += dot.vy;
                dot.vy += 0.3;  // gravity
                if (dot.y >= dot.targetY) {
                    fallingDots.splice(i, 1);
                    continue;
                }
                ctxH.fillStyle = 'rgba(167, 139, 250, 0.7)';
                ctxH.beginPath();
                ctxH.arc(dot.x, dot.y, 2.5, 0, Math.PI * 2);
                ctxH.fill();
            }
        }

        function drawProbBox(xRange, scY) {
            const d = distributions[curDist];
            const a = Math.min(queryA, queryB);
            const b = Math.max(queryA, queryB);
            let prob;
            if (d.cdf) {
                prob = d.cdf(b, params) - d.cdf(a, params);
            } else {
                prob = numericalIntegral(d.pdf, a, b, params);
            }
            prob = Math.max(0, Math.min(1, prob));

            // Display on canvas
            const midPx = (valToPixX(a, xRange) + valToPixX(b, xRange)) / 2;
            const midPy = HP - padB - plotHP * 0.3;
            ctxP.fillStyle = 'rgba(22, 33, 62, 0.85)';
            const boxW = 140, boxH = 24;
            ctxP.fillRect(midPx - boxW/2, midPy - boxH/2, boxW, boxH);
            ctxP.strokeStyle = 'rgba(255, 159, 67, 0.4)';
            ctxP.lineWidth = 1;
            ctxP.strokeRect(midPx - boxW/2, midPy - boxH/2, boxW, boxH);
            ctxP.fillStyle = '#ff9f43';
            ctxP.font = 'bold 13px Courier New, monospace';
            ctxP.textAlign = 'center';
            ctxP.fillText(`P = ${(prob * 100).toFixed(1)}%`, midPx, midPy + 5);

            // Readout panel
            document.getElementById('probReadout').innerHTML =
                `<div class="readout-row"><span style="color:#ff9f43">P(${a.toFixed(1)} \u2264 X \u2264 ${b.toFixed(1)}) =</span></div>`
                + `<div style="text-align:center; font-size:18px; font-weight:bold; color:#ff9f43; margin:4px 0;">${(prob * 100).toFixed(2)}%</div>`;
        }

        function fmtStat(v) {
            if (v === Infinity || v === -Infinity) return '\u221E';
            if (isNaN(v)) return 'undefined';
            return v.toFixed(3);
        }

        function updateStats() {
            const d = distributions[curDist];
            const mu = d.mean(params);
            const med = d.median(params);
            const sig = d.stddev(params);

            let html = `<div class="readout-row"><span style="color:#e94560">Mean (\u03BC):</span><span>${fmtStat(mu)}</span></div>`
                + `<div class="readout-row"><span style="color:#aaa">Median:</span><span>${fmtStat(med)}</span></div>`
                + `<div class="readout-row"><span style="color:#aaa">Std Dev (\u03C3):</span><span>${fmtStat(sig)}</span></div>`;

            if (isNaN(mu)) {
                html += `<div style="font-size:10px; color:#e94560; margin-top:4px;">Mean is undefined for this distribution!</div>`;
            }
            if (sig === Infinity) {
                html += `<div style="font-size:10px; color:#e94560; margin-top:2px;">Variance is infinite \u2014 extreme tail risk</div>`;
            }

            if (samples.length > 0) {
                const n = samples.length;
                const sMean = samples.reduce((a,b) => a+b, 0) / n;
                const sVar = samples.reduce((a,b) => a + (b-sMean)**2, 0) / n;
                const sStd = Math.sqrt(sVar);
                // Excess kurtosis (measure of tail heaviness)
                let sKurt = 0;
                let sSkew = 0;
                if (sStd > 0 && n > 3) {
                    const m3 = samples.reduce((a,b) => a + ((b-sMean)/sStd)**3, 0) / n;
                    const m4 = samples.reduce((a,b) => a + ((b-sMean)/sStd)**4, 0) / n;
                    sSkew = m3;
                    sKurt = m4 - 3;  // excess kurtosis (normal = 0)
                }
                html += `<div style="border-top:1px solid rgba(255,255,255,0.06); margin-top:6px; padding-top:6px;">`
                    + `<div style="font-size:10px; color:#666; margin-bottom:4px;">FROM ${n.toLocaleString()} SAMPLES:</div>`
                    + `<div class="readout-row"><span style="color:#a78bfa">Sample mean:</span><span>${sMean.toFixed(3)}</span></div>`
                    + `<div class="readout-row"><span style="color:#a78bfa">Sample std:</span><span>${sStd.toFixed(3)}</span></div>`
                    + `<div class="readout-row"><span style="color:#a78bfa">Skewness:</span><span>${sSkew.toFixed(3)}</span></div>`
                    + `<div class="readout-row"><span style="color:#a78bfa">Excess kurtosis:</span><span style="color:${sKurt > 1 ? '#e94560' : '#a78bfa'}">${sKurt.toFixed(3)}</span></div>`;
                if (sKurt > 1) {
                    html += `<div style="font-size:10px; color:#ff9f43; margin-top:2px;">Kurtosis > 0 \u2192 heavier tails than normal</div>`;
                }
                html += `</div>`;
            }
            document.getElementById('statsReadout').innerHTML = html;
        }

        // ---- Main draw loop ----
        let rainTimer = 0;
        function draw() {
            ctxP.clearRect(0, 0, WP, HP);
            ctxH.clearRect(0, 0, WH, HH);
            const d = distributions[curDist];
            const xRange = typeof d.xRange === 'function' ? d.xRange(params) : d.xRange;

            // Rain mode
            if (raining) {
                rainTimer++;
                if (rainTimer % 2 === 0) addSamples(5);
            }

            // ---- PDF canvas ----
            drawAxes(ctxP, WP, HP, xRange, 1, 'Probability Density');
            const { maxY, scY } = drawPDFCurve(xRange);
            drawShadedRegion(xRange, scY);
            drawMeanStd(xRange, scY);
            drawProbBox(xRange, scY);

            // Total area = 1 label
            ctxP.fillStyle = 'rgba(22, 33, 62, 0.85)';
            ctxP.fillRect(WP - padR - 168, padT, 164, 28);
            ctxP.strokeStyle = 'rgba(255,255,255,0.1)';
            ctxP.lineWidth = 1;
            ctxP.strokeRect(WP - padR - 168, padT, 164, 28);
            ctxP.fillStyle = '#4ecdc4';
            ctxP.font = '12px Courier New, monospace';
            ctxP.textAlign = 'left';
            ctxP.fillText('Total area under curve = 1', WP - padR - 162, padT + 18);

            // ---- Histogram canvas ----
            drawAxes(ctxH, WH, HH, xRange, 1, 'Sample Histogram');
            drawHistogram(xRange);
            drawFallingDots();

            // Stats
            updateStats();

            requestAnimationFrame(draw);
        }

        // ---- Mouse drag bounds on PDF canvas ----
        let dragging = null;
        cPDF.addEventListener('mousedown', (e) => {
            const rect = cPDF.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const d = distributions[curDist];
            const xRange = typeof d.xRange === 'function' ? d.xRange(params) : d.xRange;
            const distA = Math.abs(mx - valToPixX(queryA, xRange));
            const distB = Math.abs(mx - valToPixX(queryB, xRange));
            if (distA < 15 && distA <= distB) dragging = 'a';
            else if (distB < 15) dragging = 'b';
        });
        cPDF.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const rect = cPDF.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const d = distributions[curDist];
            const xRange = typeof d.xRange === 'function' ? d.xRange(params) : d.xRange;
            const val = pixToValX(mx, xRange);
            if (dragging === 'a') {
                queryA = val;
                document.getElementById('sliderQA').value = Math.round(val * 100);
                document.getElementById('valQA').textContent = val.toFixed(2);
            } else {
                queryB = val;
                document.getElementById('sliderQB').value = Math.round(val * 100);
                document.getElementById('valQB').textContent = val.toFixed(2);
            }
        });
        cPDF.addEventListener('mouseup', () => { dragging = null; });
        cPDF.addEventListener('mouseleave', () => { dragging = null; });

        // ---- Init ----
        buildParamSliders();
        updateEquation();
        updateInsight();
        draw();
    </script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Coded by <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
