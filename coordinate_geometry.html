<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinate Geometry</title>
    <meta name="description" content="Plot points, lines, and curves on the Cartesian plane. Interactive coordinate geometry with distance, midpoint, and gradient tools.">
    <link rel="canonical" href="https://mathsedu.org/coordinate_geometry.html">
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "LearningResource",
      "name": "Coordinate Geometry",
      "url": "https://mathsedu.org/coordinate_geometry.html",
      "description": "Plot points, lines, and curves on the Cartesian plane. Interactive coordinate geometry with distance, midpoint, and gradient tools.",
      "educationalLevel": "Beginner",
      "teaches": "Coordinate geometry",
      "learningResourceType": "Interactive visualisation",
      "interactivityType": "active",
      "inLanguage": "en",
      "isAccessibleForFree": true,
      "creator": {
        "@type": "Person",
        "name": "Manoj Bhaskar"
      },
      "license": "https://creativecommons.org/licenses/by-nc-sa/4.0/",
      "isPartOf": {
        "@type": "Course",
        "name": "Geometry",
        "url": "https://mathsedu.org/"
      }
    }
    </script>
    <meta property="og:title" content="Coordinate Geometry">
    <meta property="og:description" content="Plot points, lines, and curves on the Cartesian plane. Interactive coordinate geometry with distance, midpoint, and gradient tools.">
    <meta property="og:url" content="https://mathsedu.org/coordinate_geometry.html">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="A Visual Discovery of Mathematics">
    <meta property="og:locale" content="en_GB">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Coordinate Geometry">
    <meta name="twitter:description" content="Plot points, lines, and curves on the Cartesian plane. Interactive coordinate geometry with distance, midpoint, and gradient tools.">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a1a;color:#e0e0e0;font-family:Georgia,'Times New Roman',serif;line-height:1.6}
        .container{max-width:960px;margin:0 auto;padding:24px 28px 48px}
        .back{color:#606078;text-decoration:none;font-size:0.85em}
        .back:hover{color:#f87171}
        h1{font-size:1.8em;font-weight:400;color:#fff;margin:16px 0 4px}
        .subtitle{color:#808098;font-style:italic;margin-bottom:28px}
        h2{font-size:1.15em;font-weight:400;color:#fff;margin:28px 0 12px}
        canvas{display:block;border-radius:10px;border:1px solid rgba(255,255,255,0.06);cursor:crosshair}
        .panel{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:18px 22px;margin-bottom:20px}
        .panel h3{font-weight:400;font-size:0.8em;color:#808098;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px}
        .btn-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
        .btn{background:rgba(255,255,255,0.035);border:1px solid rgba(255,255,255,0.07);color:#b0b0c4;padding:5px 13px;border-radius:6px;cursor:pointer;font-family:Georgia,serif;font-size:0.92em;transition:all 0.2s}
        .btn:hover{background:rgba(255,255,255,0.07);color:#e0e0ef}
        .btn.active{background:rgba(248,113,113,0.13);border-color:rgba(248,113,113,0.4);color:#f87171}
        .math-line{font-family:'Courier New',monospace;font-size:0.92em;color:#c0c0d8;margin:4px 0;line-height:1.8}
        .math-line .coral{color:#f87171}.math-line .cyan{color:#67e8f9}.math-line .green{color:#2ecc71}
        .math-line .muted{color:#808098}
        .slider-row{display:flex;align-items:center;gap:14px;margin:10px 0}
        .slider-row input[type=range]{flex:1;max-width:260px;accent-color:#f87171}
        .slider-label{color:#f87171;font-family:'Courier New',monospace;font-size:1.05em;min-width:50px}
        .explain{background:rgba(255,255,255,0.025);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:20px 24px;margin-top:20px}
        .explain-name{color:#f87171;font-size:1.1em;margin-bottom:6px}
        .explain-text{color:#a0a0b8;font-size:0.9em;line-height:1.75}
        .toggle-row{display:flex;align-items:center;gap:10px;margin:8px 0}
        .toggle-row label{color:#808098;font-size:0.88em;cursor:pointer}
        .toggle-row input[type=checkbox]{accent-color:#f87171}
        .flex-row{display:flex;gap:20px;flex-wrap:wrap}
        .flex-row>.flex-half{flex:1 1 300px;min-width:280px}
        @media(max-width:600px){canvas{width:100%!important;height:auto!important}}
    </style>
</head>
<body>
<div class="container">
    <a class="back" href="index.html">&larr; Back to Index</a>
    <h1>Coordinate Geometry</h1>
    <p class="subtitle">Distance, midpoint, slope &mdash; algebra meets geometry on the plane</p>

    <!-- ═══════════════════════════════════════════════════════════════════
         SECTION 1: Interactive Cartesian Plane
         ═══════════════════════════════════════════════════════════════════ -->
    <h2>Interactive Cartesian Plane</h2>
    <canvas id="mainCanvas" width="650" height="500"></canvas>
    <div class="panel" style="margin-top:20px">
        <h3>Live Measurements</h3>
        <div id="mainMath"></div>
    </div>
    <div class="panel">
        <h3>Equation of Line through A and B</h3>
        <div id="lineEqs"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════
         SECTION 2: Parallel & Perpendicular Lines
         ═══════════════════════════════════════════════════════════════════ -->
    <h2>Parallel &amp; Perpendicular Lines</h2>
    <canvas id="parCanvas" width="600" height="400"></canvas>
    <div class="panel" style="margin-top:20px">
        <h3>Line Relationship</h3>
        <div class="toggle-row">
            <input type="checkbox" id="showAngleToggle" checked>
            <label for="showAngleToggle">Show angle between lines</label>
        </div>
        <div id="parMath"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════
         SECTION 3: Point-to-Line Distance
         ═══════════════════════════════════════════════════════════════════ -->
    <h2>Point-to-Line Distance</h2>
    <canvas id="ptlCanvas" width="600" height="350"></canvas>
    <div class="panel" style="margin-top:20px">
        <h3>Perpendicular Distance</h3>
        <div id="ptlMath"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════
         SECTION 4: Locus Explorer
         ═══════════════════════════════════════════════════════════════════ -->
    <h2>Locus Explorer</h2>
    <div class="panel">
        <h3>Locus Type</h3>
        <div class="btn-row" id="locusBtns"></div>
    </div>
    <canvas id="locusCanvas" width="600" height="400"></canvas>
    <div class="panel" style="margin-top:20px">
        <h3>Locus Equation</h3>
        <div id="locusMath"></div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════
         SECTION 5: Section Formula & Area
         ═══════════════════════════════════════════════════════════════════ -->
    <h2>Section Formula &amp; Area</h2>
    <div class="flex-row">
        <div class="flex-half">
            <div class="panel">
                <h3>Section Formula</h3>
                <canvas id="secCanvas" width="400" height="300" style="margin-bottom:12px"></canvas>
                <div class="slider-row">
                    <span class="math-line muted">m =</span>
                    <input type="range" id="secM" min="1" max="10" value="2">
                    <span class="slider-label" id="secMLabel">2</span>
                </div>
                <div class="slider-row">
                    <span class="math-line muted">n =</span>
                    <input type="range" id="secN" min="1" max="10" value="3">
                    <span class="slider-label" id="secNLabel">3</span>
                </div>
                <div class="btn-row" style="margin-top:8px">
                    <button class="btn active" id="intDivBtn">Internal</button>
                    <button class="btn" id="extDivBtn">External</button>
                </div>
                <div id="secMath"></div>
            </div>
        </div>
        <div class="flex-half">
            <div class="panel">
                <h3>Triangle Area</h3>
                <canvas id="triCanvas" width="400" height="300" style="margin-bottom:12px"></canvas>
                <div id="triMath"></div>
            </div>
        </div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════
         SECTION 6: Explanation
         ═══════════════════════════════════════════════════════════════════ -->
    <div class="explain">
        <div class="explain-name">What have we learnt?</div>
        <div class="explain-text">
            Coordinate geometry is Descartes' great unification &mdash; algebra and geometry become one. Every geometric shape becomes an equation, and every equation becomes a shape. A line is y = mx + b. A circle is (x &minus; h)&sup2; + (y &minus; k)&sup2; = r&sup2;. Distance, midpoint, slope, area &mdash; all reduce to arithmetic on coordinates.
            <br><br>
            This is the bridge to calculus (slopes become derivatives, areas become integrals) and to computer graphics (everything rendered on a screen is coordinates). When Descartes placed a grid on the plane in 1637, he gave us the language that would power Newton's physics, Einstein's spacetime, and every pixel on your display.
        </div>
    </div>
</div>

<script>
/* ══════════════════════════════════════════════════════════════════════════
   SHARED UTILITIES (must be defined before IIFEs execute)
   ══════════════════════════════════════════════════════════════════════════ */
function r2(v) { return Math.round(v * 100) / 100; }
function r2s(v) {
    var rv = Math.round(v * 100) / 100;
    return rv < 0 ? '(' + rv + ')' : '' + rv;
}

/* ══════════════════════════════════════════════════════════════════════════
   SECTION 1: Interactive Cartesian Plane
   ══════════════════════════════════════════════════════════════════════════ */
(function(){
    const cvs = document.getElementById('mainCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const scale = 40;
    const ox = W / 2, oy = H / 2;

    let A = { x: -3, y: 2 }, B = { x: 4, y: -1 };
    let drag = null;

    function toS(px, py) { return { x: ox + px * scale, y: oy - py * scale }; }
    function toW(sx, sy) { return { x: (sx - ox) / scale, y: -(sy - oy) / scale }; }

    function draw() {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#0a0a1a'; ctx.fillRect(0, 0, W, H);

        // grid
        const halfW = W / (2 * scale), halfH = H / (2 * scale);
        ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
        for (let i = Math.ceil(-halfW); i <= Math.floor(halfW); i++) {
            const sx = ox + i * scale;
            ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, H); ctx.stroke();
        }
        for (let i = Math.ceil(-halfH); i <= Math.floor(halfH); i++) {
            const sy = oy - i * scale;
            ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(W, sy); ctx.stroke();
        }
        // axes
        ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(W, oy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ox, 0); ctx.lineTo(ox, H); ctx.stroke();
        // tick marks and labels
        ctx.font = '10px Georgia'; ctx.fillStyle = '#505068'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        for (let i = Math.ceil(-halfW); i <= Math.floor(halfW); i++) {
            if (i === 0) continue;
            const sx = ox + i * scale;
            ctx.beginPath(); ctx.moveTo(sx, oy - 3); ctx.lineTo(sx, oy + 3); ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1; ctx.stroke();
            ctx.fillText(i, sx, oy + 5);
        }
        ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        for (let i = Math.ceil(-halfH); i <= Math.floor(halfH); i++) {
            if (i === 0) continue;
            const sy = oy - i * scale;
            ctx.beginPath(); ctx.moveTo(ox - 3, sy); ctx.lineTo(ox + 3, sy); ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1; ctx.stroke();
            ctx.fillText(i, ox - 6, sy);
        }
        // axis labels
        ctx.font = '13px Georgia'; ctx.fillStyle = '#808098';
        ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
        ctx.fillText('x', W - 18, oy - 6);
        ctx.textAlign = 'left'; ctx.textBaseline = 'top';
        ctx.fillText('y', ox + 8, 6);

        const sA = toS(A.x, A.y), sB = toS(B.x, B.y);

        // extended line through A and B
        drawExtendedLine(ctx, A, B, W, H, scale, ox, oy, 'rgba(255,255,255,0.15)', 1.5);

        // right triangle (dashed legs)
        const dx = B.x - A.x, dy = B.y - A.y;
        const corner = toS(B.x, A.y);
        ctx.setLineDash([5, 4]);
        // horizontal leg
        ctx.strokeStyle = 'rgba(248,113,113,0.4)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(corner.x, corner.y); ctx.stroke();
        // vertical leg
        ctx.strokeStyle = 'rgba(103,232,249,0.4)';
        ctx.beginPath(); ctx.moveTo(corner.x, corner.y); ctx.lineTo(sB.x, sB.y); ctx.stroke();
        ctx.setLineDash([]);

        // rise/run labels
        ctx.font = '11px Courier New';
        if (Math.abs(dx) > 0.01) {
            ctx.fillStyle = '#f87171'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
            ctx.fillText('run=' + r2(dx), (sA.x + corner.x) / 2, Math.max(sA.y, corner.y) + 8);
        }
        if (Math.abs(dy) > 0.01) {
            ctx.fillStyle = '#67e8f9'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
            ctx.fillText('rise=' + r2(dy), corner.x + 6, (corner.y + sB.y) / 2);
        }

        // right angle mark at corner
        if (Math.abs(dx) > 0.3 && Math.abs(dy) > 0.3) {
            const sz = 8;
            const dirX = dx > 0 ? -1 : 1;
            const dirY = dy > 0 ? -1 : 1;
            ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(corner.x + dirX * sz, corner.y);
            ctx.lineTo(corner.x + dirX * sz, corner.y + dirY * sz);
            ctx.lineTo(corner.x, corner.y + dirY * sz);
            ctx.stroke();
        }

        // hypotenuse (distance line) - thicker
        ctx.strokeStyle = '#f87171'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke();

        // distance label on hypotenuse
        const dist = Math.sqrt(dx * dx + dy * dy);
        const midLine = { x: (sA.x + sB.x) / 2, y: (sA.y + sB.y) / 2 };
        ctx.font = '12px Courier New'; ctx.fillStyle = '#f87171';
        ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
        ctx.fillText('d=' + dist.toFixed(3), midLine.x, midLine.y - 8);

        // midpoint M
        const mx = (A.x + B.x) / 2, my = (A.y + B.y) / 2;
        const sM = toS(mx, my);
        ctx.fillStyle = '#2ecc71';
        ctx.beginPath(); ctx.arc(sM.x, sM.y, 5, 0, Math.PI * 2); ctx.fill();
        ctx.font = '12px Georgia'; ctx.fillStyle = '#2ecc71';
        ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
        ctx.fillText('M(' + r2(mx) + ', ' + r2(my) + ')', sM.x + 8, sM.y - 6);

        // point A (coral)
        ctx.fillStyle = '#f87171';
        ctx.beginPath(); ctx.arc(sA.x, sA.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.font = '13px Georgia'; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
        ctx.fillText('A(' + r2(A.x) + ', ' + r2(A.y) + ')', sA.x - 8, sA.y - 8);

        // point B (cyan)
        ctx.fillStyle = '#67e8f9';
        ctx.beginPath(); ctx.arc(sB.x, sB.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.font = '13px Georgia'; ctx.fillStyle = '#67e8f9'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
        ctx.fillText('B(' + r2(B.x) + ', ' + r2(B.y) + ')', sB.x + 8, sB.y + 8);

        updateMainMath();
    }

    function drawExtendedLine(ctx, P, Q, W, H, sc, ox, oy, color, lw) {
        const dx = Q.x - P.x, dy = Q.y - P.y;
        if (Math.abs(dx) < 1e-9 && Math.abs(dy) < 1e-9) return;
        let t0 = -1000, t1 = 1000;
        const sx = ox + (P.x + t0 * dx) * sc, sy = oy - (P.y + t0 * dy) * sc;
        const ex = ox + (P.x + t1 * dx) * sc, ey = oy - (P.y + t1 * dy) * sc;
        ctx.strokeStyle = color; ctx.lineWidth = lw;
        ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
    }

    function updateMainMath() {
        const dx = B.x - A.x, dy = B.y - A.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const mx = (A.x + B.x) / 2, my = (A.y + B.y) / 2;
        const isVert = Math.abs(dx) < 0.01;
        const slope = isVert ? null : dy / dx;
        let html = '';
        html += '<div class="math-line"><span class="coral">A = (' + r2(A.x) + ', ' + r2(A.y) + ')</span> &emsp; <span class="cyan">B = (' + r2(B.x) + ', ' + r2(B.y) + ')</span></div>';
        html += '<hr style="border:none;border-top:1px solid rgba(255,255,255,0.06);margin:8px 0">';
        html += '<div class="math-line">Distance: d = &radic;((' + r2(B.x) + '&minus;' + r2s(A.x) + ')&sup2; + (' + r2(B.y) + '&minus;' + r2s(A.y) + ')&sup2;) = &radic;(' + r2(dx * dx) + ' + ' + r2(dy * dy) + ') = <span class="coral">' + dist.toFixed(4) + '</span></div>';
        html += '<div class="math-line">Midpoint: M = ((' + r2(A.x) + '+' + r2(B.x) + ')/2, (' + r2(A.y) + '+' + r2(B.y) + ')/2) = <span class="green">(' + r2(mx) + ', ' + r2(my) + ')</span></div>';
        if (isVert) {
            html += '<div class="math-line">Slope: m = <span class="muted">undefined (vertical line)</span></div>';
        } else {
            html += '<div class="math-line">Slope: m = (' + r2(B.y) + '&minus;' + r2s(A.y) + ')/(' + r2(B.x) + '&minus;' + r2s(A.x) + ') = ' + r2(dy) + '/' + r2(dx) + ' = <span class="coral">' + slope.toFixed(4) + '</span></div>';
        }
        document.getElementById('mainMath').innerHTML = html;

        // line equations
        let eqs = '';
        if (isVert) {
            eqs += '<div class="math-line">x = ' + r2(A.x) + ' &emsp;<span class="muted">(vertical line)</span></div>';
            eqs += '<div class="math-line">General form: <span class="coral">1x + 0y + (' + r2(-A.x) + ') = 0</span></div>';
        } else {
            const m = slope;
            const b = A.y - m * A.x;
            eqs += '<div class="math-line">Slope-intercept: <span class="coral">y = ' + fmtLinear(m, b) + '</span></div>';
            eqs += '<div class="math-line">Point-slope: <span class="cyan">y &minus; ' + r2s(A.y) + ' = ' + r2(m) + '(x &minus; ' + r2s(A.x) + ')</span></div>';
            // general form: ax + by + c = 0 with integer-ish coefficients
            const a_gen = -dy, b_gen = dx, c_gen = -(a_gen * A.x + b_gen * A.y);
            eqs += '<div class="math-line">General form: <span class="green">' + r2(a_gen) + 'x + ' + r2s(b_gen) + 'y + ' + r2s(c_gen) + ' = 0</span></div>';
        }
        document.getElementById('lineEqs').innerHTML = eqs;
    }

    function fmtLinear(m, b) {
        let s = r2(m) + 'x';
        if (b >= 0) s += ' + ' + r2(b);
        else s += ' - ' + r2(Math.abs(b));
        return s;
    }

    // drag
    function getP(e) {
        const r = cvs.getBoundingClientRect();
        return { x: (e.clientX - r.left) * (W / r.width), y: (e.clientY - r.top) * (H / r.height) };
    }
    function d2(a, b) { return (a.x - b.x) ** 2 + (a.y - b.y) ** 2; }

    cvs.addEventListener('mousedown', e => {
        const p = getP(e);
        const sA = toS(A.x, A.y), sB = toS(B.x, B.y);
        if (d2(p, sA) < 200) drag = 'A';
        else if (d2(p, sB) < 200) drag = 'B';
        else drag = null;
    });
    cvs.addEventListener('mousemove', e => {
        if (!drag) return;
        const p = getP(e);
        const c = toW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4;
        c.y = Math.round(c.y * 4) / 4;
        if (drag === 'A') { A.x = c.x; A.y = c.y; }
        else { B.x = c.x; B.y = c.y; }
        draw();
    });
    cvs.addEventListener('mouseup', () => { drag = null; });
    cvs.addEventListener('mouseleave', () => { drag = null; });

    // touch
    cvs.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0], r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        const sA = toS(A.x, A.y), sB = toS(B.x, B.y);
        if (d2(p, sA) < 600) drag = 'A';
        else if (d2(p, sB) < 600) drag = 'B';
    }, { passive: false });
    cvs.addEventListener('touchmove', e => {
        e.preventDefault();
        if (!drag) return;
        const t = e.touches[0], r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        const c = toW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4;
        c.y = Math.round(c.y * 4) / 4;
        if (drag === 'A') { A.x = c.x; A.y = c.y; }
        else { B.x = c.x; B.y = c.y; }
        draw();
    }, { passive: false });
    cvs.addEventListener('touchend', () => { drag = null; });

    draw();
})();

/* ══════════════════════════════════════════════════════════════════════════
   SECTION 2: Parallel & Perpendicular Lines
   ══════════════════════════════════════════════════════════════════════════ */
(function(){
    const cvs = document.getElementById('parCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const scale = 40, ox = W / 2, oy = H / 2;

    // line 1: P1-Q1, line 2: P2-Q2
    let P1 = { x: -5, y: 1 }, Q1 = { x: 3, y: 3 };
    let P2 = { x: -4, y: -2 }, Q2 = { x: 2, y: 2 };
    let drag = null;

    function toS(px, py) { return { x: ox + px * scale, y: oy - py * scale }; }
    function toW(sx, sy) { return { x: (sx - ox) / scale, y: -(sy - oy) / scale }; }

    function draw() {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#0a0a1a'; ctx.fillRect(0, 0, W, H);
        // grid
        const halfW = W / (2 * scale), halfH = H / (2 * scale);
        ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
        for (let i = Math.ceil(-halfW); i <= Math.floor(halfW); i++) {
            ctx.beginPath(); ctx.moveTo(ox + i * scale, 0); ctx.lineTo(ox + i * scale, H); ctx.stroke();
        }
        for (let i = Math.ceil(-halfH); i <= Math.floor(halfH); i++) {
            ctx.beginPath(); ctx.moveTo(0, oy - i * scale); ctx.lineTo(W, oy - i * scale); ctx.stroke();
        }
        ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(W, oy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ox, 0); ctx.lineTo(ox, H); ctx.stroke();

        // slopes
        const dx1 = Q1.x - P1.x, dy1 = Q1.y - P1.y;
        const dx2 = Q2.x - P2.x, dy2 = Q2.y - P2.y;
        const v1 = Math.abs(dx1) < 1e-9, v2 = Math.abs(dx2) < 1e-9;
        const m1 = v1 ? null : dy1 / dx1;
        const m2 = v2 ? null : dy2 / dx2;

        // detect relationship
        let relation = 'neither';
        let angleDeg = 0;
        const parThresh = 0.08, perpThresh = 0.15;
        if (v1 && v2) {
            relation = 'parallel';
        } else if ((v1 && !v2) || (!v1 && v2)) {
            // one vertical one not
            if ((v1 && Math.abs(m2) < parThresh) || (v2 && Math.abs(m1) < parThresh)) {
                relation = 'perpendicular';
            } else {
                relation = 'neither';
                angleDeg = 90;
            }
        } else {
            const diff = Math.abs(m1 - m2);
            const prod = m1 * m2;
            if (diff < parThresh) {
                relation = 'parallel';
            } else if (Math.abs(prod + 1) < perpThresh) {
                relation = 'perpendicular';
            }
            if (relation === 'neither' || relation === 'perpendicular') {
                const denom = 1 + m1 * m2;
                if (Math.abs(denom) < 1e-9) {
                    angleDeg = 90;
                } else {
                    angleDeg = Math.abs(Math.atan(Math.abs(m1 - m2) / denom)) * 180 / Math.PI;
                }
            }
            if (relation === 'perpendicular') angleDeg = 90;
        }

        // choose colors
        const c1 = relation === 'parallel' ? '#f87171' : '#f87171';
        const c2 = relation === 'parallel' ? '#f87171' : '#67e8f9';

        // draw extended lines
        extLine(ctx, P1, Q1, c1, 2);
        extLine(ctx, P2, Q2, c2, 2);

        // intersection point
        const showAngle = document.getElementById('showAngleToggle').checked;
        if (relation !== 'parallel' && !(v1 && v2)) {
            const ip = lineIntersect(P1, Q1, P2, Q2);
            if (ip) {
                const sip = toS(ip.x, ip.y);
                if (relation === 'perpendicular') {
                    // right angle mark
                    const sz = 12;
                    const ang1 = Math.atan2(-(Q1.y - P1.y), Q1.x - P1.x);
                    const ang2 = Math.atan2(-(Q2.y - P2.y), Q2.x - P2.x);
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(sip.x + sz * Math.cos(ang1), sip.y + sz * Math.sin(ang1));
                    ctx.lineTo(sip.x + sz * Math.cos(ang1) + sz * Math.cos(ang2), sip.y + sz * Math.sin(ang1) + sz * Math.sin(ang2));
                    ctx.lineTo(sip.x + sz * Math.cos(ang2), sip.y + sz * Math.sin(ang2));
                    ctx.stroke();
                }
                if (showAngle && relation !== 'parallel') {
                    // draw angle arc
                    const ang1 = Math.atan2(Q1.y - P1.y, Q1.x - P1.x);
                    const ang2 = Math.atan2(Q2.y - P2.y, Q2.x - P2.x);
                    ctx.strokeStyle = 'rgba(248,113,113,0.5)'; ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(sip.x, sip.y, 25, -ang1, -ang2, ang1 > ang2);
                    ctx.stroke();
                    // angle label
                    const midAng = -(ang1 + ang2) / 2;
                    ctx.font = '11px Courier New'; ctx.fillStyle = '#f87171';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(angleDeg.toFixed(1) + '\u00B0', sip.x + 40 * Math.cos(midAng), sip.y + 40 * Math.sin(midAng));
                }
                // intersection dot
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(sip.x, sip.y, 3, 0, Math.PI * 2); ctx.fill();
            }
        }

        // control points
        drawCtrl(P1, c1, 'P\u2081'); drawCtrl(Q1, c1, 'Q\u2081');
        drawCtrl(P2, c2, 'P\u2082'); drawCtrl(Q2, c2, 'Q\u2082');

        updateParMath(m1, m2, v1, v2, relation, angleDeg);
    }

    function extLine(ctx, P, Q, color, lw) {
        const dx = Q.x - P.x, dy = Q.y - P.y;
        if (Math.abs(dx) < 1e-9 && Math.abs(dy) < 1e-9) return;
        const t0 = -100, t1 = 100;
        const sx = ox + (P.x + t0 * dx) * scale, sy = oy - (P.y + t0 * dy) * scale;
        const ex = ox + (P.x + t1 * dx) * scale, ey = oy - (P.y + t1 * dy) * scale;
        ctx.strokeStyle = color; ctx.lineWidth = lw;
        ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
    }

    function drawCtrl(pt, color, label) {
        const s = toS(pt.x, pt.y);
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(s.x, s.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.font = '11px Georgia'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
        ctx.fillText(label, s.x + 8, s.y - 6);
    }

    function lineIntersect(P1, Q1, P2, Q2) {
        const a1 = Q1.y - P1.y, b1 = P1.x - Q1.x, c1 = a1 * P1.x + b1 * P1.y;
        const a2 = Q2.y - P2.y, b2 = P2.x - Q2.x, c2 = a2 * P2.x + b2 * P2.y;
        const det = a1 * b2 - a2 * b1;
        if (Math.abs(det) < 1e-9) return null;
        return { x: (b2 * c1 - b1 * c2) / det, y: (a1 * c2 - a2 * c1) / det };
    }

    function updateParMath(m1, m2, v1, v2, relation, angleDeg) {
        let html = '';
        html += '<div class="math-line"><span class="coral">Line 1: m\u2081 = ' + (v1 ? 'undefined (vertical)' : r2(m1)) + '</span></div>';
        html += '<div class="math-line"><span class="cyan">Line 2: m\u2082 = ' + (v2 ? 'undefined (vertical)' : r2(m2)) + '</span></div>';
        html += '<hr style="border:none;border-top:1px solid rgba(255,255,255,0.06);margin:8px 0">';
        if (relation === 'parallel') {
            html += '<div class="math-line" style="color:#f87171;font-size:1.05em">Parallel! Same slope: m\u2081 = m\u2082</div>';
        } else if (relation === 'perpendicular') {
            const prod = (v1 || v2) ? 'N/A' : r2(m1 * m2);
            html += '<div class="math-line" style="color:#2ecc71;font-size:1.05em">Perpendicular! m\u2081 \u00D7 m\u2082 = ' + prod + ' \u2248 -1</div>';
        } else {
            html += '<div class="math-line"><span class="muted">Neither parallel nor perpendicular</span></div>';
            if (!v1 && !v2) {
                html += '<div class="math-line">m\u2081 \u00D7 m\u2082 = ' + r2(m1 * m2) + '</div>';
            }
            html += '<div class="math-line">Angle: tan(\u03B8) = |m\u2081 \u2212 m\u2082| / (1 + m\u2081m\u2082) &rArr; \u03B8 = <span class="coral">' + angleDeg.toFixed(2) + '\u00B0</span></div>';
        }
        document.getElementById('parMath').innerHTML = html;
    }

    // drag
    function getP(e) {
        const r = cvs.getBoundingClientRect();
        return { x: (e.clientX - r.left) * (W / r.width), y: (e.clientY - r.top) * (H / r.height) };
    }
    function d2(a, b) { return (a.x - b.x) ** 2 + (a.y - b.y) ** 2; }
    const pts = () => [
        { ref: P1, key: 'P1' }, { ref: Q1, key: 'Q1' },
        { ref: P2, key: 'P2' }, { ref: Q2, key: 'Q2' }
    ];

    cvs.addEventListener('mousedown', e => {
        const p = getP(e);
        drag = null;
        for (const { ref, key } of pts()) {
            if (d2(p, toS(ref.x, ref.y)) < 200) { drag = key; break; }
        }
    });
    cvs.addEventListener('mousemove', e => {
        if (!drag) return;
        const p = getP(e), c = toW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        if (drag === 'P1') { P1.x = c.x; P1.y = c.y; }
        else if (drag === 'Q1') { Q1.x = c.x; Q1.y = c.y; }
        else if (drag === 'P2') { P2.x = c.x; P2.y = c.y; }
        else if (drag === 'Q2') { Q2.x = c.x; Q2.y = c.y; }
        draw();
    });
    cvs.addEventListener('mouseup', () => { drag = null; });
    cvs.addEventListener('mouseleave', () => { drag = null; });
    // touch
    cvs.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0], r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        drag = null;
        for (const { ref, key } of pts()) {
            if (d2(p, toS(ref.x, ref.y)) < 600) { drag = key; break; }
        }
    }, { passive: false });
    cvs.addEventListener('touchmove', e => {
        e.preventDefault(); if (!drag) return;
        const t = e.touches[0], r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        const c = toW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        if (drag === 'P1') { P1.x = c.x; P1.y = c.y; }
        else if (drag === 'Q1') { Q1.x = c.x; Q1.y = c.y; }
        else if (drag === 'P2') { P2.x = c.x; P2.y = c.y; }
        else if (drag === 'Q2') { Q2.x = c.x; Q2.y = c.y; }
        draw();
    }, { passive: false });
    cvs.addEventListener('touchend', () => { drag = null; });

    document.getElementById('showAngleToggle').addEventListener('change', draw);
    draw();
})();

/* ══════════════════════════════════════════════════════════════════════════
   SECTION 3: Point-to-Line Distance
   ══════════════════════════════════════════════════════════════════════════ */
(function(){
    const cvs = document.getElementById('ptlCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const scale = 40, ox = W / 2, oy = H / 2;

    let P = { x: 2, y: 3 };
    let L1 = { x: -5, y: -1 }, L2 = { x: 4, y: 1 };
    let drag = null;

    function toS(px, py) { return { x: ox + px * scale, y: oy - py * scale }; }
    function toW(sx, sy) { return { x: (sx - ox) / scale, y: -(sy - oy) / scale }; }

    function draw() {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#0a0a1a'; ctx.fillRect(0, 0, W, H);
        // grid
        const halfW = W / (2 * scale), halfH = H / (2 * scale);
        ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
        for (let i = Math.ceil(-halfW); i <= Math.floor(halfW); i++) {
            ctx.beginPath(); ctx.moveTo(ox + i * scale, 0); ctx.lineTo(ox + i * scale, H); ctx.stroke();
        }
        for (let i = Math.ceil(-halfH); i <= Math.floor(halfH); i++) {
            ctx.beginPath(); ctx.moveTo(0, oy - i * scale); ctx.lineTo(W, oy - i * scale); ctx.stroke();
        }
        ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(W, oy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ox, 0); ctx.lineTo(ox, H); ctx.stroke();

        // line through L1, L2 (extended)
        const dlx = L2.x - L1.x, dly = L2.y - L1.y;
        if (Math.abs(dlx) > 1e-9 || Math.abs(dly) > 1e-9) {
            const t0 = -100, t1 = 100;
            const sx = ox + (L1.x + t0 * dlx) * scale, sy = oy - (L1.y + t0 * dly) * scale;
            const ex = ox + (L1.x + t1 * dlx) * scale, ey = oy - (L1.y + t1 * dly) * scale;
            ctx.strokeStyle = '#67e8f9'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
        }

        // compute general form ax + by + c = 0
        const a = L2.y - L1.y, b = L1.x - L2.x;
        const c = a * L1.x + b * L1.y;
        // distance = |a*P.x + b*P.y - c| / sqrt(a^2 + b^2)
        const num = Math.abs(a * P.x + b * P.y - c);
        const den = Math.sqrt(a * a + b * b);
        const dist = den > 1e-9 ? num / den : 0;

        // foot of perpendicular
        let foot;
        if (den > 1e-9) {
            const t = ((P.x - L1.x) * dlx + (P.y - L1.y) * dly) / (dlx * dlx + dly * dly);
            foot = { x: L1.x + t * dlx, y: L1.y + t * dly };
        } else {
            foot = { x: L1.x, y: L1.y };
        }

        // perpendicular line (dashed coral)
        const sP = toS(P.x, P.y), sF = toS(foot.x, foot.y);
        ctx.setLineDash([6, 4]);
        ctx.strokeStyle = '#f87171'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(sP.x, sP.y); ctx.lineTo(sF.x, sF.y); ctx.stroke();
        ctx.setLineDash([]);

        // right angle mark at foot
        if (dist > 0.2) {
            const sz = 10;
            const perpAng = Math.atan2(-(P.y - foot.y), P.x - foot.x);
            const lineAng = Math.atan2(-dly, dlx);
            ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(sF.x + sz * Math.cos(perpAng), sF.y + sz * Math.sin(perpAng));
            ctx.lineTo(sF.x + sz * Math.cos(perpAng) + sz * Math.cos(lineAng), sF.y + sz * Math.sin(perpAng) + sz * Math.sin(lineAng));
            ctx.lineTo(sF.x + sz * Math.cos(lineAng), sF.y + sz * Math.sin(lineAng));
            ctx.stroke();
        }

        // distance label
        const midPerp = { x: (sP.x + sF.x) / 2, y: (sP.y + sF.y) / 2 };
        ctx.font = '12px Courier New'; ctx.fillStyle = '#f87171';
        ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
        ctx.fillText('d=' + dist.toFixed(3), midPerp.x + 12, midPerp.y - 6);

        // foot of perpendicular dot
        ctx.fillStyle = '#2ecc71';
        ctx.beginPath(); ctx.arc(sF.x, sF.y, 5, 0, Math.PI * 2); ctx.fill();
        ctx.font = '10px Georgia'; ctx.fillStyle = '#2ecc71'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
        ctx.fillText('F(' + r2(foot.x) + ', ' + r2(foot.y) + ')', sF.x + 8, sF.y + 6);

        // show some other distances (to prove perpendicular is shortest)
        ctx.setLineDash([2, 3]);
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
        for (let tt = -3; tt <= 3; tt += 1.5) {
            if (Math.abs(tt) < 0.5) continue;
            const tFoot = { x: foot.x + tt * dlx / Math.sqrt(dlx * dlx + dly * dly), y: foot.y + tt * dly / Math.sqrt(dlx * dlx + dly * dly) };
            const sTf = toS(tFoot.x, tFoot.y);
            ctx.beginPath(); ctx.moveTo(sP.x, sP.y); ctx.lineTo(sTf.x, sTf.y); ctx.stroke();
        }
        ctx.setLineDash([]);

        // control points
        ctx.fillStyle = '#f87171';
        ctx.beginPath(); ctx.arc(sP.x, sP.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.font = '13px Georgia'; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
        ctx.fillText('P(' + r2(P.x) + ', ' + r2(P.y) + ')', sP.x - 8, sP.y - 8);

        const sL1 = toS(L1.x, L1.y), sL2 = toS(L2.x, L2.y);
        ctx.fillStyle = '#67e8f9';
        ctx.beginPath(); ctx.arc(sL1.x, sL1.y, 5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(sL2.x, sL2.y, 5, 0, Math.PI * 2); ctx.fill();

        updatePtlMath(a, b, c, num, den, dist);
    }

    function updatePtlMath(a, b, c, num, den, dist) {
        // display as ax + by + c = 0 form (rewrite: a*x + b*y - c = 0)
        const ac = a, bc = b, cc = -c;
        let html = '';
        html += '<div class="math-line">Line: <span class="cyan">' + r2(ac) + 'x + ' + r2s(bc) + 'y + ' + r2s(cc) + ' = 0</span></div>';
        html += '<div class="math-line">Point: <span class="coral">P = (' + r2(P.x) + ', ' + r2(P.y) + ')</span></div>';
        html += '<hr style="border:none;border-top:1px solid rgba(255,255,255,0.06);margin:8px 0">';
        html += '<div class="math-line">d = |ax\u2080 + by\u2080 + c| / &radic;(a&sup2; + b&sup2;)</div>';
        html += '<div class="math-line">d = |' + r2(ac) + '(' + r2(P.x) + ') + ' + r2s(bc) + '(' + r2(P.y) + ') + ' + r2s(cc) + '| / &radic;(' + r2(ac * ac) + ' + ' + r2(bc * bc) + ')</div>';
        html += '<div class="math-line">d = ' + r2(num) + ' / ' + r2(den) + ' = <span class="coral">' + dist.toFixed(4) + '</span></div>';
        html += '<div class="math-line muted" style="margin-top:6px">The dashed gray lines show other distances from P to the line &mdash; the perpendicular (coral) is always shortest.</div>';
        document.getElementById('ptlMath').innerHTML = html;
    }

    // drag
    function getP(e) {
        const r = cvs.getBoundingClientRect();
        return { x: (e.clientX - r.left) * (W / r.width), y: (e.clientY - r.top) * (H / r.height) };
    }
    function d2(a, b) { return (a.x - b.x) ** 2 + (a.y - b.y) ** 2; }

    cvs.addEventListener('mousedown', e => {
        const p = getP(e);
        const sP = toS(P.x, P.y), sL1 = toS(L1.x, L1.y), sL2 = toS(L2.x, L2.y);
        if (d2(p, sP) < 200) drag = 'P';
        else if (d2(p, sL1) < 200) drag = 'L1';
        else if (d2(p, sL2) < 200) drag = 'L2';
        else drag = null;
    });
    cvs.addEventListener('mousemove', e => {
        if (!drag) return;
        const p = getP(e), c = toW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        if (drag === 'P') { P.x = c.x; P.y = c.y; }
        else if (drag === 'L1') { L1.x = c.x; L1.y = c.y; }
        else if (drag === 'L2') { L2.x = c.x; L2.y = c.y; }
        draw();
    });
    cvs.addEventListener('mouseup', () => { drag = null; });
    cvs.addEventListener('mouseleave', () => { drag = null; });
    // touch
    cvs.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0], r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        const sP = toS(P.x, P.y), sL1 = toS(L1.x, L1.y), sL2 = toS(L2.x, L2.y);
        if (d2(p, sP) < 600) drag = 'P';
        else if (d2(p, sL1) < 600) drag = 'L1';
        else if (d2(p, sL2) < 600) drag = 'L2';
    }, { passive: false });
    cvs.addEventListener('touchmove', e => {
        e.preventDefault(); if (!drag) return;
        const t = e.touches[0], r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        const c = toW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        if (drag === 'P') { P.x = c.x; P.y = c.y; }
        else if (drag === 'L1') { L1.x = c.x; L1.y = c.y; }
        else if (drag === 'L2') { L2.x = c.x; L2.y = c.y; }
        draw();
    }, { passive: false });
    cvs.addEventListener('touchend', () => { drag = null; });

    draw();
})();

/* ══════════════════════════════════════════════════════════════════════════
   SECTION 4: Locus Explorer
   ══════════════════════════════════════════════════════════════════════════ */
(function(){
    const cvs = document.getElementById('locusCanvas');
    const ctx = cvs.getContext('2d');
    const W = cvs.width, H = cvs.height;
    const scale = 40, ox = W / 2, oy = H / 2;

    let locusMode = 'circle'; // circle, bisector, anglebisector, parabola
    // circle: center C, radius r
    let C = { x: 0, y: 0 }, radius = 3;
    // bisector: points A, B
    let BA = { x: -3, y: 0 }, BB = { x: 3, y: 0 };
    // angle bisector: two lines through origin for simplicity, defined by angles
    let AL1a = { x: -5, y: -2 }, AL1b = { x: 5, y: 2 };
    let AL2a = { x: -5, y: 2 }, AL2b = { x: 5, y: -1 };
    // parabola: focus F, directrix defined by a horizontal line y = d
    let Focus = { x: 0, y: 1 }, dirY = -1;
    let drag = null;

    function toS(px, py) { return { x: ox + px * scale, y: oy - py * scale }; }
    function toW(sx, sy) { return { x: (sx - ox) / scale, y: -(sy - oy) / scale }; }

    const locusBtns = [
        { id: 'circle', label: 'Circle' },
        { id: 'bisector', label: 'Perp. Bisector' },
        { id: 'anglebisector', label: 'Angle Bisector' },
        { id: 'parabola', label: 'Parabola' }
    ];

    function renderLocusBtns() {
        const c = document.getElementById('locusBtns');
        c.innerHTML = locusBtns.map(o => '<button class="btn' + (o.id === locusMode ? ' active' : '') + '" data-loc="' + o.id + '">' + o.label + '</button>').join('');
        c.querySelectorAll('.btn').forEach(b => b.addEventListener('click', () => {
            locusMode = b.dataset.loc; renderLocusBtns(); draw();
        }));
    }
    renderLocusBtns();

    function draw() {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#0a0a1a'; ctx.fillRect(0, 0, W, H);
        // grid
        const halfW = W / (2 * scale), halfH = H / (2 * scale);
        ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
        for (let i = Math.ceil(-halfW); i <= Math.floor(halfW); i++) {
            ctx.beginPath(); ctx.moveTo(ox + i * scale, 0); ctx.lineTo(ox + i * scale, H); ctx.stroke();
        }
        for (let i = Math.ceil(-halfH); i <= Math.floor(halfH); i++) {
            ctx.beginPath(); ctx.moveTo(0, oy - i * scale); ctx.lineTo(W, oy - i * scale); ctx.stroke();
        }
        ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(W, oy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ox, 0); ctx.lineTo(ox, H); ctx.stroke();

        if (locusMode === 'circle') drawCircleLocus();
        else if (locusMode === 'bisector') drawBisectorLocus();
        else if (locusMode === 'anglebisector') drawAngleBisectorLocus();
        else if (locusMode === 'parabola') drawParabolaLocus();
    }

    function drawCircleLocus() {
        const sC = toS(C.x, C.y);
        const rPx = radius * scale;

        // sample points
        ctx.fillStyle = 'rgba(248,113,113,0.25)';
        for (let i = 0; i < 24; i++) {
            const th = (2 * Math.PI * i) / 24;
            const px = C.x + radius * Math.cos(th), py = C.y + radius * Math.sin(th);
            const s = toS(px, py);
            ctx.beginPath(); ctx.arc(s.x, s.y, 3, 0, Math.PI * 2); ctx.fill();
            // dashed radius line to a few points
            if (i % 6 === 0) {
                ctx.setLineDash([3, 3]);
                ctx.strokeStyle = 'rgba(248,113,113,0.15)'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(sC.x, sC.y); ctx.lineTo(s.x, s.y); ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // continuous circle
        ctx.strokeStyle = '#f87171'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(sC.x, sC.y, rPx, 0, Math.PI * 2); ctx.stroke();

        // fill lightly
        ctx.fillStyle = 'rgba(248,113,113,0.04)';
        ctx.beginPath(); ctx.arc(sC.x, sC.y, rPx, 0, Math.PI * 2); ctx.fill();

        // center point
        ctx.fillStyle = '#f87171';
        ctx.beginPath(); ctx.arc(sC.x, sC.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.font = '12px Georgia'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
        ctx.fillText('C(' + r2(C.x) + ', ' + r2(C.y) + ')', sC.x + 10, sC.y - 8);

        // radius handle: point on circle at 0 degrees
        const rHandle = { x: C.x + radius, y: C.y };
        const sR = toS(rHandle.x, rHandle.y);
        ctx.fillStyle = '#67e8f9';
        ctx.beginPath(); ctx.arc(sR.x, sR.y, 5, 0, Math.PI * 2); ctx.fill();
        ctx.font = '10px Georgia'; ctx.fillStyle = '#67e8f9'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
        ctx.fillText('r=' + r2(radius), sR.x + 6, sR.y + 6);

        // equation
        let eq = '';
        if (Math.abs(C.x) < 0.01 && Math.abs(C.y) < 0.01) {
            eq = 'x&sup2; + y&sup2; = ' + r2(radius * radius);
        } else {
            eq = '(x &minus; ' + r2s(C.x) + ')&sup2; + (y &minus; ' + r2s(C.y) + ')&sup2; = ' + r2(radius * radius);
        }
        document.getElementById('locusMath').innerHTML =
            '<div class="math-line">Locus: set of all points at distance <span class="coral">r = ' + r2(radius) + '</span> from center C</div>' +
            '<div class="math-line"><span class="coral">' + eq + '</span></div>';
    }

    function drawBisectorLocus() {
        const sA = toS(BA.x, BA.y), sB = toS(BB.x, BB.y);

        // segment AB
        ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(sA.x, sA.y); ctx.lineTo(sB.x, sB.y); ctx.stroke();

        // midpoint
        const mx = (BA.x + BB.x) / 2, my = (BA.y + BB.y) / 2;
        const sM = toS(mx, my);

        // perpendicular bisector direction
        const dx = BB.x - BA.x, dy = BB.y - BA.y;
        // perpendicular direction: (-dy, dx)
        const pdx = -dy, pdy = dx;
        const len = Math.sqrt(pdx * pdx + pdy * pdy);
        if (len > 1e-9) {
            const ndx = pdx / len, ndy = pdy / len;
            // draw extended line
            const t = 20;
            const s1 = toS(mx - t * ndx, my - t * ndy);
            const s2 = toS(mx + t * ndx, my + t * ndy);
            ctx.strokeStyle = '#f87171'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();

            // sample points on the bisector
            ctx.fillStyle = 'rgba(248,113,113,0.3)';
            for (let tt = -4; tt <= 4; tt += 1) {
                const px = mx + tt * ndx, py = my + tt * ndy;
                const s = toS(px, py);
                ctx.beginPath(); ctx.arc(s.x, s.y, 3, 0, Math.PI * 2); ctx.fill();
                // show equal distances
                if (Math.abs(tt) > 0.5 && Math.abs(tt) < 3.5 && tt % 2 === 0) {
                    ctx.setLineDash([2, 2]);
                    ctx.strokeStyle = 'rgba(248,113,113,0.12)'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(sA.x, sA.y); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(sB.x, sB.y); ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        // midpoint dot
        ctx.fillStyle = '#2ecc71';
        ctx.beginPath(); ctx.arc(sM.x, sM.y, 4, 0, Math.PI * 2); ctx.fill();

        // points A, B
        ctx.fillStyle = '#f87171';
        ctx.beginPath(); ctx.arc(sA.x, sA.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.font = '12px Georgia'; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
        ctx.fillText('A(' + r2(BA.x) + ', ' + r2(BA.y) + ')', sA.x - 8, sA.y - 8);

        ctx.fillStyle = '#67e8f9';
        ctx.beginPath(); ctx.arc(sB.x, sB.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.font = '12px Georgia'; ctx.fillStyle = '#67e8f9'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
        ctx.fillText('B(' + r2(BB.x) + ', ' + r2(BB.y) + ')', sB.x + 8, sB.y - 8);

        // equation: perpendicular bisector of AB
        // (x - x1)(x2 - x1) + (y - y1)(y2 - y1) = ((x2-x1)^2 + (y2-y1)^2)/2
        // or: 2(x2-x1)x + 2(y2-y1)y = x2^2 - x1^2 + y2^2 - y1^2
        const a2 = 2 * (BB.x - BA.x), b2 = 2 * (BB.y - BA.y);
        const c2 = BB.x * BB.x - BA.x * BA.x + BB.y * BB.y - BA.y * BA.y;
        document.getElementById('locusMath').innerHTML =
            '<div class="math-line">Locus: set of all points equidistant from A and B</div>' +
            '<div class="math-line">Condition: |PA| = |PB|</div>' +
            '<div class="math-line"><span class="coral">' + r2(a2) + 'x + ' + r2s(b2) + 'y = ' + r2(c2) + '</span></div>';
    }

    function drawAngleBisectorLocus() {
        // two lines
        extLineCtx(AL1a, AL1b, '#67e8f9', 1.5);
        extLineCtx(AL2a, AL2b, '#fbbf24', 1.5);

        // general form of each line
        const a1 = AL1b.y - AL1a.y, b1 = AL1a.x - AL1b.x, c1 = a1 * AL1a.x + b1 * AL1a.y;
        const a2 = AL2b.y - AL2a.y, b2 = AL2a.x - AL2b.x, c2 = a2 * AL2a.x + b2 * AL2a.y;
        const d1 = Math.sqrt(a1 * a1 + b1 * b1);
        const d2_len = Math.sqrt(a2 * a2 + b2 * b2);

        if (d1 > 1e-9 && d2_len > 1e-9) {
            // angle bisectors: (a1x + b1y - c1)/d1 = +/- (a2x + b2y - c2)/d2
            // draw by sampling
            ctx.lineWidth = 2;
            for (let sign = -1; sign <= 1; sign += 2) {
                const pts = [];
                for (let sx = 0; sx < W; sx += 2) {
                    // for each x, solve for y
                    const wx = (sx - ox) / scale;
                    // (a1*wx + b1*wy - c1)/d1 = sign*(a2*wx + b2*wy - c2)/d2
                    // b1*wy/d1 - sign*b2*wy/d2 = sign*(a2*wx - c2)/d2 - (a1*wx - c1)/d1
                    const lhs_coeff = b1 / d1 - sign * b2 / d2_len;
                    const rhs = sign * (a2 * wx - c2) / d2_len - (a1 * wx - c1) / d1;
                    if (Math.abs(lhs_coeff) < 1e-9) continue;
                    const wy = rhs / lhs_coeff;
                    const sy = oy - wy * scale;
                    if (sy >= -10 && sy <= H + 10) pts.push({ x: sx, y: sy });
                }
                if (pts.length > 1) {
                    ctx.strokeStyle = sign === 1 ? '#f87171' : 'rgba(248,113,113,0.4)';
                    ctx.beginPath();
                    let started = false;
                    for (let i = 0; i < pts.length; i++) {
                        if (!started) { ctx.moveTo(pts[i].x, pts[i].y); started = true; }
                        else {
                            // discontinuity check
                            if (Math.abs(pts[i].y - pts[i - 1].y) > H / 2) {
                                ctx.stroke();
                                ctx.beginPath();
                                ctx.moveTo(pts[i].x, pts[i].y);
                            } else {
                                ctx.lineTo(pts[i].x, pts[i].y);
                            }
                        }
                    }
                    ctx.stroke();
                }
            }

            // sample points on bisector showing equal distances
            ctx.fillStyle = 'rgba(248,113,113,0.3)';
            for (let sx = 50; sx < W; sx += 80) {
                const wx = (sx - ox) / scale;
                const lhs_coeff = b1 / d1 - b2 / d2_len;
                if (Math.abs(lhs_coeff) < 1e-9) continue;
                const rhs = (a2 * wx - c2) / d2_len - (a1 * wx - c1) / d1;
                const wy = rhs / lhs_coeff;
                const sy = oy - wy * scale;
                if (sy > 10 && sy < H - 10) {
                    ctx.beginPath(); ctx.arc(sx, sy, 3, 0, Math.PI * 2); ctx.fill();
                }
            }
        }

        // control points
        drawCtrlLoc(AL1a, '#67e8f9', 'L\u2081a');
        drawCtrlLoc(AL1b, '#67e8f9', 'L\u2081b');
        drawCtrlLoc(AL2a, '#fbbf24', 'L\u2082a');
        drawCtrlLoc(AL2b, '#fbbf24', 'L\u2082b');

        document.getElementById('locusMath').innerHTML =
            '<div class="math-line">Locus: set of all points equidistant from two lines</div>' +
            '<div class="math-line">Condition: distance to Line 1 = distance to Line 2</div>' +
            '<div class="math-line"><span class="coral">(a\u2081x + b\u2081y + c\u2081)/&radic;(a\u2081&sup2;+b\u2081&sup2;) = &plusmn;(a\u2082x + b\u2082y + c\u2082)/&radic;(a\u2082&sup2;+b\u2082&sup2;)</span></div>' +
            '<div class="math-line muted">Two bisectors exist &mdash; one for each sign (&plusmn;). The brighter line is the (+) bisector.</div>';
    }

    function drawParabolaLocus() {
        const sF = toS(Focus.x, Focus.y);

        // directrix line (horizontal at y = dirY)
        const sDir = oy - dirY * scale;
        ctx.strokeStyle = '#67e8f9'; ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.beginPath(); ctx.moveTo(0, sDir); ctx.lineTo(W, sDir); ctx.stroke();
        ctx.setLineDash([]);
        ctx.font = '11px Georgia'; ctx.fillStyle = '#67e8f9'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
        ctx.fillText('directrix: y = ' + r2(dirY), 10, sDir - 6);

        // parabola curve: equidistant from focus and directrix
        // |y - dirY| = sqrt((x - Fx)^2 + (y - Fy)^2)
        // solving: y = (x^2 - 2*Fx*x + Fx^2 + Fy^2 - dirY^2) / (2*(Fy - dirY))
        const denom = 2 * (Focus.y - dirY);
        if (Math.abs(denom) > 0.01) {
            ctx.strokeStyle = '#f87171'; ctx.lineWidth = 2;
            ctx.beginPath();
            let started = false;
            for (let sx = 0; sx < W; sx += 1) {
                const wx = (sx - ox) / scale;
                const wy = (wx * wx - 2 * Focus.x * wx + Focus.x * Focus.x + Focus.y * Focus.y - dirY * dirY) / denom;
                const sy = oy - wy * scale;
                if (sy >= -10 && sy <= H + 10) {
                    if (!started) { ctx.moveTo(sx, sy); started = true; }
                    else ctx.lineTo(sx, sy);
                }
            }
            ctx.stroke();

            // sample points with equal distance lines
            ctx.fillStyle = 'rgba(248,113,113,0.3)';
            for (let i = -3; i <= 3; i++) {
                const wx = Focus.x + i * 1.2;
                const wy = (wx * wx - 2 * Focus.x * wx + Focus.x * Focus.x + Focus.y * Focus.y - dirY * dirY) / denom;
                const s = toS(wx, wy);
                if (s.y > 10 && s.y < H - 10) {
                    ctx.beginPath(); ctx.arc(s.x, s.y, 3, 0, Math.PI * 2); ctx.fill();
                    // line to focus
                    ctx.setLineDash([2, 2]);
                    ctx.strokeStyle = 'rgba(248,113,113,0.15)'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(sF.x, sF.y); ctx.stroke();
                    // line to directrix
                    ctx.strokeStyle = 'rgba(103,232,249,0.15)';
                    ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x, sDir); ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // vertex
            const vx = Focus.x;
            const vy = (Focus.y + dirY) / 2;
            const sV = toS(vx, vy);
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath(); ctx.arc(sV.x, sV.y, 4, 0, Math.PI * 2); ctx.fill();
            ctx.font = '10px Georgia'; ctx.fillStyle = '#2ecc71'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
            ctx.fillText('V', sV.x + 6, sV.y + 2);
        }

        // focus
        ctx.fillStyle = '#f87171';
        ctx.beginPath(); ctx.arc(sF.x, sF.y, 6, 0, Math.PI * 2); ctx.fill();
        ctx.font = '12px Georgia'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
        ctx.fillText('F(' + r2(Focus.x) + ', ' + r2(Focus.y) + ')', sF.x + 10, sF.y - 8);

        // directrix drag handle
        const dirHandle = toS(0, dirY);
        ctx.fillStyle = '#67e8f9';
        ctx.beginPath(); ctx.arc(dirHandle.x, dirHandle.y, 5, 0, Math.PI * 2); ctx.fill();

        // equation
        const p = (Focus.y - dirY) / 2; // distance from vertex to focus
        let eq;
        if (Math.abs(Focus.x) < 0.01) {
            eq = 'x&sup2; = ' + r2(4 * p) + '(y &minus; ' + r2s((Focus.y + dirY) / 2) + ')';
        } else {
            eq = '(x &minus; ' + r2s(Focus.x) + ')&sup2; = ' + r2(4 * p) + '(y &minus; ' + r2s((Focus.y + dirY) / 2) + ')';
        }
        document.getElementById('locusMath').innerHTML =
            '<div class="math-line">Locus: set of all points equidistant from focus F and directrix</div>' +
            '<div class="math-line">Condition: |PF| = distance from P to directrix</div>' +
            '<div class="math-line"><span class="coral">' + eq + '</span></div>' +
            '<div class="math-line muted">p = ' + r2(Math.abs(p)) + ' (focal parameter = half the distance from focus to directrix)</div>';
    }

    function extLineCtx(P, Q, color, lw) {
        const dx = Q.x - P.x, dy = Q.y - P.y;
        if (Math.abs(dx) < 1e-9 && Math.abs(dy) < 1e-9) return;
        const t0 = -100, t1 = 100;
        const sx = ox + (P.x + t0 * dx) * scale, sy = oy - (P.y + t0 * dy) * scale;
        const ex = ox + (P.x + t1 * dx) * scale, ey = oy - (P.y + t1 * dy) * scale;
        ctx.strokeStyle = color; ctx.lineWidth = lw;
        ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
    }

    function drawCtrlLoc(pt, color, label) {
        const s = toS(pt.x, pt.y);
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(s.x, s.y, 5, 0, Math.PI * 2); ctx.fill();
        ctx.font = '10px Georgia'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
        ctx.fillText(label, s.x + 7, s.y - 5);
    }

    // drag
    function getP(e) {
        const r = cvs.getBoundingClientRect();
        return { x: (e.clientX - r.left) * (W / r.width), y: (e.clientY - r.top) * (H / r.height) };
    }
    function d2(a, b) { return (a.x - b.x) ** 2 + (a.y - b.y) ** 2; }

    function getDragTargets() {
        if (locusMode === 'circle') {
            const rHandle = toS(C.x + radius, C.y);
            return [
                { ref: C, key: 'C', s: toS(C.x, C.y) },
                { ref: null, key: 'R', s: rHandle }
            ];
        } else if (locusMode === 'bisector') {
            return [
                { ref: BA, key: 'BA', s: toS(BA.x, BA.y) },
                { ref: BB, key: 'BB', s: toS(BB.x, BB.y) }
            ];
        } else if (locusMode === 'anglebisector') {
            return [
                { ref: AL1a, key: 'AL1a', s: toS(AL1a.x, AL1a.y) },
                { ref: AL1b, key: 'AL1b', s: toS(AL1b.x, AL1b.y) },
                { ref: AL2a, key: 'AL2a', s: toS(AL2a.x, AL2a.y) },
                { ref: AL2b, key: 'AL2b', s: toS(AL2b.x, AL2b.y) }
            ];
        } else if (locusMode === 'parabola') {
            const dirHandle = toS(0, dirY);
            return [
                { ref: Focus, key: 'F', s: toS(Focus.x, Focus.y) },
                { ref: null, key: 'D', s: dirHandle }
            ];
        }
        return [];
    }

    cvs.addEventListener('mousedown', e => {
        const p = getP(e); drag = null;
        for (const t of getDragTargets()) {
            if (d2(p, t.s) < 200) { drag = t.key; break; }
        }
    });
    cvs.addEventListener('mousemove', e => {
        if (!drag) return;
        const p = getP(e), c = toW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        applyDrag(c);
        draw();
    });
    cvs.addEventListener('mouseup', () => { drag = null; });
    cvs.addEventListener('mouseleave', () => { drag = null; });
    // touch
    cvs.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0], r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        drag = null;
        for (const tgt of getDragTargets()) {
            if (d2(p, tgt.s) < 600) { drag = tgt.key; break; }
        }
    }, { passive: false });
    cvs.addEventListener('touchmove', e => {
        e.preventDefault(); if (!drag) return;
        const t = e.touches[0], r = cvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (W / r.width), y: (t.clientY - r.top) * (H / r.height) };
        const c = toW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        applyDrag(c);
        draw();
    }, { passive: false });
    cvs.addEventListener('touchend', () => { drag = null; });

    function applyDrag(c) {
        if (drag === 'C') { C.x = c.x; C.y = c.y; }
        else if (drag === 'R') { radius = Math.max(0.5, Math.sqrt((c.x - C.x) ** 2 + (c.y - C.y) ** 2)); }
        else if (drag === 'BA') { BA.x = c.x; BA.y = c.y; }
        else if (drag === 'BB') { BB.x = c.x; BB.y = c.y; }
        else if (drag === 'AL1a') { AL1a.x = c.x; AL1a.y = c.y; }
        else if (drag === 'AL1b') { AL1b.x = c.x; AL1b.y = c.y; }
        else if (drag === 'AL2a') { AL2a.x = c.x; AL2a.y = c.y; }
        else if (drag === 'AL2b') { AL2b.x = c.x; AL2b.y = c.y; }
        else if (drag === 'F') { Focus.x = c.x; Focus.y = c.y; }
        else if (drag === 'D') { dirY = c.y; }
    }

    draw();
})();

/* ══════════════════════════════════════════════════════════════════════════
   SECTION 5: Section Formula & Area
   ══════════════════════════════════════════════════════════════════════════ */
(function(){
    // Section Formula
    const secCvs = document.getElementById('secCanvas');
    const secCtx = secCvs.getContext('2d');
    const SW = secCvs.width, SH = secCvs.height;
    const sScale = 35, sox = SW / 2, soy = SH / 2;

    let SA = { x: -4, y: -2 }, SB = { x: 4, y: 3 };
    let secDrag = null;
    let isExternal = false;

    function toSS(px, py) { return { x: sox + px * sScale, y: soy - py * sScale }; }
    function toSW(sx, sy) { return { x: (sx - sox) / sScale, y: -(sy - soy) / sScale }; }

    function drawSec() {
        secCtx.clearRect(0, 0, SW, SH);
        secCtx.fillStyle = '#0a0a1a'; secCtx.fillRect(0, 0, SW, SH);
        // grid
        const halfW = SW / (2 * sScale), halfH = SH / (2 * sScale);
        secCtx.strokeStyle = 'rgba(255,255,255,0.05)'; secCtx.lineWidth = 1;
        for (let i = Math.ceil(-halfW); i <= Math.floor(halfW); i++) {
            secCtx.beginPath(); secCtx.moveTo(sox + i * sScale, 0); secCtx.lineTo(sox + i * sScale, SH); secCtx.stroke();
        }
        for (let i = Math.ceil(-halfH); i <= Math.floor(halfH); i++) {
            secCtx.beginPath(); secCtx.moveTo(0, soy - i * sScale); secCtx.lineTo(SW, soy - i * sScale); secCtx.stroke();
        }
        secCtx.strokeStyle = 'rgba(255,255,255,0.18)'; secCtx.lineWidth = 1.5;
        secCtx.beginPath(); secCtx.moveTo(0, soy); secCtx.lineTo(SW, soy); secCtx.stroke();
        secCtx.beginPath(); secCtx.moveTo(sox, 0); secCtx.lineTo(sox, SH); secCtx.stroke();

        const m = parseInt(document.getElementById('secM').value);
        const n = parseInt(document.getElementById('secN').value);
        document.getElementById('secMLabel').textContent = m;
        document.getElementById('secNLabel').textContent = n;

        let px, py;
        if (!isExternal) {
            // internal: P = (m*x2 + n*x1)/(m+n), (m*y2 + n*y1)/(m+n)
            px = (m * SB.x + n * SA.x) / (m + n);
            py = (m * SB.y + n * SA.y) / (m + n);
        } else {
            // external: P = (m*x2 - n*x1)/(m-n), (m*y2 - n*y1)/(m-n)
            if (m === n) {
                px = null; py = null; // point at infinity
            } else {
                px = (m * SB.x - n * SA.x) / (m - n);
                py = (m * SB.y - n * SA.y) / (m - n);
            }
        }

        const ssA = toSS(SA.x, SA.y), ssB = toSS(SB.x, SB.y);

        // line AB extended
        const dx = SB.x - SA.x, dy = SB.y - SA.y;
        if (Math.abs(dx) > 1e-9 || Math.abs(dy) > 1e-9) {
            secCtx.strokeStyle = 'rgba(255,255,255,0.12)'; secCtx.lineWidth = 1;
            const t0 = -10, t1 = 10;
            secCtx.beginPath();
            secCtx.moveTo(sox + (SA.x + t0 * dx) * sScale, soy - (SA.y + t0 * dy) * sScale);
            secCtx.lineTo(sox + (SA.x + t1 * dx) * sScale, soy - (SA.y + t1 * dy) * sScale);
            secCtx.stroke();
        }

        // segment AB
        secCtx.strokeStyle = 'rgba(255,255,255,0.3)'; secCtx.lineWidth = 2;
        secCtx.beginPath(); secCtx.moveTo(ssA.x, ssA.y); secCtx.lineTo(ssB.x, ssB.y); secCtx.stroke();

        // dividing point
        if (px !== null && py !== null) {
            const sP = toSS(px, py);
            if (sP.x > -50 && sP.x < SW + 50 && sP.y > -50 && sP.y < SH + 50) {
                secCtx.fillStyle = '#2ecc71';
                secCtx.beginPath(); secCtx.arc(sP.x, sP.y, 6, 0, Math.PI * 2); secCtx.fill();
                secCtx.font = '11px Georgia'; secCtx.fillStyle = '#2ecc71'; secCtx.textAlign = 'left'; secCtx.textBaseline = 'bottom';
                secCtx.fillText('P(' + r2(px) + ', ' + r2(py) + ')', sP.x + 8, sP.y - 6);
            }
        }

        // points A, B
        secCtx.fillStyle = '#f87171';
        secCtx.beginPath(); secCtx.arc(ssA.x, ssA.y, 6, 0, Math.PI * 2); secCtx.fill();
        secCtx.font = '12px Georgia'; secCtx.textAlign = 'right'; secCtx.textBaseline = 'bottom';
        secCtx.fillText('A', ssA.x - 8, ssA.y - 8);

        secCtx.fillStyle = '#67e8f9';
        secCtx.beginPath(); secCtx.arc(ssB.x, ssB.y, 6, 0, Math.PI * 2); secCtx.fill();
        secCtx.font = '12px Georgia'; secCtx.fillStyle = '#67e8f9'; secCtx.textAlign = 'left'; secCtx.textBaseline = 'bottom';
        secCtx.fillText('B', ssB.x + 8, ssB.y - 8);

        // math
        let html = '';
        html += '<div class="math-line"><span class="coral">A = (' + r2(SA.x) + ', ' + r2(SA.y) + ')</span> &emsp; <span class="cyan">B = (' + r2(SB.x) + ', ' + r2(SB.y) + ')</span></div>';
        html += '<div class="math-line">Ratio m:n = ' + m + ':' + n + ' &emsp;(' + (isExternal ? 'external' : 'internal') + ' division)</div>';
        if (!isExternal) {
            html += '<div class="math-line">P = ((' + m + '&middot;' + r2(SB.x) + ' + ' + n + '&middot;' + r2(SA.x) + ')/(' + m + '+' + n + '), (' + m + '&middot;' + r2(SB.y) + ' + ' + n + '&middot;' + r2(SA.y) + ')/(' + m + '+' + n + '))</div>';
        } else {
            html += '<div class="math-line">P = ((' + m + '&middot;' + r2(SB.x) + ' &minus; ' + n + '&middot;' + r2(SA.x) + ')/(' + m + '&minus;' + n + '), (' + m + '&middot;' + r2(SB.y) + ' &minus; ' + n + '&middot;' + r2(SA.y) + ')/(' + m + '&minus;' + n + '))</div>';
        }
        if (px !== null && py !== null) {
            html += '<div class="math-line"><span class="green">P = (' + r2(px) + ', ' + r2(py) + ')</span></div>';
        } else {
            html += '<div class="math-line muted">m = n in external division: point at infinity (parallel line)</div>';
        }
        document.getElementById('secMath').innerHTML = html;
    }

    document.getElementById('secM').addEventListener('input', drawSec);
    document.getElementById('secN').addEventListener('input', drawSec);
    document.getElementById('intDivBtn').addEventListener('click', () => {
        isExternal = false;
        document.getElementById('intDivBtn').classList.add('active');
        document.getElementById('extDivBtn').classList.remove('active');
        drawSec();
    });
    document.getElementById('extDivBtn').addEventListener('click', () => {
        isExternal = true;
        document.getElementById('extDivBtn').classList.add('active');
        document.getElementById('intDivBtn').classList.remove('active');
        drawSec();
    });

    // drag
    function getP(e) {
        const r = secCvs.getBoundingClientRect();
        return { x: (e.clientX - r.left) * (SW / r.width), y: (e.clientY - r.top) * (SH / r.height) };
    }
    function d2(a, b) { return (a.x - b.x) ** 2 + (a.y - b.y) ** 2; }

    secCvs.addEventListener('mousedown', e => {
        const p = getP(e);
        if (d2(p, toSS(SA.x, SA.y)) < 200) secDrag = 'A';
        else if (d2(p, toSS(SB.x, SB.y)) < 200) secDrag = 'B';
        else secDrag = null;
    });
    secCvs.addEventListener('mousemove', e => {
        if (!secDrag) return;
        const p = getP(e), c = toSW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        if (secDrag === 'A') { SA.x = c.x; SA.y = c.y; }
        else { SB.x = c.x; SB.y = c.y; }
        drawSec();
    });
    secCvs.addEventListener('mouseup', () => { secDrag = null; });
    secCvs.addEventListener('mouseleave', () => { secDrag = null; });
    secCvs.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0], r = secCvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (SW / r.width), y: (t.clientY - r.top) * (SH / r.height) };
        if (d2(p, toSS(SA.x, SA.y)) < 600) secDrag = 'A';
        else if (d2(p, toSS(SB.x, SB.y)) < 600) secDrag = 'B';
    }, { passive: false });
    secCvs.addEventListener('touchmove', e => {
        e.preventDefault(); if (!secDrag) return;
        const t = e.touches[0], r = secCvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (SW / r.width), y: (t.clientY - r.top) * (SH / r.height) };
        const c = toSW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        if (secDrag === 'A') { SA.x = c.x; SA.y = c.y; }
        else { SB.x = c.x; SB.y = c.y; }
        drawSec();
    }, { passive: false });
    secCvs.addEventListener('touchend', () => { secDrag = null; });

    drawSec();

    // Triangle Area
    const triCvs = document.getElementById('triCanvas');
    const triCtx = triCvs.getContext('2d');
    const TW = triCvs.width, TH = triCvs.height;
    const tScale = 35, tox = TW / 2, toy = TH / 2;

    let T1 = { x: -3, y: -2 }, T2 = { x: 4, y: -1 }, T3 = { x: 1, y: 3 };
    let triDrag = null;

    function toTS(px, py) { return { x: tox + px * tScale, y: toy - py * tScale }; }
    function toTW(sx, sy) { return { x: (sx - tox) / tScale, y: -(sy - toy) / tScale }; }

    function drawTri() {
        triCtx.clearRect(0, 0, TW, TH);
        triCtx.fillStyle = '#0a0a1a'; triCtx.fillRect(0, 0, TW, TH);
        // grid
        const halfW = TW / (2 * tScale), halfH = TH / (2 * tScale);
        triCtx.strokeStyle = 'rgba(255,255,255,0.05)'; triCtx.lineWidth = 1;
        for (let i = Math.ceil(-halfW); i <= Math.floor(halfW); i++) {
            triCtx.beginPath(); triCtx.moveTo(tox + i * tScale, 0); triCtx.lineTo(tox + i * tScale, TH); triCtx.stroke();
        }
        for (let i = Math.ceil(-halfH); i <= Math.floor(halfH); i++) {
            triCtx.beginPath(); triCtx.moveTo(0, toy - i * tScale); triCtx.lineTo(TW, toy - i * tScale); triCtx.stroke();
        }
        triCtx.strokeStyle = 'rgba(255,255,255,0.18)'; triCtx.lineWidth = 1.5;
        triCtx.beginPath(); triCtx.moveTo(0, toy); triCtx.lineTo(TW, toy); triCtx.stroke();
        triCtx.beginPath(); triCtx.moveTo(tox, 0); triCtx.lineTo(tox, TH); triCtx.stroke();

        const s1 = toTS(T1.x, T1.y), s2 = toTS(T2.x, T2.y), s3 = toTS(T3.x, T3.y);

        // area
        const area = Math.abs(T1.x * (T2.y - T3.y) + T2.x * (T3.y - T1.y) + T3.x * (T1.y - T2.y)) / 2;
        const collinear = area < 0.05;

        // filled triangle
        if (!collinear) {
            triCtx.fillStyle = 'rgba(248,113,113,0.08)';
            triCtx.beginPath();
            triCtx.moveTo(s1.x, s1.y); triCtx.lineTo(s2.x, s2.y); triCtx.lineTo(s3.x, s3.y);
            triCtx.closePath(); triCtx.fill();
        }

        // triangle edges
        triCtx.strokeStyle = collinear ? 'rgba(255,255,255,0.25)' : '#f87171';
        triCtx.lineWidth = 2;
        triCtx.beginPath();
        triCtx.moveTo(s1.x, s1.y); triCtx.lineTo(s2.x, s2.y); triCtx.lineTo(s3.x, s3.y);
        triCtx.closePath(); triCtx.stroke();

        // area label at centroid
        if (!collinear) {
            const cx = (s1.x + s2.x + s3.x) / 3, cy = (s1.y + s2.y + s3.y) / 3;
            triCtx.font = '13px Courier New'; triCtx.fillStyle = '#f87171';
            triCtx.textAlign = 'center'; triCtx.textBaseline = 'middle';
            triCtx.fillText('Area = ' + area.toFixed(2), cx, cy);
        }

        // vertices
        const colors = ['#f87171', '#67e8f9', '#2ecc71'];
        const labels = ['P\u2081', 'P\u2082', 'P\u2083'];
        const pts = [T1, T2, T3];
        const spts = [s1, s2, s3];
        for (let i = 0; i < 3; i++) {
            triCtx.fillStyle = colors[i];
            triCtx.beginPath(); triCtx.arc(spts[i].x, spts[i].y, 6, 0, Math.PI * 2); triCtx.fill();
            triCtx.font = '11px Georgia'; triCtx.textAlign = 'left'; triCtx.textBaseline = 'bottom';
            triCtx.fillText(labels[i] + '(' + r2(pts[i].x) + ',' + r2(pts[i].y) + ')', spts[i].x + 8, spts[i].y - 6);
        }

        // math
        let html = '';
        html += '<div class="math-line">Area = &frac12;|x\u2081(y\u2082&minus;y\u2083) + x\u2082(y\u2083&minus;y\u2081) + x\u2083(y\u2081&minus;y\u2082)|</div>';
        html += '<div class="math-line">= &frac12;|' + r2(T1.x) + '(' + r2(T2.y) + '&minus;' + r2s(T3.y) + ') + ' + r2(T2.x) + '(' + r2(T3.y) + '&minus;' + r2s(T1.y) + ') + ' + r2(T3.x) + '(' + r2(T1.y) + '&minus;' + r2s(T2.y) + ')|</div>';
        html += '<div class="math-line">= <span class="coral">' + area.toFixed(4) + ' sq. units</span></div>';
        if (collinear) {
            html += '<div class="math-line" style="color:#f87171;font-size:1.05em;margin-top:6px">Area = 0 &rArr; Points are collinear!</div>';
        }
        document.getElementById('triMath').innerHTML = html;
    }

    // drag
    function getTP(e) {
        const r = triCvs.getBoundingClientRect();
        return { x: (e.clientX - r.left) * (TW / r.width), y: (e.clientY - r.top) * (TH / r.height) };
    }
    function d2(a, b) { return (a.x - b.x) ** 2 + (a.y - b.y) ** 2; }

    triCvs.addEventListener('mousedown', e => {
        const p = getTP(e);
        if (d2(p, toTS(T1.x, T1.y)) < 200) triDrag = 'T1';
        else if (d2(p, toTS(T2.x, T2.y)) < 200) triDrag = 'T2';
        else if (d2(p, toTS(T3.x, T3.y)) < 200) triDrag = 'T3';
        else triDrag = null;
    });
    triCvs.addEventListener('mousemove', e => {
        if (!triDrag) return;
        const p = getTP(e), c = toTW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        if (triDrag === 'T1') { T1.x = c.x; T1.y = c.y; }
        else if (triDrag === 'T2') { T2.x = c.x; T2.y = c.y; }
        else if (triDrag === 'T3') { T3.x = c.x; T3.y = c.y; }
        drawTri();
    });
    triCvs.addEventListener('mouseup', () => { triDrag = null; });
    triCvs.addEventListener('mouseleave', () => { triDrag = null; });
    triCvs.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0], r = triCvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (TW / r.width), y: (t.clientY - r.top) * (TH / r.height) };
        if (d2(p, toTS(T1.x, T1.y)) < 600) triDrag = 'T1';
        else if (d2(p, toTS(T2.x, T2.y)) < 600) triDrag = 'T2';
        else if (d2(p, toTS(T3.x, T3.y)) < 600) triDrag = 'T3';
    }, { passive: false });
    triCvs.addEventListener('touchmove', e => {
        e.preventDefault(); if (!triDrag) return;
        const t = e.touches[0], r = triCvs.getBoundingClientRect();
        const p = { x: (t.clientX - r.left) * (TW / r.width), y: (t.clientY - r.top) * (TH / r.height) };
        const c = toTW(p.x, p.y);
        c.x = Math.round(c.x * 4) / 4; c.y = Math.round(c.y * 4) / 4;
        if (triDrag === 'T1') { T1.x = c.x; T1.y = c.y; }
        else if (triDrag === 'T2') { T2.x = c.x; T2.y = c.y; }
        else if (triDrag === 'T3') { T3.x = c.x; T3.y = c.y; }
        drawTri();
    }, { passive: false });
    triCvs.addEventListener('touchend', () => { triDrag = null; });

    drawTri();
})();

/* (utility functions r2, r2s defined at top of script block) */
</script>
<footer style="text-align:center;padding:28px 20px 18px;color:#505068;font-size:0.72em;line-height:1.7;border-top:1px solid rgba(255,255,255,0.04);margin-top:30px"><div>&copy; 2025&ndash;2026 Manoj Bhaskar &middot; Coded by <a href="https://claude.ai/claude-code" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">Claude</a> &middot; <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:#606078;text-decoration:none" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a></div></footer>
</body>
</html>
